/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"migrando-microservicios-de-nestjs-con-typescript-a-go-una-semana-de-descubrimientos\">Migrando Microservicios de NestJS con TypeScript a Go: Una Semana de Descubrimientos</h1>\n<p>En la última semana, me he sumergido en el mundo de Go con el objetivo de migrar nuestros microservicios desarrollados en NestJS con…</p>\n<hr>\n<h3 id=\"migrando-microservicios-de-nestjs-con-typescript-a-go-una-semana-de-descubrimientos-1\">Migrando Microservicios de NestJS con TypeScript a Go: Una Semana de Descubrimientos</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*9uYraLkbpKaIvlBm.png\" alt=\"\"></p>\n<p>En la última semana, me he sumergido en el mundo de Go con el objetivo de migrar nuestros microservicios desarrollados en NestJS con TypeScript. Esta travesía ha sido un ejercicio intenso de desaprender ciertos paradigmas y adoptar otros, comprendiendo las diferencias fundamentales entre estos dos ecosistemas de desarrollo.</p>\n<h3 id=\"nuestra-arquitectura-ennestjs\">Nuestra Arquitectura en NestJS</h3>\n<p>En nuestro stack con NestJS, manejamos microservicios conectados a bases de datos PostgreSQL y Redis. Implementamos diversas estrategias de comunicación entre microservicios:</p>\n<ol>\n<li><strong>Comunicación por Eventos</strong>: Utilizamos Pub/Sub para suscripciones y tópicos que permiten la comunicación asíncrona entre microservicios.</li>\n<li><strong>Backend for Frontend (BFF)</strong>: Implementamos APIs REST protegidas con JWT, que sirven de intermediarios entre el frontend y la base de datos.</li>\n</ol>\n<h4 id=\"validaciones-y-migraciones\">Validaciones y Migraciones</h4>\n<p>La validación de DTOs y la migración de datos son cruciales en nuestro sistema. TypeScript nos ha permitido definir tipos estrictos y estructuras con Knex y TypeORM para manejar migraciones. Aunque eficaz, este enfoque requiere un conocimiento profundo del lenguaje y de cómo manipular flujos de datos a través de diferentes microservicios.</p>\n<h4 id=\"retos-connestjs\">Retos con NestJS</h4>\n<p>Detectamos problemas de <strong>event loop</strong> que afectaban la performance, los cuales abordamos usando la librería Clinic.js. Identificamos los cuellos de botella y optimizamos el uso de patrones de diseño junto con <code>async</code> y <code>await</code>. Sin embargo, manejar concurrencia en Node.js puede ser complejo y costoso en términos de recursos.</p>\n<h3 id=\"adentrándonos-engo\">Adentrándonos en Go</h3>\n<p>Al explorar Go, nos encontramos con una transición de paradigmas y una serie de diferencias significativas:</p>\n<ol>\n<li><strong>Compilación y Tipado Estático</strong>: A diferencia de TypeScript, Go es un lenguaje compilado con tipado estático fuerte, lo que nos fuerza a detectar errores en tiempo de compilación.</li>\n<li><strong>Control de Flujo y Manejo de Errores</strong>: Go simplifica el manejo de errores a través de su enfoque explícito de retorno de errores, en lugar de excepciones.</li>\n<li><strong>Estructura de Datos y Memoria</strong>: La asignación de memoria y la gestión de estructuras de datos en Go requiere una comprensión más profunda del hardware, lo cual es diferente al enfoque más abstracto de JavaScript.</li>\n</ol>\n<h4 id=\"poo-e-interfaces\">POO e Interfaces</h4>\n<p>En Go, aunque la orientación a objetos es soportada, se manifiesta de manera diferente. La ausencia de herencia tradicional y la utilización de interfaces proporciona una flexibilidad distinta que debe ser entendida a fondo para aprovechar al máximo.</p>\n<h4 id=\"ejemplos-comparativos\">Ejemplos Comparativos</h4>\n<p>Validación de Datos</p>\n<p><strong>NestJS</strong>: Usamos Decoradores en DTOs para la validación.</p>\n<p>import { IsString, IsInt } from ‘class-validator’;</p>\n<p>class CreateUserDto {<br>\n@IsString()<br>\nname: string;</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>@IsInt()  </span></span>\n<span class=\"line\"><span>age: number;  </span></span></code></pre>\n<p>}</p>\n<p><strong>Go</strong>: Usamos librerías como <code>go-playground/validator</code> para la validación.</p>\n<p>import (<br>\n“gopkg.in/go-playground/validator.v9”<br>\n)</p>\n<p>type User struct {<br>\nName string `validate:“required”`<br>\nAge  int    `validate:“gte=0”`<br>\n}</p>\n<p>validate := validator.New()<br>\nuser := &#x26;User{Name: “Alice”, Age: 25}<br>\nerr := validate.Struct(user)</p>\n<p>Comunicación Asíncrona</p>\n<ul>\n<li><strong>NestJS</strong>: Uso de <code>async/await</code> para manejar promesas.</li>\n</ul>\n<p>async function fetchData(): Promise&#x3C;void> {<br>\nconst data = await apiCall();<br>\nconsole.log(data);<br>\n}</p>\n<p><strong>Go</strong>: Uso de gorutinas y canales para concurrencia.</p>\n<p>func fetchData() {<br>\ndataChan := make(chan string)<br>\ngo func() {<br>\ndataChan &#x3C;- apiCall()<br>\n}()<br>\ndata := &#x3C;-dataChan<br>\nfmt.Println(data)<br>\n}</p>\n<h4 id=\"herramientas-y-configuración\">Herramientas y Configuración</h4>\n<p>En Go, hemos adoptado herramientas como <strong>Gin</strong> para APIs REST y <strong>Gorm</strong> como ORM. La configuración de nuestro entorno en VSCode con <code>make</code> para automatizar tareas ha sido crucial para mantener la productividad y adaptarnos a este nuevo flujo de trabajo.</p>\n<h3 id=\"reflexiones-finales\">Reflexiones Finales</h3>\n<p>Migrar de NestJS con TypeScript a Go ha sido desafiante pero también gratificante. Mientras que NestJS ofrece una experiencia enriquecida en el desarrollo rápido de APIs con un enfoque en la reutilización y la abstracción, Go nos ha brindado un control más granular sobre la concurrencia y el rendimiento, esencial para aplicaciones altamente escalables.</p>\n<p>Seguimos experimentando y ajustando nuestros flujos de trabajo, y a pesar de los desafíos, estamos entusiasmados con las posibilidades que ofrece Go para el futuro de nuestros microservicios.</p>\n<hr>\n<p>Espero que este blog sirva como una guía y una inspiración para aquellos que estén considerando una transición similar. ¿Qué experiencias han tenido ustedes con la migración de tecnologías? ¿Qué retos y soluciones han encontrado en el camino?</p>\n<p>¡Compartan sus historias y sigamos aprendiendo juntos!</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/c754ff0cea6a\">June 23, 2024</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/migrando-microservicios-de-nestjs-con-typescript-a-go-una-semana-de-descubrimientos-c754ff0cea6a\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Migrando Microservicios de NestJS con TypeScript a Go: Una Semana de Descubrimientos","description":"","tags":["code","Microservicios","NestJS","Typescript","Go"],"time":4,"featured":true,"timestamp":"2024-06-23T12:20:32-0300","filename":"2024-06-23_Migrando-Microservicios-de-NestJS-con-TypeScript-a-Go--Una-Semana-de-Descubrimientos-c754ff0cea6a"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2024-06-23_Migrando-Microservicios-de-NestJS-con-TypeScript-a-Go--Una-Semana-de-Descubrimientos-c754ff0cea6a.md";
				const url = "/blog/2024-06-23_Migrando-Microservicios-de-NestJS-con-TypeScript-a-Go--Una-Semana-de-Descubrimientos-c754ff0cea6a";
				function rawContent() {
					return "   \n                                        \n                                                                                             \n               \n                                                              \n       \n              \n                                     \n                                                                                                                        \n   \n\nMigrando Microservicios de NestJS con TypeScript a Go: Una Semana de Descubrimientos\n====================================================================================\n\nEn la última semana, me he sumergido en el mundo de Go con el objetivo de migrar nuestros microservicios desarrollados en NestJS con…\n\n* * *\n\n### Migrando Microservicios de NestJS con TypeScript a Go: Una Semana de Descubrimientos\n\n![](https://cdn-images-1.medium.com/max/800/0*9uYraLkbpKaIvlBm.png)\n\nEn la última semana, me he sumergido en el mundo de Go con el objetivo de migrar nuestros microservicios desarrollados en NestJS con TypeScript. Esta travesía ha sido un ejercicio intenso de desaprender ciertos paradigmas y adoptar otros, comprendiendo las diferencias fundamentales entre estos dos ecosistemas de desarrollo.\n\n### Nuestra Arquitectura en NestJS\n\nEn nuestro stack con NestJS, manejamos microservicios conectados a bases de datos PostgreSQL y Redis. Implementamos diversas estrategias de comunicación entre microservicios:\n\n1.  **Comunicación por Eventos**: Utilizamos Pub/Sub para suscripciones y tópicos que permiten la comunicación asíncrona entre microservicios.\n2.  **Backend for Frontend (BFF)**: Implementamos APIs REST protegidas con JWT, que sirven de intermediarios entre el frontend y la base de datos.\n\n#### Validaciones y Migraciones\n\nLa validación de DTOs y la migración de datos son cruciales en nuestro sistema. TypeScript nos ha permitido definir tipos estrictos y estructuras con Knex y TypeORM para manejar migraciones. Aunque eficaz, este enfoque requiere un conocimiento profundo del lenguaje y de cómo manipular flujos de datos a través de diferentes microservicios.\n\n#### Retos con NestJS\n\nDetectamos problemas de **event loop** que afectaban la performance, los cuales abordamos usando la librería Clinic.js. Identificamos los cuellos de botella y optimizamos el uso de patrones de diseño junto con `async` y `await`. Sin embargo, manejar concurrencia en Node.js puede ser complejo y costoso en términos de recursos.\n\n### Adentrándonos en Go\n\nAl explorar Go, nos encontramos con una transición de paradigmas y una serie de diferencias significativas:\n\n1.  **Compilación y Tipado Estático**: A diferencia de TypeScript, Go es un lenguaje compilado con tipado estático fuerte, lo que nos fuerza a detectar errores en tiempo de compilación.\n2.  **Control de Flujo y Manejo de Errores**: Go simplifica el manejo de errores a través de su enfoque explícito de retorno de errores, en lugar de excepciones.\n3.  **Estructura de Datos y Memoria**: La asignación de memoria y la gestión de estructuras de datos en Go requiere una comprensión más profunda del hardware, lo cual es diferente al enfoque más abstracto de JavaScript.\n\n#### POO e Interfaces\n\nEn Go, aunque la orientación a objetos es soportada, se manifiesta de manera diferente. La ausencia de herencia tradicional y la utilización de interfaces proporciona una flexibilidad distinta que debe ser entendida a fondo para aprovechar al máximo.\n\n#### Ejemplos Comparativos\n\nValidación de Datos\n\n**NestJS**: Usamos Decoradores en DTOs para la validación.\n\nimport { IsString, IsInt } from 'class-validator';  \n  \nclass CreateUserDto {  \n    @IsString()  \n    name: string;  \n  \n    @IsInt()  \n    age: number;  \n}\n\n**Go**: Usamos librerías como `go-playground/validator` para la validación.\n\nimport (  \n    \"gopkg.in/go-playground/validator.v9\"  \n)  \n  \ntype User struct {  \n    Name string \\`validate:\"required\"\\`  \n    Age  int    \\`validate:\"gte=0\"\\`  \n}  \n  \nvalidate := validator.New()  \nuser := &User{Name: \"Alice\", Age: 25}  \nerr := validate.Struct(user)\n\nComunicación Asíncrona\n\n*   **NestJS**: Uso de `async/await` para manejar promesas.\n\nasync function fetchData(): Promise<void\\> {  \n    const data = await apiCall();  \n    console.log(data);  \n}\n\n**Go**: Uso de gorutinas y canales para concurrencia.\n\nfunc fetchData() {  \n    dataChan := make(chan string)  \n    go func() {  \n        dataChan <- apiCall()  \n    }()  \n    data := <-dataChan  \n    fmt.Println(data)  \n}\n\n#### Herramientas y Configuración\n\nEn Go, hemos adoptado herramientas como **Gin** para APIs REST y **Gorm** como ORM. La configuración de nuestro entorno en VSCode con `make` para automatizar tareas ha sido crucial para mantener la productividad y adaptarnos a este nuevo flujo de trabajo.\n\n### Reflexiones Finales\n\nMigrar de NestJS con TypeScript a Go ha sido desafiante pero también gratificante. Mientras que NestJS ofrece una experiencia enriquecida en el desarrollo rápido de APIs con un enfoque en la reutilización y la abstracción, Go nos ha brindado un control más granular sobre la concurrencia y el rendimiento, esencial para aplicaciones altamente escalables.\n\nSeguimos experimentando y ajustando nuestros flujos de trabajo, y a pesar de los desafíos, estamos entusiasmados con las posibilidades que ofrece Go para el futuro de nuestros microservicios.\n\n* * *\n\nEspero que este blog sirva como una guía y una inspiración para aquellos que estén considerando una transición similar. ¿Qué experiencias han tenido ustedes con la migración de tecnologías? ¿Qué retos y soluciones han encontrado en el camino?\n\n¡Compartan sus historias y sigamos aprendiendo juntos!\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [June 23, 2024](https://medium.com/p/c754ff0cea6a).\n\n[Canonical link](https://medium.com/@devjaime/migrando-microservicios-de-nestjs-con-typescript-a-go-una-semana-de-descubrimientos-c754ff0cea6a)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"migrando-microservicios-de-nestjs-con-typescript-a-go-una-semana-de-descubrimientos","text":"Migrando Microservicios de NestJS con TypeScript a Go: Una Semana de Descubrimientos"},{"depth":3,"slug":"migrando-microservicios-de-nestjs-con-typescript-a-go-una-semana-de-descubrimientos-1","text":"Migrando Microservicios de NestJS con TypeScript a Go: Una Semana de Descubrimientos"},{"depth":3,"slug":"nuestra-arquitectura-ennestjs","text":"Nuestra Arquitectura en NestJS"},{"depth":4,"slug":"validaciones-y-migraciones","text":"Validaciones y Migraciones"},{"depth":4,"slug":"retos-connestjs","text":"Retos con NestJS"},{"depth":3,"slug":"adentrándonos-engo","text":"Adentrándonos en Go"},{"depth":4,"slug":"poo-e-interfaces","text":"POO e Interfaces"},{"depth":4,"slug":"ejemplos-comparativos","text":"Ejemplos Comparativos"},{"depth":4,"slug":"herramientas-y-configuración","text":"Herramientas y Configuración"},{"depth":3,"slug":"reflexiones-finales","text":"Reflexiones Finales"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
