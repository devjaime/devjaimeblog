/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"rust-in-modern-backend-development-advantages-disadvantages-and-ideas-for-the-future\">Rust in Modern Backend Development: Advantages, Disadvantages, and Ideas for the Future</h1>\n<p>Introduction</p>\n<hr>\n<h3 id=\"rust-in-modern-backend-development-advantages-disadvantages-and-ideas-for-thefuture\">Rust in Modern Backend Development: Advantages, Disadvantages, and Ideas for the Future</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*yu05HFAJA9J1juxk\" alt=\"\"></p>\n<p>IA generative</p>\n<h3 id=\"introduction\">Introduction</h3>\n<p>Modern backend development is constantly evolving, with new technologies and programming languages emerging regularly. Rust, known for its security and performance, has gained attention in the realm of backend development. In this blog, we will explore the advantages and disadvantages of Rust in this context, as well as ideas for its future in backend development.</p>\n<p><a href=\"https://www.rust-lang.org/\" title=\"https://www.rust-lang.org/\"><strong>Rust</strong><br>\n_A language empowering everyone to build reliable and efficient software._www.rust-lang.org</a><a href=\"https://www.rust-lang.org/\"></a></p>\n<h3 id=\"advantages-of-using-rust-for-backend-development\">Advantages of Using Rust for Backend Development</h3>\n<h4 id=\"memory-safety-without-garbage-collector\"><em>Memory Safety Without Garbage Collector</em></h4>\n<p>Rust ensures memory safety without a garbage collector, making it ideal for systems where performance and resource efficiency are critical. This feature significantly reduces vulnerabilities related to memory management.</p>\n<h4 id=\"efficient-concurrency\"><em>Efficient Concurrency</em></h4>\n<p>Rust handles concurrency in a unique way with its principles of ownership and borrowing, which reduces runtime errors related to accessing shared data in concurrent environments.</p>\n<h4 id=\"performance-comparable-tocc\"><em>Performance Comparable to C/C++</em></h4>\n<p>Being a low-level language, Rust offers performance close to that of C and C++, which is essential for backend applications that demand high speed and processing efficiency.</p>\n<h4 id=\"growing-ecosystem\"><em>Growing Ecosystem</em></h4>\n<p>Rust’s ecosystem is constantly growing, with an active community and an increasing number of libraries and frameworks, such as Actix and Rocket, that facilitate backend application development.</p>\n<h4 id=\"disadvantages-of-rust-in-backend-development\">Disadvantages of Rust in Backend Development</h4>\n<p><em>Steep Learning Curve</em> Rust has a steeper learning curve compared to other languages due to its unique safety features and type system.</p>\n<h4 id=\"limited-resource-availability\"><em>Limited Resource Availability</em></h4>\n<p>Although it is growing, Rust’s ecosystem is relatively smaller than that of languages like JavaScript (Node.js) or Python, which can limit the availability of resources and support.</p>\n<h4 id=\"compilation-time\"><em>Compilation Time</em></h4>\n<p>Rust can have longer compilation times compared to other languages, which could affect the development workflow, especially in large projects.</p>\n<h4 id=\"ideas-for-the-future-of-backend-development-withrust\">Ideas for the Future of Backend Development with Rust</h4>\n<h4 id=\"ecosystem-expansion\"><em>Ecosystem Expansion</em></h4>\n<p>Continue developing and expanding Rust’s ecosystem, including more libraries and tools, to further facilitate backend application development.</p>\n<h4 id=\"compilation-improvements\"><em>Compilation Improvements</em></h4>\n<p>Work on optimizing Rust’s compiler to reduce compilation times, especially in large and complex projects.</p>\n<h4 id=\"encouraging-education-andtraining\"><em>Encouraging Education and Training</em></h4>\n<p>Given Rust’s learning curve, it would be beneficial to increase educational resources, such as tutorials and courses, to make it easier for developers to learn the language.</p>\n<h4 id=\"integration-with-emerging-technologies\"><em>Integration with Emerging Technologies</em></h4>\n<p>Explore the integration of Rust with emerging technologies such as artificial intelligence, machine learning, and cloud computing, to leverage its performance and security.</p>\n<h3 id=\"developing-a-backend-for-smart-contracts-with-rust-architecture-and-considerations\">Developing a Backend for Smart Contracts with Rust: Architecture and Considerations</h3>\n<p>Introduction The world of smart contracts and blockchain has grown immensely, offering a new paradigm in how we handle transactions and digital agreements. Rust, with its focus on security and performance, is particularly suited for developing a robust backend in this field. In this article, we will outline a backend architecture for handling smart contracts using Rust.</p>\n<h4 id=\"general-architecture\">General Architecture</h4>\n<h4 id=\"1-restful-api-orgraphql\">1. RESTful API or GraphQL</h4>\n<ul>\n<li>Purpose: Interface for interacting with users and other systems.</li>\n<li>Implementation with Rust: Use frameworks like Actix-web to create efficient and secure endpoints.</li>\n</ul>\n<h4 id=\"2-smart-contractengine\">2. Smart Contract Engine</h4>\n<ul>\n<li>Purpose: Processing and managing smart contracts.</li>\n<li>Implementation with Rust: Develop modules that can interpret, execute, and validate smart contracts. Here, existing Rust libraries can be used to interact with blockchain.</li>\n</ul>\n<h4 id=\"3-blockchain-communication\">3. Blockchain Communication</h4>\n<ul>\n<li>Purpose: Interact with the blockchain to deploy and execute smart contracts.</li>\n<li>Implementation with Rust: Use libraries like ethers-rs to connect to Ethereum or other compatible blockchains.</li>\n</ul>\n<h4 id=\"4-database\">4. Database</h4>\n<ul>\n<li>Purpose: Store relevant data, such as contract states, transactions, and user records.</li>\n<li>Implementation with Rust: Connect with database systems like PostgreSQL using Rust ORMs.</li>\n</ul>\n<h4 id=\"5-queue-and-messaging-system\">5. Queue and Messaging System</h4>\n<ul>\n<li>Purpose: Handle asynchronous tasks and communication between different services.</li>\n<li>Implementation with Rust: Integrate with messaging systems like RabbitMQ or Kafka.</li>\n</ul>\n<h4 id=\"key-considerations\">Key Considerations</h4>\n<h4 id=\"security\">Security</h4>\n<ul>\n<li>Rigorous Validation: Ensure all inputs and contracts are thoroughly validated to prevent malicious executions.</li>\n<li>Unit and Integration Testing: Implement a robust set of tests to ensure the backend’s robustness.</li>\n</ul>\n<h4 id=\"scalability\">Scalability</h4>\n<ul>\n<li>Modular Design: Build the system in independent modules that can scale or be updated individually.</li>\n<li>Effective Concurrency: Leverage Rust’s concurrency capabilities to handle multiple requests and operations simultaneously.</li>\n</ul>\n<h4 id=\"interoperability\">Interoperability</h4>\n<ul>\n<li>Flexible APIs: Design APIs that can easily interact with different types of clients and services.</li>\n<li>Compatibility with Various Blockchains: Ensure the system can adapt to work with different blockchain technologies.</li>\n</ul>\n<h3 id=\"creating-a-small-code-example-to-cover-the-entire-architecture-of-a-backend-for-smart-contracts\">Creating a Small Code Example to Cover the Entire Architecture of a Backend for Smart Contracts</h3>\n<p>Creating a small code example that covers the entire architecture of a backend for smart contracts is quite broad and detailed. However, I can provide a simplified example that shows how you might start building an API in Rust that interacts with a smart contract on a blockchain like Ethereum. This example will use actix-web for the web server and ethers-rs for interacting with the blockchain.</p>\n<h4 id=\"requirements-to-run-this-example-you-willneed\">Requirements To run this example, you will need:</h4>\n<ul>\n<li>Rust and Cargo installed on your system.</li>\n<li>An Ethereum instance to connect to (e.g., a local Ganache node for testing).</li>\n</ul>\n<h4 id=\"step-1\">Step 1:</h4>\n<p>Create a New Rust Project Create a new Rust project with Cargo ((<a href=\"https://doc.rust-lang.org/cargo/\">https://doc.rust-lang.org/cargo/</a>):</p>\n<p>cargo new rust_blockchain_backend<br>\ncd rust_blockchain_backend</p>\n<h4 id=\"step-2\">Step 2:</h4>\n<p>Add Dependencies Add the following dependencies in your Cargo.toml file:</p>\n<p>[dependencies]<br>\nactix-web = “4”<br>\nethers = “0.5”<br>\ntokio = { version = “1”, features = [“full”] }</p>\n<h4 id=\"step-3\">Step 3:</h4>\n<p>Web Server Code with Actix-web Next, modify the src/main.rs file to include a basic web server with actix-web and an endpoint that interacts with a smart contract.</p>\n<p>use actix_web::{web, App, HttpResponse, HttpServer, Responder};<br>\nuse ethers::prelude::*;<br>\nasync fn get_contract_data() -> impl Responder {<br>\n// Set up the provider (connecting to a local Ethereum instance)<br>\nlet provider = Provider::<http>::try_from(“<a href=\"http://localhost:8545%22).expect(%22Error\">http://localhost:8545”).expect(“Error</a> creating provider”);<br>\n// Here, you would interact with your smart contract<br>\n// For example, getting the balance of an address<br>\nlet address = “your_contract_address”.parse::</http></p><address>().unwrap();<br>\nmatch provider.get_balance(address, None).await {<br>\nOk(balance) => HttpResponse::Ok().body(format!(“Balance: {}”, balance)),<br>\nErr(_) => HttpResponse::InternalServerError().body(“Error getting balance”),<br>\n}<br>\n}<br>\n#[actix_web::main]<br>\nasync fn main() -> std::io::Result&#x3C;()> {<br>\nHttpServer::new(|| {<br>\nApp::new()<br>\n.route(“/contract_data”, web::get().to(get_contract_data))<br>\n})<br>\n.bind(“127.0.0.1:8080”)?<br>\n.run()<br>\n.await<br>\n}<p></p>\n<h4 id=\"step-4\">Step 4:</h4>\n<p>Run the Server Once you have completed the code, you can run the server with:</p>\n<p>cargo run</p>\n<p>The server will be available at <a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080</a>, and you can access the /contract_data endpoint to interact with the smart contract.</p>\n<h4 id=\"final-notes\">Final Notes</h4>\n<p>This code is just a basic skeleton and much more work is needed to effectively handle smart contracts, including handling authentication, data validation, robust error management, and connection to a real smart contract. Additionally, this example assumes that you have a running and accessible Ethereum node.</p>\n<h4 id=\"conclusion\">Conclusion</h4>\n<p>Developing a backend for handling smart contracts with Rust offers a promising combination of security, efficiency, and performance. By following a well-thought-out architecture and focusing on security, scalability, and interoperability, a robust and flexible system can be built that is suitable for the dynamic world of blockchain and smart contracts. Rust’s adaptability and performance make it ideal for addressing the unique challenges present in this emerging field.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/164928673be3\">January 6, 2024</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/rust-in-modern-backend-development-advantages-disadvantages-and-ideas-for-the-future-164928673be3\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p></address>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Rust in Modern Backend Development: Advantages, Disadvantages, and Ideas for the Future","description":"","tags":["code","Rust"],"time":4,"featured":true,"timestamp":"2024-01-06T12:20:32-0300","filename":"2024-01-06_Rust-in-Modern-Backend-Development--Advantages--Disadvantages--and-Ideas-for-the-Future-164928673be3"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2024-01-06_Rust-in-Modern-Backend-Development--Advantages--Disadvantages--and-Ideas-for-the-Future-164928673be3.md";
				const url = "/blog/2024-01-06_Rust-in-Modern-Backend-Development--Advantages--Disadvantages--and-Ideas-for-the-Future-164928673be3";
				function rawContent() {
					return "   \n                                        \n                                                                                                \n               \n                      \n       \n              \n                                     \n                                                                                                                           \n   \n\nRust in Modern Backend Development: Advantages, Disadvantages, and Ideas for the Future\n=======================================================================================\n\nIntroduction\n\n* * *\n\n### Rust in Modern Backend Development: Advantages, Disadvantages, and Ideas for the Future\n\n![](https://cdn-images-1.medium.com/max/800/0*yu05HFAJA9J1juxk)\n\nIA generative\n\n### Introduction\n\nModern backend development is constantly evolving, with new technologies and programming languages emerging regularly. Rust, known for its security and performance, has gained attention in the realm of backend development. In this blog, we will explore the advantages and disadvantages of Rust in this context, as well as ideas for its future in backend development.\n\n[**Rust**  \n_A language empowering everyone to build reliable and efficient software._www.rust-lang.org](https://www.rust-lang.org/ \"https://www.rust-lang.org/\")[](https://www.rust-lang.org/)\n\n### Advantages of Using Rust for Backend Development\n\n#### _Memory Safety Without Garbage Collector_\n\nRust ensures memory safety without a garbage collector, making it ideal for systems where performance and resource efficiency are critical. This feature significantly reduces vulnerabilities related to memory management.\n\n#### _Efficient Concurrency_\n\nRust handles concurrency in a unique way with its principles of ownership and borrowing, which reduces runtime errors related to accessing shared data in concurrent environments.\n\n#### _Performance Comparable to C/C++_\n\nBeing a low-level language, Rust offers performance close to that of C and C++, which is essential for backend applications that demand high speed and processing efficiency.\n\n#### _Growing Ecosystem_\n\nRust’s ecosystem is constantly growing, with an active community and an increasing number of libraries and frameworks, such as Actix and Rocket, that facilitate backend application development.\n\n#### Disadvantages of Rust in Backend Development\n\n_Steep Learning Curve_ Rust has a steeper learning curve compared to other languages due to its unique safety features and type system.\n\n#### _Limited Resource Availability_\n\nAlthough it is growing, Rust’s ecosystem is relatively smaller than that of languages like JavaScript (Node.js) or Python, which can limit the availability of resources and support.\n\n#### _Compilation Time_\n\nRust can have longer compilation times compared to other languages, which could affect the development workflow, especially in large projects.\n\n#### Ideas for the Future of Backend Development with Rust\n\n#### _Ecosystem Expansion_\n\nContinue developing and expanding Rust’s ecosystem, including more libraries and tools, to further facilitate backend application development.\n\n#### _Compilation Improvements_\n\nWork on optimizing Rust’s compiler to reduce compilation times, especially in large and complex projects.\n\n#### _Encouraging Education and Training_\n\nGiven Rust’s learning curve, it would be beneficial to increase educational resources, such as tutorials and courses, to make it easier for developers to learn the language.\n\n#### _Integration with Emerging Technologies_\n\nExplore the integration of Rust with emerging technologies such as artificial intelligence, machine learning, and cloud computing, to leverage its performance and security.\n\n### Developing a Backend for Smart Contracts with Rust: Architecture and Considerations\n\nIntroduction The world of smart contracts and blockchain has grown immensely, offering a new paradigm in how we handle transactions and digital agreements. Rust, with its focus on security and performance, is particularly suited for developing a robust backend in this field. In this article, we will outline a backend architecture for handling smart contracts using Rust.\n\n#### General Architecture\n\n#### 1\\. RESTful API or GraphQL\n\n*   Purpose: Interface for interacting with users and other systems.\n*   Implementation with Rust: Use frameworks like Actix-web to create efficient and secure endpoints.\n\n#### 2\\. Smart Contract Engine\n\n*   Purpose: Processing and managing smart contracts.\n*   Implementation with Rust: Develop modules that can interpret, execute, and validate smart contracts. Here, existing Rust libraries can be used to interact with blockchain.\n\n#### 3\\. Blockchain Communication\n\n*   Purpose: Interact with the blockchain to deploy and execute smart contracts.\n*   Implementation with Rust: Use libraries like ethers-rs to connect to Ethereum or other compatible blockchains.\n\n#### 4\\. Database\n\n*   Purpose: Store relevant data, such as contract states, transactions, and user records.\n*   Implementation with Rust: Connect with database systems like PostgreSQL using Rust ORMs.\n\n#### 5\\. Queue and Messaging System\n\n*   Purpose: Handle asynchronous tasks and communication between different services.\n*   Implementation with Rust: Integrate with messaging systems like RabbitMQ or Kafka.\n\n#### Key Considerations\n\n#### Security\n\n*   Rigorous Validation: Ensure all inputs and contracts are thoroughly validated to prevent malicious executions.\n*   Unit and Integration Testing: Implement a robust set of tests to ensure the backend’s robustness.\n\n#### Scalability\n\n*   Modular Design: Build the system in independent modules that can scale or be updated individually.\n*   Effective Concurrency: Leverage Rust’s concurrency capabilities to handle multiple requests and operations simultaneously.\n\n#### Interoperability\n\n*   Flexible APIs: Design APIs that can easily interact with different types of clients and services.\n*   Compatibility with Various Blockchains: Ensure the system can adapt to work with different blockchain technologies.\n\n### Creating a Small Code Example to Cover the Entire Architecture of a Backend for Smart Contracts\n\nCreating a small code example that covers the entire architecture of a backend for smart contracts is quite broad and detailed. However, I can provide a simplified example that shows how you might start building an API in Rust that interacts with a smart contract on a blockchain like Ethereum. This example will use actix-web for the web server and ethers-rs for interacting with the blockchain.\n\n#### Requirements To run this example, you will need:\n\n*   Rust and Cargo installed on your system.\n*   An Ethereum instance to connect to (e.g., a local Ganache node for testing).\n\n#### Step 1:\n\nCreate a New Rust Project Create a new Rust project with Cargo (([https://doc.rust-lang.org/cargo/](https://doc.rust-lang.org/cargo/)):\n\ncargo new rust\\_blockchain\\_backend  \ncd rust\\_blockchain\\_backend\n\n#### Step 2:\n\nAdd Dependencies Add the following dependencies in your Cargo.toml file:\n\n\\[dependencies\\]  \nactix-web = \"4\"  \nethers = \"0.5\"  \ntokio = { version = \"1\", features = \\[\"full\"\\] }\n\n#### Step 3:\n\nWeb Server Code with Actix-web Next, modify the src/main.rs file to include a basic web server with actix-web and an endpoint that interacts with a smart contract.\n\nuse actix\\_web::{web, App, HttpResponse, HttpServer, Responder};  \nuse ethers::prelude::\\*;  \nasync fn get\\_contract\\_data() \\-> impl Responder {  \n    // Set up the provider (connecting to a local Ethereum instance)  \n    let provider = Provider::<Http>::try\\_from(\"http://localhost:8545\").expect(\"Error creating provider\");  \n    // Here, you would interact with your smart contract  \n    // For example, getting the balance of an address  \n    let address = \"your\\_contract\\_address\".parse::<Address>().unwrap();  \n    match provider.get\\_balance(address, None).await {  \n        Ok(balance) => HttpResponse::Ok().body(format!(\"Balance: {}\", balance)),  \n        Err(\\_) => HttpResponse::InternalServerError().body(\"Error getting balance\"),  \n    }  \n}  \n#\\[actix\\_web::main\\]  \nasync fn main() \\-> std::io::Result<()> {  \n    HttpServer::new(|| {  \n        App::new()  \n            .route(\"/contract\\_data\", web::get().to(get\\_contract\\_data))  \n    })  \n    .bind(\"127.0.0.1:8080\")?  \n    .run()  \n    .await  \n}\n\n#### Step 4:\n\nRun the Server Once you have completed the code, you can run the server with:\n\ncargo run\n\nThe server will be available at [http://127.0.0.1:8080](http://127.0.0.1:8080/), and you can access the /contract\\_data endpoint to interact with the smart contract.\n\n#### Final Notes\n\nThis code is just a basic skeleton and much more work is needed to effectively handle smart contracts, including handling authentication, data validation, robust error management, and connection to a real smart contract. Additionally, this example assumes that you have a running and accessible Ethereum node.\n\n#### Conclusion\n\nDeveloping a backend for handling smart contracts with Rust offers a promising combination of security, efficiency, and performance. By following a well-thought-out architecture and focusing on security, scalability, and interoperability, a robust and flexible system can be built that is suitable for the dynamic world of blockchain and smart contracts. Rust’s adaptability and performance make it ideal for addressing the unique challenges present in this emerging field.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [January 6, 2024](https://medium.com/p/164928673be3).\n\n[Canonical link](https://medium.com/@devjaime/rust-in-modern-backend-development-advantages-disadvantages-and-ideas-for-the-future-164928673be3)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"rust-in-modern-backend-development-advantages-disadvantages-and-ideas-for-the-future","text":"Rust in Modern Backend Development: Advantages, Disadvantages, and Ideas for the Future"},{"depth":3,"slug":"rust-in-modern-backend-development-advantages-disadvantages-and-ideas-for-thefuture","text":"Rust in Modern Backend Development: Advantages, Disadvantages, and Ideas for the Future"},{"depth":3,"slug":"introduction","text":"Introduction"},{"depth":3,"slug":"advantages-of-using-rust-for-backend-development","text":"Advantages of Using Rust for Backend Development"},{"depth":4,"slug":"memory-safety-without-garbage-collector","text":"Memory Safety Without Garbage Collector"},{"depth":4,"slug":"efficient-concurrency","text":"Efficient Concurrency"},{"depth":4,"slug":"performance-comparable-tocc","text":"Performance Comparable to C/C++"},{"depth":4,"slug":"growing-ecosystem","text":"Growing Ecosystem"},{"depth":4,"slug":"disadvantages-of-rust-in-backend-development","text":"Disadvantages of Rust in Backend Development"},{"depth":4,"slug":"limited-resource-availability","text":"Limited Resource Availability"},{"depth":4,"slug":"compilation-time","text":"Compilation Time"},{"depth":4,"slug":"ideas-for-the-future-of-backend-development-withrust","text":"Ideas for the Future of Backend Development with Rust"},{"depth":4,"slug":"ecosystem-expansion","text":"Ecosystem Expansion"},{"depth":4,"slug":"compilation-improvements","text":"Compilation Improvements"},{"depth":4,"slug":"encouraging-education-andtraining","text":"Encouraging Education and Training"},{"depth":4,"slug":"integration-with-emerging-technologies","text":"Integration with Emerging Technologies"},{"depth":3,"slug":"developing-a-backend-for-smart-contracts-with-rust-architecture-and-considerations","text":"Developing a Backend for Smart Contracts with Rust: Architecture and Considerations"},{"depth":4,"slug":"general-architecture","text":"General Architecture"},{"depth":4,"slug":"1-restful-api-orgraphql","text":"1. RESTful API or GraphQL"},{"depth":4,"slug":"2-smart-contractengine","text":"2. Smart Contract Engine"},{"depth":4,"slug":"3-blockchain-communication","text":"3. Blockchain Communication"},{"depth":4,"slug":"4-database","text":"4. Database"},{"depth":4,"slug":"5-queue-and-messaging-system","text":"5. Queue and Messaging System"},{"depth":4,"slug":"key-considerations","text":"Key Considerations"},{"depth":4,"slug":"security","text":"Security"},{"depth":4,"slug":"scalability","text":"Scalability"},{"depth":4,"slug":"interoperability","text":"Interoperability"},{"depth":3,"slug":"creating-a-small-code-example-to-cover-the-entire-architecture-of-a-backend-for-smart-contracts","text":"Creating a Small Code Example to Cover the Entire Architecture of a Backend for Smart Contracts"},{"depth":4,"slug":"requirements-to-run-this-example-you-willneed","text":"Requirements To run this example, you will need:"},{"depth":4,"slug":"step-1","text":"Step 1:"},{"depth":4,"slug":"step-2","text":"Step 2:"},{"depth":4,"slug":"step-3","text":"Step 3:"},{"depth":4,"slug":"step-4","text":"Step 4:"},{"depth":4,"slug":"final-notes","text":"Final Notes"},{"depth":4,"slug":"conclusion","text":"Conclusion"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
