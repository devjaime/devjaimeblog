/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"vistas-materializadas-cron-jobs-y-microservicios-en-go\">Vistas Materializadas, Cron Jobs y Microservicios en Go</h1>\n<p>Las vistas materializadas son una herramienta poderosa en bases de datos relacionales, especialmente en PostgreSQL, para mejorar el‚Ä¶</p>\n<hr>\n<h3 id=\"vistas-materializadas-cron-jobs-y-microservicios-engo\">Vistas Materializadas, Cron Jobs y Microservicios en¬†Go</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*mxCxErqTczpxdscXzihOuQ.png\" alt=\"\"></p>\n<blockquote>\n<p>Las <strong>vistas materializadas</strong> son una herramienta poderosa en bases de datos relacionales, especialmente en <strong>PostgreSQL</strong>, para mejorar el rendimiento de consultas en sistemas con grandes vol√∫menes de datos. Sin embargo, para mantenerlas actualizadas, es necesario contar con un mecanismo de <strong>actualizaci√≥n peri√≥dica</strong>, como un <strong>cron job</strong> o una <strong>Cloud Function</strong>.</p>\n</blockquote>\n<p>En este blog, exploraremos c√≥mo integrar <strong>vistas materializadas</strong> con <strong>microservicios en Go</strong>, utilizando <strong>cron jobs</strong> en Kubernetes o <strong>Cloud Functions</strong> en GCP/AWS para refrescarlas autom√°ticamente.</p>\n<h3 id=\"1-qu√©-es-una-vista-materializada\">1. ¬øQu√© es una Vista Materializada?</h3>\n<p>Una vista materializada es similar a una vista normal, pero los datos se almacenan f√≠sicamente en la base de datos. Esto permite mejorar la velocidad de consultas a cambio de requerir actualizaciones peri√≥dicas para reflejar los cambios en los datos originales.</p>\n<p><strong>Ejemplo de creaci√≥n en PostgreSQL:</strong></p>\n<p>CREATE MATERIALIZED VIEW ventas_diarias AS<br>\nSELECT fecha, SUM(monto) AS total_ventas<br>\nFROM transacciones<br>\nGROUP BY fecha;</p>\n<p>Para actualizar esta vista:</p>\n<p>REFRESH MATERIALIZED VIEW ventas_diarias;</p>\n<h3 id=\"2-actualizaci√≥n-con-un-microservicio-engo\">2. Actualizaci√≥n con un Microservicio en¬†Go</h3>\n<p>Podemos usar <strong>pgx</strong> para ejecutar la actualizaci√≥n desde un servicio en <strong>Go</strong>.</p>\n<h3 id=\"21-configuraci√≥n-del-cliente-postgresql\">2.1 Configuraci√≥n del Cliente PostgreSQL</h3>\n<p>Instalamos el driver:</p>\n<p>go get github.com/jackc/pgx/v5</p>\n<p>C√≥digo en Go para actualizar la vista:</p>\n<p>package main<br>\nimport (<br>\n‚Äúcontext\"<br>\n\"fmt\"<br>\n\"log\"<br>\n\"time\"<br>\n\"github.com/jackc/pgx/v5/pgxpool‚Äù<br>\n)<br>\nconst dbURL = ‚Äúpostgres://user:password@host:5432/dbname‚Äù<br>\nfunc refreshMaterializedView(db *pgxpool.Pool) {<br>\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)<br>\ndefer cancel()<br>\n_, err := db.Exec(ctx, ‚ÄúREFRESH MATERIALIZED VIEW ventas_diarias;‚Äú)<br>\nif err != nil {<br>\nlog.Fatalf(‚ÄúError actualizando vista: %v‚Äù, err)<br>\n}<br>\nfmt.Println(‚ÄúVista materializada actualizada correctamente‚Äù)<br>\n}<br>\nfunc main() {<br>\ndb, err := pgxpool.New(context.Background(), dbURL)<br>\nif err != nil {<br>\nlog.Fatalf(‚ÄúNo se pudo conectar a la base de datos: %v‚Äù, err)<br>\n}<br>\ndefer db.Close()<br>\nrefreshMaterializedView(db)<br>\n}</p>\n<p>3. Automatizaci√≥n con un Cron Job en Kubernetes</p>\n<p>Si usamos Kubernetes, podemos definir un <strong>CronJob</strong> que ejecute nuestro microservicio peri√≥dicamente:</p>\n<p>apiVersion: batch/v1<br>\nkind: CronJob<br>\nmetadata:<br>\nname: refrescar-vista<br>\nspec:<br>\nschedule: ‚Äú0 * * * *‚Äù # Cada hora<br>\njobTemplate:<br>\nspec:<br>\ntemplate:<br>\nspec:<br>\ncontainers:<br>\n- name: refrescar-vista<br>\nimage: mi-registro/miservicio:latest<br>\ncommand: [‚Äú/app/main‚Äù]<br>\nrestartPolicy: OnFailure</p>\n<h3 id=\"4-alternativa-con-cloud-functions-engcp\">4. Alternativa con Cloud Functions en¬†GCP</h3>\n<p>Podemos usar una <strong>Cloud Function</strong> en <strong>Go</strong> que se ejecute con Cloud Scheduler:</p>\n<h3 id=\"41-c√≥digo-para-la-cloudfunction\">4.1 C√≥digo para la Cloud¬†Function</h3>\n<p>package refrescarvista<br>\nimport (<br>\n‚Äúcontext\"<br>\n\"database/sql\"<br>\n\"log\"<br>\n\"net/http‚Äù<br>\n_ ‚Äúgithub.com/lib/pq‚Äù<br>\n)<br>\nconst dbURL = ‚Äúpostgres://user:password@host:5432/dbname‚Äù<br>\nfunc RefreshView(w http.ResponseWriter, r *http.Request) {<br>\ndb, err := sql.Open(‚Äúpostgres‚Äù, dbURL)<br>\nif err != nil {<br>\nhttp.Error(w, ‚ÄúError conectando a la BD‚Äù, http.StatusInternalServerError)<br>\nreturn<br>\n}<br>\ndefer db.Close()<br>\n_, err = db.Exec(‚ÄúREFRESH MATERIALIZED VIEW ventas_diarias;‚Äú)<br>\nif err != nil {<br>\nhttp.Error(w, ‚ÄúError actualizando vista‚Äù, http.StatusInternalServerError)<br>\nreturn<br>\n}<br>\nw.Write([]byte(‚ÄúVista actualizada‚Äù))<br>\n}</p>\n<h3 id=\"42-programaci√≥n-con-cloud-scheduler\">4.2 Programaci√≥n con Cloud Scheduler</h3>\n<p>Podemos crear una tarea en <strong>Cloud Scheduler</strong> para ejecutar esta funci√≥n peri√≥dicamente:</p>\n<p>gcloud scheduler jobs create http refrescar-vista \\<br>\n‚Äîschedule=‚Äú0 * * * *‚Äù \\<br>\n‚Äîuri=‚Äú<a href=\"https://REGION-PROJECT%5C_ID.cloudfunctions.net/refrescarvista\">https://REGION-PROJECT\\_ID.cloudfunctions.net/refrescarvista</a>‚Äù \\<br>\n‚Äîhttp-method=GET</p>\n<h3 id=\"5-conclusi√≥n\">5. Conclusi√≥n</h3>\n<p>Las vistas materializadas son una excelente opci√≥n para mejorar el rendimiento de consultas en bases de datos relacionales. En este blog, vimos c√≥mo integrarlas con <strong>Go</strong> usando:</p>\n<ul>\n<li>Un <strong>microservicio en Go</strong> para actualizar la vista.</li>\n<li>Un <strong>CronJob en Kubernetes</strong> para automatizar la tarea.</li>\n<li>Una <strong>Cloud Function en GCP</strong> con <strong>Cloud Scheduler</strong> como alternativa serverless.</li>\n</ul>\n<p>Esto permite una arquitectura flexible y escalable para manejar grandes vol√∫menes de datos de manera eficiente. üöÄ</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hern√°ndez</a> on <a href=\"https://medium.com/p/2d3a35c4391f\">March 9, 2025</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/vistas-materializadas-cron-jobs-y-microservicios-en-go-2d3a35c4391f\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Vistas Materializadas, Cron Jobs y Microservicios en Go","description":"","tags":["code","Go","Vistas Materializadas","CronJob","microservicios"],"time":4,"featured":true,"timestamp":"2025-03-09T12:20:33-0300","filename":"2025-03-09_Vistas-Materializadas--Cron-Jobs-y-Microservicios-en-Go-2d3a35c4391f"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2025-03-09_Vistas-Materializadas--Cron-Jobs-y-Microservicios-en-Go-2d3a35c4391f.md";
				const url = "/blog/2025-03-09_Vistas-Materializadas--Cron-Jobs-y-Microservicios-en-Go-2d3a35c4391f";
				function rawContent() {
					return "   \n                                        \n                                                                \n               \n                                                                          \n       \n              \n                                     \n                                                                                           \n   \n\nVistas Materializadas, Cron Jobs y Microservicios en Go\n=======================================================\n\nLas vistas materializadas son una herramienta poderosa en bases de datos relacionales, especialmente en PostgreSQL, para mejorar el‚Ä¶\n\n* * *\n\n### Vistas Materializadas, Cron Jobs y Microservicios en¬†Go\n\n![](https://cdn-images-1.medium.com/max/800/1*mxCxErqTczpxdscXzihOuQ.png)\n\n> Las **vistas materializadas** son una herramienta poderosa en bases de datos relacionales, especialmente en **PostgreSQL**, para mejorar el rendimiento de consultas en sistemas con grandes vol√∫menes de datos. Sin embargo, para mantenerlas actualizadas, es necesario contar con un mecanismo de **actualizaci√≥n peri√≥dica**, como un **cron job** o una **Cloud Function**.\n\nEn este blog, exploraremos c√≥mo integrar **vistas materializadas** con **microservicios en Go**, utilizando **cron jobs** en Kubernetes o **Cloud Functions** en GCP/AWS para refrescarlas autom√°ticamente.\n\n### 1\\. ¬øQu√© es una Vista Materializada?\n\nUna vista materializada es similar a una vista normal, pero los datos se almacenan f√≠sicamente en la base de datos. Esto permite mejorar la velocidad de consultas a cambio de requerir actualizaciones peri√≥dicas para reflejar los cambios en los datos originales.\n\n**Ejemplo de creaci√≥n en PostgreSQL:**\n\nCREATE MATERIALIZED VIEW ventas\\_diarias AS  \nSELECT fecha, SUM(monto) AS total\\_ventas  \nFROM transacciones  \nGROUP BY fecha;\n\nPara actualizar esta vista:\n\nREFRESH MATERIALIZED VIEW ventas\\_diarias;\n\n### 2\\. Actualizaci√≥n con un Microservicio en¬†Go\n\nPodemos usar **pgx** para ejecutar la actualizaci√≥n desde un servicio en **Go**.\n\n### 2.1 Configuraci√≥n del Cliente PostgreSQL\n\nInstalamos el driver:\n\ngo get github.com/jackc/pgx/v5\n\nC√≥digo en Go para actualizar la vista:\n\npackage main  \nimport (  \n \"context\"  \n \"fmt\"  \n \"log\"  \n \"time\"  \n \"github.com/jackc/pgx/v5/pgxpool\"  \n)  \nconst dbURL = \"postgres://user:password@host:5432/dbname\"  \nfunc refreshMaterializedView(db \\*pgxpool.Pool) {  \n ctx, cancel := context.WithTimeout(context.Background(), 5\\*time.Second)  \n defer cancel()  \n \\_, err := db.Exec(ctx, \"REFRESH MATERIALIZED VIEW ventas\\_diarias;\")  \n if err != nil {  \n  log.Fatalf(\"Error actualizando vista: %v\", err)  \n }  \n fmt.Println(\"Vista materializada actualizada correctamente\")  \n}  \nfunc main() {  \n db, err := pgxpool.New(context.Background(), dbURL)  \n if err != nil {  \n  log.Fatalf(\"No se pudo conectar a la base de datos: %v\", err)  \n }  \n defer db.Close()  \n refreshMaterializedView(db)  \n}\n\n3\\. Automatizaci√≥n con un Cron Job en Kubernetes\n\nSi usamos Kubernetes, podemos definir un **CronJob** que ejecute nuestro microservicio peri√≥dicamente:\n\napiVersion: batch/v1  \nkind: CronJob  \nmetadata:  \n  name: refrescar-vista  \nspec:  \n  schedule: \"0 \\* \\* \\* \\*\" \\# Cada hora  \n  jobTemplate:  \n    spec:  \n      template:  \n        spec:  \n          containers:  \n          \\- name: refrescar-vista  \n            image: mi-registro/miservicio:latest  \n            command: \\[\"/app/main\"\\]  \n          restartPolicy: OnFailure\n\n### 4\\. Alternativa con Cloud Functions en¬†GCP\n\nPodemos usar una **Cloud Function** en **Go** que se ejecute con Cloud Scheduler:\n\n### 4.1 C√≥digo para la Cloud¬†Function\n\npackage refrescarvista  \nimport (  \n \"context\"  \n \"database/sql\"  \n \"log\"  \n \"net/http\"  \n \\_ \"github.com/lib/pq\"  \n)  \nconst dbURL = \"postgres://user:password@host:5432/dbname\"  \nfunc RefreshView(w http.ResponseWriter, r \\*http.Request) {  \n db, err := sql.Open(\"postgres\", dbURL)  \n if err != nil {  \n  http.Error(w, \"Error conectando a la BD\", http.StatusInternalServerError)  \n  return  \n }  \n defer db.Close()  \n \\_, err = db.Exec(\"REFRESH MATERIALIZED VIEW ventas\\_diarias;\")  \n if err != nil {  \n  http.Error(w, \"Error actualizando vista\", http.StatusInternalServerError)  \n  return  \n }  \n w.Write(\\[\\]byte(\"Vista actualizada\"))  \n}\n\n### 4.2 Programaci√≥n con Cloud Scheduler\n\nPodemos crear una tarea en **Cloud Scheduler** para ejecutar esta funci√≥n peri√≥dicamente:\n\ngcloud scheduler jobs create http refrescar-vista \\\\  \n    \\--schedule=\"0 \\* \\* \\* \\*\" \\\\  \n    \\--uri=\"https://REGION-PROJECT\\_ID.cloudfunctions.net/refrescarvista\" \\\\  \n    \\--http-method=GET\n\n### 5\\. Conclusi√≥n\n\nLas vistas materializadas son una excelente opci√≥n para mejorar el rendimiento de consultas en bases de datos relacionales. En este blog, vimos c√≥mo integrarlas con **Go** usando:\n\n*   Un **microservicio en Go** para actualizar la vista.\n*   Un **CronJob en Kubernetes** para automatizar la tarea.\n*   Una **Cloud Function en GCP** con **Cloud Scheduler** como alternativa serverless.\n\nEsto permite una arquitectura flexible y escalable para manejar grandes vol√∫menes de datos de manera eficiente. üöÄ\n\nBy [Jaime Hern√°ndez](https://medium.com/@devjaime) on [March 9, 2025](https://medium.com/p/2d3a35c4391f).\n\n[Canonical link](https://medium.com/@devjaime/vistas-materializadas-cron-jobs-y-microservicios-en-go-2d3a35c4391f)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"vistas-materializadas-cron-jobs-y-microservicios-en-go","text":"Vistas Materializadas, Cron Jobs y Microservicios en Go"},{"depth":3,"slug":"vistas-materializadas-cron-jobs-y-microservicios-engo","text":"Vistas Materializadas, Cron Jobs y Microservicios en¬†Go"},{"depth":3,"slug":"1-qu√©-es-una-vista-materializada","text":"1. ¬øQu√© es una Vista Materializada?"},{"depth":3,"slug":"2-actualizaci√≥n-con-un-microservicio-engo","text":"2. Actualizaci√≥n con un Microservicio en¬†Go"},{"depth":3,"slug":"21-configuraci√≥n-del-cliente-postgresql","text":"2.1 Configuraci√≥n del Cliente PostgreSQL"},{"depth":3,"slug":"4-alternativa-con-cloud-functions-engcp","text":"4. Alternativa con Cloud Functions en¬†GCP"},{"depth":3,"slug":"41-c√≥digo-para-la-cloudfunction","text":"4.1 C√≥digo para la Cloud¬†Function"},{"depth":3,"slug":"42-programaci√≥n-con-cloud-scheduler","text":"4.2 Programaci√≥n con Cloud Scheduler"},{"depth":3,"slug":"5-conclusi√≥n","text":"5. Conclusi√≥n"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
