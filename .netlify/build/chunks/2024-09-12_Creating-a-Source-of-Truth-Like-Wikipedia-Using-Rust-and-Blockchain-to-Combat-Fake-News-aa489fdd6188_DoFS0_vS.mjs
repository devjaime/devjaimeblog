/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"creating-a-source-of-truth-like-wikipedia-using-rust-and-blockchain-to-combat-fake-news\">Creating a Source of Truth Like Wikipedia Using Rust and Blockchain to Combat Fake News</h1>\n<p>In the information age, fake news and misinformation have become growing issues. In response, there is a need for a source of truth that…</p>\n<hr>\n<h3 id=\"creating-a-source-of-truth-like-wikipedia-using-rust-and-blockchain-to-combat-fakenews\">Creating a Source of Truth Like Wikipedia Using Rust and Blockchain to Combat Fake News</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*vsnuwlnd3b5Iv2RKY6ltJw.png\" alt=\"\"></p>\n<p>In the information age, fake news and misinformation have become growing issues. In response, there is a need for a <strong>source of truth</strong> that ensures the accuracy of information and can be audited transparently. Using emerging technologies such as <strong>blockchain</strong> and the <strong>Rust programming language</strong>, it’s possible to create a robust and reliable platform similar to Wikipedia, where data can be verified and maintained in a decentralized manner. This article discusses how to build such a solution from a software engineering perspective.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*RYHSglNn19VLFO8ecoq1MQ.jpeg\" alt=\"\"></p>\n<h3 id=\"why-rust-and-blockchain\">Why Rust and Blockchain?</h3>\n<h3 id=\"rust-safety-and-performance\">Rust: Safety and Performance</h3>\n<p>Rust is known for its <strong>memory safety</strong> and high performance, making it an excellent choice for systems where <strong>data integrity</strong> and <strong>concurrency</strong> are critical. These characteristics are essential in a blockchain project, as we need to ensure that the information stored is not corruptible or manipulable.</p>\n<h3 id=\"blockchain-transparency-and-decentralization\">Blockchain: Transparency and Decentralization</h3>\n<p>Blockchain allows the creation of a distributed and immutable database. Each node in the network has a copy of the information, and any modification must be approved through a consensus mechanism, making it difficult to tamper with the data. This makes blockchain ideal for a platform aiming to combat misinformation, as any changes to the information will be transparent and verifiable.</p>\n<h3 id=\"system-architecture-design\">System Architecture Design</h3>\n<ol>\n<li><strong>Frontend</strong>: A Wikipedia-like interface where users can read articles and propose changes or new entries.</li>\n<li><strong>Backend in Rust</strong>: A system that handles user requests and blockchain transactions.</li>\n<li><strong>Blockchain</strong>: Stores data immutably, allowing traceability of any modification. Each article on the platform will be associated with a block.</li>\n<li><strong>Digital Signatures and Verification</strong>: Information sources will be verified through digital signatures and cryptography to ensure that data comes from trusted sources.</li>\n</ol>\n<h3 id=\"building-the-backend-inrust\">Building the Backend in Rust</h3>\n<h3 id=\"1-project-initialization\">1. Project Initialization</h3>\n<p>First, we set up a Rust project using <strong>Cargo</strong>, the Rust package manager. We install the necessary dependencies to handle cryptography and blockchain.</p>\n<p>cargo new source_of_truth<br>\ncd source_of_truth</p>\n<p>In the <code>Cargo.toml</code> file, we add the required dependencies:</p>\n<p>toml<br>\n[dependencies]<br>\nserde = { version = “1.0”, features = [“derive”] }<br>\nserde_json = “1.0”<br>\nsha2 = “0.9”  # For hash functions<br>\nring = “0.16” # For cryptograph</p>\n<h3 id=\"2-creating-a-block-structure\">2. Creating a Block Structure</h3>\n<p>Each article or change will be represented by a block in the blockchain. We define a block structure that contains the article information, source, and the hash of the previous block:</p>\n<p>extern crate sha2;<br>\nextern crate serde;<br>\nextern crate serde_json;<br>\nuse sha2::{Sha256, Digest};<br>\nuse serde::{Serialize, Deserialize};<br>\nuse std::time::{SystemTime, UNIX_EPOCH};<br>\n#[derive(Serialize, Deserialize, Debug, Clone)]<br>\nstruct Block {<br>\nindex: u64,<br>\ntimestamp: u128,<br>\narticle: String,<br>\nsource: String,<br>\nprev_hash: String,<br>\nhash: String,<br>\n}<br>\nimpl Block {<br>\nfn new(index: u64, article: String, source: String, prev_hash: String) -> Block {<br>\nlet timestamp = SystemTime::now()<br>\n.duration_since(UNIX_EPOCH)<br>\n.expect(“Time went backwards”)<br>\n.as_millis();<br>\nlet block_data = format!(”{}{}{}{}”, index, timestamp, &#x26;article, &#x26;source);<br>\nlet hash = calculate_hash(&#x26;block_data);<br>\nBlock {<br>\nindex,<br>\ntimestamp,<br>\narticle,<br>\nsource,<br>\nprev_hash,<br>\nhash,<br>\n}<br>\n}<br>\n}<br>\nfn calculate_hash(data: &#x26;str) -> String {<br>\nlet mut hasher = Sha256::new();<br>\nhasher.update(data.as_bytes());<br>\nlet result = hasher.finalize();<br>\nformat!(”{:x}”, result)<br>\n}</p>\n<h3 id=\"3-implementing-the-blockchain\">3. Implementing the Blockchain</h3>\n<p>Now, we implement the blockchain, where each new block depends on the hash of the previous block, ensuring immutability.</p>\n<p>struct Blockchain {<br>\nchain: Vec<block>,<br>\n}<br>\nimpl Blockchain {<br>\nfn new() -> Blockchain {<br>\nBlockchain {<br>\nchain: vec![Blockchain::create_genesis_block()],<br>\n}<br>\n}<br>\nfn create_genesis_block() -> Block {<br>\nBlock::new(0, String::from(“Genesis Block”), String::from(“N/A”), String::from(“0”))<br>\n}<br>\nfn add_block(&#x26;mut self, article: String, source: String) {<br>\nlet prev_block = &#x26;self.chain[self.chain.len() - 1];<br>\nlet new_block = Block::new(<br>\nself.chain.len() as u64,<br>\narticle,<br>\nsource,<br>\nprev_block.hash.clone(),<br>\n);<br>\nself.chain.push(new_block);<br>\n}<br>\nfn is_valid(&#x26;self) -> bool {<br>\nfor i in 1..self.chain.len() {<br>\nlet current = &#x26;self.chain[i];<br>\nlet previous = &#x26;self.chain[i - 1];<br>\nif current.prev_hash != previous.hash {<br>\nreturn false;<br>\n}<br>\nlet recalculated_hash = calculate_hash(&#x26;format!(<br>\n”{}{}{}{}“,<br>\ncurrent.index, current.timestamp, current.article, current.source<br>\n));<br>\nif current.hash != recalculated_hash {<br>\nreturn false;<br>\n}<br>\n}<br>\ntrue<br>\n}<br>\n}</block></p>\n<p>With this basic blockchain implementation, we can add articles as blocks and ensure the chain’s validity by checking the previous hashes.</p>\n<h3 id=\"4-verifying-with-digital-signatures\">4. Verifying with Digital Signatures</h3>\n<p>To verify the sources of information, we use <strong>digital signatures</strong>. Each trusted source (e.g., a media outlet or a verified journalist) will have a <strong>private key</strong> to sign the information they publish.</p>\n<h4 id=\"generating-keys\">Generating Keys</h4>\n<p>We use the <code>ring</code> library to generate key pairs and sign data:</p>\n<p>extern crate ring;<br>\nuse ring::{rand, signature};<br>\nfn generate_keys() -> (Vec&#x3C;u8>, Vec&#x3C;u8>) {<br>\nlet rng = rand::SystemRandom::new();<br>\nlet key_pair = signature::Ed25519KeyPair::generate_pkcs8(&#x26;rng).unwrap();<br>\nlet key_pair = signature::Ed25519KeyPair::from_pkcs8(key_pair.as_ref()).unwrap();<br>\n(key_pair.public_key().as_ref().to_vec(), key_pair.private_key().as_ref().to_vec())<br>\n}<br>\nfn sign_data(data: &#x26;[u8], private_key: &#x26;[u8]) -> Vec&#x3C;u8> {<br>\nlet key_pair = signature::Ed25519KeyPair::from_pkcs8(private_key).unwrap();<br>\nkey_pair.sign(data).as_ref().to_vec()<br>\n}<br>\nfn verify_signature(data: &#x26;[u8], public_key: &#x26;[u8], signature: &#x26;[u8]) -> bool {<br>\nlet peer_public_key = signature::UnparsedPublicKey::new(&#x26;signature::ED25519, public_key);<br>\npeer_public_key.verify(data, signature).is_ok()<br>\n}</p>\n<h3 id=\"5-integrating-the-signature-into-theblock\">5. Integrating the Signature into the Block</h3>\n<p>Now we can modify our block structure to include digital signatures and verify that the sources are legitimate.</p>\n<p>#[derive(Serialize, Deserialize, Debug, Clone)]<br>\nstruct Block {<br>\nindex: u64,<br>\ntimestamp: u128,<br>\narticle: String,<br>\nsource: String,<br>\nprev_hash: String,<br>\nhash: String,<br>\nsignature: Vec&#x3C;u8>,<br>\n}<br>\nimpl Block {<br>\nfn new(index: u64, article: String, source: String, prev_hash: String, private_key: &#x26;[u8]) -> Block {<br>\nlet timestamp = SystemTime::now()<br>\n.duration_since(UNIX_EPOCH)<br>\n.expect(“Time went backwards”)<br>\n.as_millis();<br>\nlet block_data = format!(”{}{}{}{}”, index, timestamp, &#x26;article, &#x26;source);<br>\nlet hash = calculate_hash(&#x26;block_data);<br>\nlet signature = sign_data(block_data.as_bytes(), private_key);<br>\nBlock {<br>\nindex,<br>\ntimestamp,<br>\narticle,<br>\nsource,<br>\nprev_hash,<br>\nhash,<br>\nsignature,<br>\n}<br>\n}<br>\n}</p>\n<p>Now, every time an article is added, the source signs the block digitally, and readers can verify the authenticity of the source using its public key.</p>\n<h3 id=\"conclusion\">Conclusion</h3>\n<p>Using <strong>Rust</strong> and <strong>blockchain</strong>, we have designed a platform that could function as a source of truth, where data is transparent and verifiable. Through digital signatures, we ensure that the sources are trustworthy and that any published information can be audited.</p>\n<p>This approach has great potential for combating fake news by allowing users and auditors to trust that the information has not been altered. The decentralization provided by blockchain ensures that the platform is not controlled by a single entity, reducing the chances of manipulation.</p>\n<p>Would you like to try this approach in a real-world project? <strong>Rust</strong> and <strong>blockchain</strong> offer the tools to create a future with more reliable information!</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/aa489fdd6188\">September 12, 2024</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/creating-a-source-of-truth-like-wikipedia-using-rust-and-blockchain-to-combat-fake-news-aa489fdd6188\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Creating a Source of Truth Like Wikipedia Using Rust and Blockchain to Combat Fake News","description":"","tags":["code","BlockChain"],"time":4,"featured":true,"timestamp":"2024-09-12T12:20:32-0300","filename":"2024-09-12_Creating-a-Source-of-Truth-Like-Wikipedia-Using-Rust-and-Blockchain-to-Combat-Fake-News-aa489fdd6188"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2024-09-12_Creating-a-Source-of-Truth-Like-Wikipedia-Using-Rust-and-Blockchain-to-Combat-Fake-News-aa489fdd6188.md";
				const url = "/blog/2024-09-12_Creating-a-Source-of-Truth-Like-Wikipedia-Using-Rust-and-Blockchain-to-Combat-Fake-News-aa489fdd6188";
				function rawContent() {
					return "   \n                                        \n                                                                                                \n               \n                            \n       \n              \n                                     \n                                                                                                                           \n   \n\nCreating a Source of Truth Like Wikipedia Using Rust and Blockchain to Combat Fake News\n=======================================================================================\n\nIn the information age, fake news and misinformation have become growing issues. In response, there is a need for a source of truth that…\n\n* * *\n\n### Creating a Source of Truth Like Wikipedia Using Rust and Blockchain to Combat Fake News\n\n![](https://cdn-images-1.medium.com/max/800/1*vsnuwlnd3b5Iv2RKY6ltJw.png)\n\nIn the information age, fake news and misinformation have become growing issues. In response, there is a need for a **source of truth** that ensures the accuracy of information and can be audited transparently. Using emerging technologies such as **blockchain** and the **Rust programming language**, it’s possible to create a robust and reliable platform similar to Wikipedia, where data can be verified and maintained in a decentralized manner. This article discusses how to build such a solution from a software engineering perspective.\n\n![](https://cdn-images-1.medium.com/max/800/1*RYHSglNn19VLFO8ecoq1MQ.jpeg)\n\n### Why Rust and Blockchain?\n\n### Rust: Safety and Performance\n\nRust is known for its **memory safety** and high performance, making it an excellent choice for systems where **data integrity** and **concurrency** are critical. These characteristics are essential in a blockchain project, as we need to ensure that the information stored is not corruptible or manipulable.\n\n### Blockchain: Transparency and Decentralization\n\nBlockchain allows the creation of a distributed and immutable database. Each node in the network has a copy of the information, and any modification must be approved through a consensus mechanism, making it difficult to tamper with the data. This makes blockchain ideal for a platform aiming to combat misinformation, as any changes to the information will be transparent and verifiable.\n\n### System Architecture Design\n\n1.  **Frontend**: A Wikipedia-like interface where users can read articles and propose changes or new entries.\n2.  **Backend in Rust**: A system that handles user requests and blockchain transactions.\n3.  **Blockchain**: Stores data immutably, allowing traceability of any modification. Each article on the platform will be associated with a block.\n4.  **Digital Signatures and Verification**: Information sources will be verified through digital signatures and cryptography to ensure that data comes from trusted sources.\n\n### Building the Backend in Rust\n\n### 1\\. Project Initialization\n\nFirst, we set up a Rust project using **Cargo**, the Rust package manager. We install the necessary dependencies to handle cryptography and blockchain.\n\ncargo new source\\_of\\_truth  \ncd source\\_of\\_truth\n\nIn the `Cargo.toml` file, we add the required dependencies:\n\ntoml  \n\\[dependencies\\]  \nserde = { version = \"1.0\", features = \\[\"derive\"\\] }  \nserde\\_json = \"1.0\"  \nsha2 = \"0.9\"  \\# For hash functions  \nring = \"0.16\" \\# For cryptograph\n\n### 2\\. Creating a Block Structure\n\nEach article or change will be represented by a block in the blockchain. We define a block structure that contains the article information, source, and the hash of the previous block:\n\nextern crate sha2;  \nextern crate serde;  \nextern crate serde\\_json;  \nuse sha2::{Sha256, Digest};  \nuse serde::{Serialize, Deserialize};  \nuse std::time::{SystemTime, UNIX\\_EPOCH};  \n#\\[derive(Serialize, Deserialize, Debug, Clone)\\]  \nstruct Block {  \n    index: u64,  \n    timestamp: u128,  \n    article: String,  \n    source: String,  \n    prev\\_hash: String,  \n    hash: String,  \n}  \nimpl Block {  \n    fn new(index: u64, article: String, source: String, prev\\_hash: String) \\-> Block {  \n        let timestamp = SystemTime::now()  \n            .duration\\_since(UNIX\\_EPOCH)  \n            .expect(\"Time went backwards\")  \n            .as\\_millis();  \n        let block\\_data = format!(\"{}{}{}{}\", index, timestamp, &article, &source);  \n        let hash = calculate\\_hash(&block\\_data);  \n        Block {  \n            index,  \n            timestamp,  \n            article,  \n            source,  \n            prev\\_hash,  \n            hash,  \n        }  \n    }  \n}  \nfn calculate\\_hash(data: &str) \\-> String {  \n    let mut hasher = Sha256::new();  \n    hasher.update(data.as\\_bytes());  \n    let result = hasher.finalize();  \n    format!(\"{:x}\", result)  \n}\n\n### 3\\. Implementing the Blockchain\n\nNow, we implement the blockchain, where each new block depends on the hash of the previous block, ensuring immutability.\n\nstruct Blockchain {  \n    chain: Vec<Block>,  \n}  \nimpl Blockchain {  \n    fn new() \\-> Blockchain {  \n        Blockchain {  \n            chain: vec!\\[Blockchain::create\\_genesis\\_block()\\],  \n        }  \n    }  \n    fn create\\_genesis\\_block() \\-> Block {  \n        Block::new(0, String::from(\"Genesis Block\"), String::from(\"N/A\"), String::from(\"0\"))  \n    }  \n    fn add\\_block(&mut self, article: String, source: String) {  \n        let prev\\_block = &self.chain\\[self.chain.len() - 1\\];  \n        let new\\_block = Block::new(  \n            self.chain.len() as u64,  \n            article,  \n            source,  \n            prev\\_block.hash.clone(),  \n        );  \n        self.chain.push(new\\_block);  \n    }  \n    fn is\\_valid(&self) \\-> bool {  \n        for i in 1..self.chain.len() {  \n            let current = &self.chain\\[i\\];  \n            let previous = &self.chain\\[i - 1\\];  \n            if current.prev\\_hash != previous.hash {  \n                return false;  \n            }  \n            let recalculated\\_hash = calculate\\_hash(&format!(  \n                \"{}{}{}{}\",  \n                current.index, current.timestamp, current.article, current.source  \n            ));  \n            if current.hash != recalculated\\_hash {  \n                return false;  \n            }  \n        }  \n        true  \n    }  \n}\n\nWith this basic blockchain implementation, we can add articles as blocks and ensure the chain’s validity by checking the previous hashes.\n\n### 4\\. Verifying with Digital Signatures\n\nTo verify the sources of information, we use **digital signatures**. Each trusted source (e.g., a media outlet or a verified journalist) will have a **private key** to sign the information they publish.\n\n#### Generating Keys\n\nWe use the `ring` library to generate key pairs and sign data:\n\nextern crate ring;  \nuse ring::{rand, signature};  \nfn generate\\_keys() \\-> (Vec<u8\\>, Vec<u8\\>) {  \n    let rng = rand::SystemRandom::new();  \n    let key\\_pair = signature::Ed25519KeyPair::generate\\_pkcs8(&rng).unwrap();  \n    let key\\_pair = signature::Ed25519KeyPair::from\\_pkcs8(key\\_pair.as\\_ref()).unwrap();  \n    (key\\_pair.public\\_key().as\\_ref().to\\_vec(), key\\_pair.private\\_key().as\\_ref().to\\_vec())  \n}  \nfn sign\\_data(data: &\\[u8\\], private\\_key: &\\[u8\\]) \\-> Vec<u8\\> {  \n    let key\\_pair = signature::Ed25519KeyPair::from\\_pkcs8(private\\_key).unwrap();  \n    key\\_pair.sign(data).as\\_ref().to\\_vec()  \n}  \nfn verify\\_signature(data: &\\[u8\\], public\\_key: &\\[u8\\], signature: &\\[u8\\]) \\-> bool {  \n    let peer\\_public\\_key = signature::UnparsedPublicKey::new(&signature::ED25519, public\\_key);  \n    peer\\_public\\_key.verify(data, signature).is\\_ok()  \n}\n\n### 5\\. Integrating the Signature into the Block\n\nNow we can modify our block structure to include digital signatures and verify that the sources are legitimate.\n\n#\\[derive(Serialize, Deserialize, Debug, Clone)\\]  \nstruct Block {  \n    index: u64,  \n    timestamp: u128,  \n    article: String,  \n    source: String,  \n    prev\\_hash: String,  \n    hash: String,  \n    signature: Vec<u8\\>,  \n}  \nimpl Block {  \n    fn new(index: u64, article: String, source: String, prev\\_hash: String, private\\_key: &\\[u8\\]) \\-> Block {  \n        let timestamp = SystemTime::now()  \n            .duration\\_since(UNIX\\_EPOCH)  \n            .expect(\"Time went backwards\")  \n            .as\\_millis();  \n        let block\\_data = format!(\"{}{}{}{}\", index, timestamp, &article, &source);  \n        let hash = calculate\\_hash(&block\\_data);  \n        let signature = sign\\_data(block\\_data.as\\_bytes(), private\\_key);  \n        Block {  \n            index,  \n            timestamp,  \n            article,  \n            source,  \n            prev\\_hash,  \n            hash,  \n            signature,  \n        }  \n    }  \n}\n\nNow, every time an article is added, the source signs the block digitally, and readers can verify the authenticity of the source using its public key.\n\n### Conclusion\n\nUsing **Rust** and **blockchain**, we have designed a platform that could function as a source of truth, where data is transparent and verifiable. Through digital signatures, we ensure that the sources are trustworthy and that any published information can be audited.\n\nThis approach has great potential for combating fake news by allowing users and auditors to trust that the information has not been altered. The decentralization provided by blockchain ensures that the platform is not controlled by a single entity, reducing the chances of manipulation.\n\nWould you like to try this approach in a real-world project? **Rust** and **blockchain** offer the tools to create a future with more reliable information!\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [September 12, 2024](https://medium.com/p/aa489fdd6188).\n\n[Canonical link](https://medium.com/@devjaime/creating-a-source-of-truth-like-wikipedia-using-rust-and-blockchain-to-combat-fake-news-aa489fdd6188)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"creating-a-source-of-truth-like-wikipedia-using-rust-and-blockchain-to-combat-fake-news","text":"Creating a Source of Truth Like Wikipedia Using Rust and Blockchain to Combat Fake News"},{"depth":3,"slug":"creating-a-source-of-truth-like-wikipedia-using-rust-and-blockchain-to-combat-fakenews","text":"Creating a Source of Truth Like Wikipedia Using Rust and Blockchain to Combat Fake News"},{"depth":3,"slug":"why-rust-and-blockchain","text":"Why Rust and Blockchain?"},{"depth":3,"slug":"rust-safety-and-performance","text":"Rust: Safety and Performance"},{"depth":3,"slug":"blockchain-transparency-and-decentralization","text":"Blockchain: Transparency and Decentralization"},{"depth":3,"slug":"system-architecture-design","text":"System Architecture Design"},{"depth":3,"slug":"building-the-backend-inrust","text":"Building the Backend in Rust"},{"depth":3,"slug":"1-project-initialization","text":"1. Project Initialization"},{"depth":3,"slug":"2-creating-a-block-structure","text":"2. Creating a Block Structure"},{"depth":3,"slug":"3-implementing-the-blockchain","text":"3. Implementing the Blockchain"},{"depth":3,"slug":"4-verifying-with-digital-signatures","text":"4. Verifying with Digital Signatures"},{"depth":4,"slug":"generating-keys","text":"Generating Keys"},{"depth":3,"slug":"5-integrating-the-signature-into-theblock","text":"5. Integrating the Signature into the Block"},{"depth":3,"slug":"conclusion","text":"Conclusion"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
