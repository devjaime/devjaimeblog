/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"estrategias-de-redis-en-microservicios-potenciando-el-rendimiento-y-la-escalabilidad\">Estrategias de Redis en Microservicios: Potenciando el Rendimiento y la Escalabilidad</h1>\n<p>Los microservicios han revolucionado la forma en que desarrollamos y gestionamos aplicaciones, permitiendo la modularidad y la…</p>\n<hr>\n<h3 id=\"estrategias-de-redis-en-microservicios-potenciando-el-rendimiento-y-la-escalabilidad-1\">Estrategias de Redis en Microservicios: Potenciando el Rendimiento y la Escalabilidad</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*uLUEt4QnsDyiSAp5.png\" alt=\"\"></p>\n<p>Los microservicios han revolucionado la forma en que desarrollamos y gestionamos aplicaciones, permitiendo la modularidad y la escalabilidad necesarias para enfrentar los desafíos de un mundo digital en constante evolución. Sin embargo, esta arquitectura distribuida también presenta desafíos particulares en términos de gestión de datos y rendimiento. Es aquí donde Redis, una base de datos en memoria altamente escalable, puede desempeñar un papel crucial. En este artículo, exploraremos las estrategias de Redis en microservicios y cómo pueden ayudar a mejorar la eficiencia y la escalabilidad de tus aplicaciones.</p>\n<h3 id=\"qué-esredis\">¿Qué es Redis?</h3>\n<p>Redis es una base de datos en memoria de código abierto que se utiliza ampliamente como almacén de datos en caché, cola de mensajes, y sistema de almacenamiento clave-valor. Su capacidad para manejar datos en memoria con una latencia extremadamente baja lo convierte en una opción ideal para aplicaciones que requieren respuestas rápidas y escalabilidad horizontal.</p>\n<h3 id=\"la-importancia-de-redis-en-microservicios\">La Importancia de Redis en Microservicios</h3>\n<p>Los microservicios se componen de múltiples componentes independientes que se ejecutan de manera distribuida, lo que plantea desafíos en la gestión de datos y la comunicación entre estos componentes. Redis se convierte en una herramienta valiosa en este contexto debido a varias razones:</p>\n<ol>\n<li><strong>Caché de Datos</strong>: Los microservicios pueden utilizar Redis como una capa de caché para almacenar datos temporales. Esto reduce la carga en las bases de datos principales y acelera las respuestas a las solicitudes de los usuarios.</li>\n<li><strong>Comunicación y Coordinación</strong>: Redis proporciona estructuras de datos que facilitan la comunicación y la coordinación entre microservicios. Las listas, colas y conjuntos ordenados permiten la implementación de patrones de mensajería y colaboración.</li>\n<li><strong>Escalabilidad</strong>: Redis está diseñado para ser altamente escalable y se puede implementar en clústeres para manejar cargas de trabajo crecientes de manera efectiva. Esto se adapta perfectamente a la naturaleza escalable de los microservicios.</li>\n<li><strong>Persistencia Opcional</strong>: Aunque Redis es principalmente una base de datos en memoria, también admite la persistencia de datos en disco. Esto es beneficioso para casos en los que la recuperación de datos después de un reinicio es fundamental.</li>\n</ol>\n<h3 id=\"estrategias-clave-de-redis-en-microservicios\">Estrategias Clave de Redis en Microservicios</h3>\n<p>A continuación, se presentan algunas estrategias clave para aprovechar Redis en entornos de microservicios:</p>\n<h3 id=\"1-caché-dedatos\">1. Caché de Datos</h3>\n<p>Utiliza Redis para almacenar en caché datos que se acceden con frecuencia desde diferentes microservicios. Esto reduce la carga en las bases de datos principales y mejora el rendimiento general de la aplicación.</p>\n<h3 id=\"2-cola-demensajes\">2. Cola de Mensajes</h3>\n<p>Implementa colas de mensajes basadas en Redis para la comunicación asíncrona entre microservicios. Esto permite una mayor flexibilidad y una menor dependencia entre los componentes de la aplicación.</p>\n<h3 id=\"3-control-desesiones\">3. Control de Sesiones</h3>\n<p>Utiliza Redis para gestionar las sesiones de usuario. Almacenar información de sesión en Redis garantiza que las sesiones sean compartidas entre los microservicios y que los usuarios puedan mantener su estado incluso si se redirigen a diferentes instancias de microservicios.</p>\n<h3 id=\"4-almacenamiento-de-configuración\">4. Almacenamiento de Configuración</h3>\n<p>Centraliza la gestión de configuración de microservicios en Redis. Esto facilita la actualización y la propagación de configuraciones a lo largo de la aplicación sin necesidad de reiniciar los microservicios.</p>\n<h3 id=\"5-monitoreo-ymétricas\">5. Monitoreo y Métricas</h3>\n<p>Usa Redis para recopilar métricas y datos de monitoreo de los microservicios. Esto te permitirá realizar un seguimiento del rendimiento y el estado de tus microservicios en tiempo real.</p>\n<h4 id=\"a-continuación-algunos-ejemplos-en-nodejs-ygo\">A continuación algunos ejemplos en Nodejs y Go.</h4>\n<h3 id=\"ejemplo-ennodejs\">Ejemplo en Node.js:</h3>\n<h3 id=\"1-caché-de-datos-con-redis-ennodejs\">1. Caché de Datos con Redis en Node.js:</h3>\n<p>const redis = require(‘redis’);<br>\nconst client = redis.createClient();<br>\n// Almacenar en caché un resultado<br>\nclient.set(‘clave’, ‘valor’, ‘EX’, 3600); // Expira en 1 hora<br>\n// Obtener un valor de la caché<br>\nclient.get(‘clave’, (err, result) => {<br>\nif (err) throw err;<br>\nif (result) {<br>\nconsole.log(‘Valor en caché:’, result);<br>\n} else {<br>\n// Si no está en caché, obtén el valor de la base de datos y guárdalo en la caché<br>\nconsole.log(‘Valor no encontrado en caché’);<br>\n// Realiza una consulta a la base de datos y luego guarda el resultado en caché<br>\n}<br>\n});</p>\n<h3 id=\"2-cola-de-mensajes-con-redis-en-nodejs-usando-el-módulobull\">2. Cola de Mensajes con Redis en Node.js (usando el módulo ‘bull’):</h3>\n<p>const Queue = require(‘bull’);<br>\nconst queue = new Queue(‘mi-cola’, ‘redis://localhost:6379’);<br>\n// Productor: Agregar un trabajo a la cola<br>\nqueue.add({ tarea: ‘Procesar datos’ });<br>\n// Consumidor: Procesar trabajos de la cola<br>\nqueue.process((job) => {<br>\nconsole.log(‘Procesando trabajo:’, job.data);<br>\n// Realizar tareas de procesamiento aquí<br>\n});</p>\n<h3 id=\"3-control-de-sesiones-con-redis-en-nodejs-usando-express-session\">3. Control de Sesiones con Redis en Node.js (usando ‘express-session’):</h3>\n<p>const express = require(‘express’);<br>\nconst session = require(‘express-session’);<br>\nconst RedisStore = require(‘connect-redis’)(session);</p>\n<p>const app = express();<br>\napp.use(session({<br>\nstore: new RedisStore({ host: ‘localhost’, port: 6379 }),<br>\nsecret: ‘mi-secreto’,<br>\nresave: false,<br>\nsaveUninitialized: true,<br>\ncookie: { secure: false },<br>\n}));<br>\napp.get(’/’, (req, res) => {<br>\nreq.session.visitas = req.session.visitas ? req.session.visitas + 1 : 1;<br>\nres.send(`Número de visitas: ${req.session.visitas}`);<br>\n});<br>\napp.listen(3000, () => {<br>\nconsole.log(‘Servidor escuchando en el puerto 3000’);<br>\n});</p>\n<h3 id=\"ejemplo-engo\">Ejemplo en Go:</h3>\n<h3 id=\"1-caché-de-datos-con-redis-en-go-usando-el-paquete-githubcomgo-redisredis\">1. Caché de Datos con Redis en Go (usando el paquete ‘github.com/go-redis/redis’):</h3>\n<p>package main</p>\n<p>import (<br>\n“github.com/go-redis/redis/v8\"<br>\n\"context\"<br>\n\"fmt”<br>\n)<br>\nfunc main() {<br>\nctx := context.Background()<br>\nclient := redis.NewClient(&#x26;redis.Options{<br>\nAddr: “localhost:6379”,<br>\n})<br>\n// Almacenar en caché un valor<br>\nerr := client.Set(ctx, “clave”, “valor”, 0).Err()<br>\nif err != nil {<br>\npanic(err)<br>\n}<br>\n// Obtener un valor de la caché<br>\nvalor, err := client.Get(ctx, “clave”).Result()<br>\nif err == redis.Nil {<br>\nfmt.Println(“La clave no se encuentra en caché”)<br>\n} else if err != nil {<br>\npanic(err)<br>\n} else {<br>\nfmt.Println(“Valor en caché:”, valor)<br>\n}<br>\n}</p>\n<h3 id=\"2-cola-de-mensajes-con-redis-en-go-usando-el-paquete-githubcomgo-redisredisv8\">2. Cola de Mensajes con Redis en Go (usando el paquete ‘github.com/go-redis/redis/v8’):</h3>\n<p>package main<br>\nimport (<br>\n“github.com/go-redis/redis/v8\"<br>\n\"context\"<br>\n\"fmt”<br>\n)<br>\nfunc main() {<br>\nctx := context.Background()<br>\nclient := redis.NewClient(&#x26;redis.Options{<br>\nAddr: “localhost:6379”,<br>\n})<br>\n// Productor: Agregar un mensaje a la cola<br>\ncola := “mi-cola”<br>\nerr := client.LPush(ctx, cola, “Mensaje 1”, “Mensaje 2”).Err()<br>\nif err != nil {<br>\npanic(err)<br>\n}<br>\n// Consumidor: Obtener y procesar mensajes de la cola<br>\nfor {<br>\nmensaje, err := client.BRPop(ctx, 0, cola).Result()<br>\nif err != nil {<br>\npanic(err)<br>\n}<br>\nfmt.Println(“Mensaje recibido:”, mensaje[1])<br>\n}<br>\n}</p>\n<p>Estos ejemplos ilustran cómo implementar estrategias comunes de Redis en aplicaciones Node.js y Go para Caché de Datos y Cola de Mensajes. Puedes adaptar y ampliar estos ejemplos según las necesidades específicas de tus aplicaciones. Para el Control de Sesiones, Almacenamiento de Configuración y Monitoreo y Métricas, también existen paquetes y bibliotecas adecuadas en Node.js y Go que puedes utilizar según tus requisitos y preferencias.</p>\n<h3 id=\"conclusión\">Conclusión</h3>\n<p>Redis ofrece un conjunto poderoso de capacidades que pueden mejorar significativamente la eficiencia y la escalabilidad de los microservicios. Ya sea que estés buscando reducir la latencia, mejorar la comunicación entre componentes o simplificar la gestión de datos distribuidos, Redis puede ser una solución valiosa en tu arquitectura de microservicios. Sin embargo, es importante planificar cuidadosamente su implementación y considerar las necesidades específicas de tu aplicación para aprovechar al máximo esta poderosa herramienta.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/555e5e3be4ba\">September 18, 2023</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/estrategias-de-redis-en-microservicios-potenciando-el-rendimiento-y-la-escalabilidad-555e5e3be4ba\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Estrategias de Redis en Microservicios: Potenciando el Rendimiento y la Escalabilidad","description":"","tags":["code","redis","microservicios"],"time":4,"featured":true,"timestamp":"2023-09-18T12:20:32-0300","filename":"2023-09-18_Estrategias-de-Redis-en-Microservicios--Potenciando-el-Rendimiento-y-la-Escalabilidad-555e5e3be4ba"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2023-09-18_Estrategias-de-Redis-en-Microservicios--Potenciando-el-Rendimiento-y-la-Escalabilidad-555e5e3be4ba.md";
				const url = "/blog/2023-09-18_Estrategias-de-Redis-en-Microservicios--Potenciando-el-Rendimiento-y-la-Escalabilidad-555e5e3be4ba";
				function rawContent() {
					return "   \n                                        \n                                                                                              \n               \n                                         \n       \n              \n                                     \n                                                                                                                         \n   \n\nEstrategias de Redis en Microservicios: Potenciando el Rendimiento y la Escalabilidad\n=====================================================================================\n\nLos microservicios han revolucionado la forma en que desarrollamos y gestionamos aplicaciones, permitiendo la modularidad y la…\n\n* * *\n\n### Estrategias de Redis en Microservicios: Potenciando el Rendimiento y la Escalabilidad\n\n![](https://cdn-images-1.medium.com/max/800/0*uLUEt4QnsDyiSAp5.png)\n\nLos microservicios han revolucionado la forma en que desarrollamos y gestionamos aplicaciones, permitiendo la modularidad y la escalabilidad necesarias para enfrentar los desafíos de un mundo digital en constante evolución. Sin embargo, esta arquitectura distribuida también presenta desafíos particulares en términos de gestión de datos y rendimiento. Es aquí donde Redis, una base de datos en memoria altamente escalable, puede desempeñar un papel crucial. En este artículo, exploraremos las estrategias de Redis en microservicios y cómo pueden ayudar a mejorar la eficiencia y la escalabilidad de tus aplicaciones.\n\n### ¿Qué es Redis?\n\nRedis es una base de datos en memoria de código abierto que se utiliza ampliamente como almacén de datos en caché, cola de mensajes, y sistema de almacenamiento clave-valor. Su capacidad para manejar datos en memoria con una latencia extremadamente baja lo convierte en una opción ideal para aplicaciones que requieren respuestas rápidas y escalabilidad horizontal.\n\n### La Importancia de Redis en Microservicios\n\nLos microservicios se componen de múltiples componentes independientes que se ejecutan de manera distribuida, lo que plantea desafíos en la gestión de datos y la comunicación entre estos componentes. Redis se convierte en una herramienta valiosa en este contexto debido a varias razones:\n\n1.  **Caché de Datos**: Los microservicios pueden utilizar Redis como una capa de caché para almacenar datos temporales. Esto reduce la carga en las bases de datos principales y acelera las respuestas a las solicitudes de los usuarios.\n2.  **Comunicación y Coordinación**: Redis proporciona estructuras de datos que facilitan la comunicación y la coordinación entre microservicios. Las listas, colas y conjuntos ordenados permiten la implementación de patrones de mensajería y colaboración.\n3.  **Escalabilidad**: Redis está diseñado para ser altamente escalable y se puede implementar en clústeres para manejar cargas de trabajo crecientes de manera efectiva. Esto se adapta perfectamente a la naturaleza escalable de los microservicios.\n4.  **Persistencia Opcional**: Aunque Redis es principalmente una base de datos en memoria, también admite la persistencia de datos en disco. Esto es beneficioso para casos en los que la recuperación de datos después de un reinicio es fundamental.\n\n### Estrategias Clave de Redis en Microservicios\n\nA continuación, se presentan algunas estrategias clave para aprovechar Redis en entornos de microservicios:\n\n### 1\\. Caché de Datos\n\nUtiliza Redis para almacenar en caché datos que se acceden con frecuencia desde diferentes microservicios. Esto reduce la carga en las bases de datos principales y mejora el rendimiento general de la aplicación.\n\n### 2\\. Cola de Mensajes\n\nImplementa colas de mensajes basadas en Redis para la comunicación asíncrona entre microservicios. Esto permite una mayor flexibilidad y una menor dependencia entre los componentes de la aplicación.\n\n### 3\\. Control de Sesiones\n\nUtiliza Redis para gestionar las sesiones de usuario. Almacenar información de sesión en Redis garantiza que las sesiones sean compartidas entre los microservicios y que los usuarios puedan mantener su estado incluso si se redirigen a diferentes instancias de microservicios.\n\n### 4\\. Almacenamiento de Configuración\n\nCentraliza la gestión de configuración de microservicios en Redis. Esto facilita la actualización y la propagación de configuraciones a lo largo de la aplicación sin necesidad de reiniciar los microservicios.\n\n### 5\\. Monitoreo y Métricas\n\nUsa Redis para recopilar métricas y datos de monitoreo de los microservicios. Esto te permitirá realizar un seguimiento del rendimiento y el estado de tus microservicios en tiempo real.\n\n#### A continuación algunos ejemplos en Nodejs y Go.\n\n### Ejemplo en Node.js:\n\n### 1\\. Caché de Datos con Redis en Node.js:\n\nconst redis = require('redis');  \nconst client = redis.createClient();  \n// Almacenar en caché un resultado  \nclient.set('clave', 'valor', 'EX', 3600); // Expira en 1 hora  \n// Obtener un valor de la caché  \nclient.get('clave', (err, result) => {  \n  if (err) throw err;  \n  if (result) {  \n    console.log('Valor en caché:', result);  \n  } else {  \n    // Si no está en caché, obtén el valor de la base de datos y guárdalo en la caché  \n    console.log('Valor no encontrado en caché');  \n    // Realiza una consulta a la base de datos y luego guarda el resultado en caché  \n  }  \n});\n\n### 2\\. Cola de Mensajes con Redis en Node.js (usando el módulo ‘bull’):\n\nconst Queue = require('bull');  \nconst queue = new Queue('mi-cola', 'redis://localhost:6379');  \n// Productor: Agregar un trabajo a la cola  \nqueue.add({ tarea: 'Procesar datos' });  \n// Consumidor: Procesar trabajos de la cola  \nqueue.process((job) => {  \n  console.log('Procesando trabajo:', job.data);  \n  // Realizar tareas de procesamiento aquí  \n});\n\n### 3\\. Control de Sesiones con Redis en Node.js (usando ‘express-session’):\n\nconst express = require('express');  \nconst session = require('express-session');  \nconst RedisStore = require('connect-redis')(session);  \n  \nconst app = express();  \napp.use(session({  \n  store: new RedisStore({ host: 'localhost', port: 6379 }),  \n  secret: 'mi-secreto',  \n  resave: false,  \n  saveUninitialized: true,  \n  cookie: { secure: false },  \n}));  \napp.get('/', (req, res) => {  \n  req.session.visitas = req.session.visitas ? req.session.visitas + 1 : 1;  \n  res.send(\\`Número de visitas: ${req.session.visitas}\\`);  \n});  \napp.listen(3000, () => {  \n  console.log('Servidor escuchando en el puerto 3000');  \n});\n\n### Ejemplo en Go:\n\n### 1\\. Caché de Datos con Redis en Go (usando el paquete ‘github.com/go-redis/redis’):\n\npackage main  \n  \nimport (  \n    \"github.com/go-redis/redis/v8\"  \n    \"context\"  \n    \"fmt\"  \n)  \nfunc main() {  \n    ctx := context.Background()  \n    client := redis.NewClient(&redis.Options{  \n        Addr: \"localhost:6379\",  \n    })  \n    // Almacenar en caché un valor  \n    err := client.Set(ctx, \"clave\", \"valor\", 0).Err()  \n    if err != nil {  \n        panic(err)  \n    }  \n    // Obtener un valor de la caché  \n    valor, err := client.Get(ctx, \"clave\").Result()  \n    if err == redis.Nil {  \n        fmt.Println(\"La clave no se encuentra en caché\")  \n    } else if err != nil {  \n        panic(err)  \n    } else {  \n        fmt.Println(\"Valor en caché:\", valor)  \n    }  \n}\n\n### 2\\. Cola de Mensajes con Redis en Go (usando el paquete ‘github.com/go-redis/redis/v8’):\n\npackage main  \nimport (  \n    \"github.com/go-redis/redis/v8\"  \n    \"context\"  \n    \"fmt\"  \n)  \nfunc main() {  \n    ctx := context.Background()  \n    client := redis.NewClient(&redis.Options{  \n        Addr: \"localhost:6379\",  \n    })  \n    // Productor: Agregar un mensaje a la cola  \n    cola := \"mi-cola\"  \n    err := client.LPush(ctx, cola, \"Mensaje 1\", \"Mensaje 2\").Err()  \n    if err != nil {  \n        panic(err)  \n    }  \n    // Consumidor: Obtener y procesar mensajes de la cola  \n    for {  \n        mensaje, err := client.BRPop(ctx, 0, cola).Result()  \n        if err != nil {  \n            panic(err)  \n        }  \n        fmt.Println(\"Mensaje recibido:\", mensaje\\[1\\])  \n    }  \n}\n\nEstos ejemplos ilustran cómo implementar estrategias comunes de Redis en aplicaciones Node.js y Go para Caché de Datos y Cola de Mensajes. Puedes adaptar y ampliar estos ejemplos según las necesidades específicas de tus aplicaciones. Para el Control de Sesiones, Almacenamiento de Configuración y Monitoreo y Métricas, también existen paquetes y bibliotecas adecuadas en Node.js y Go que puedes utilizar según tus requisitos y preferencias.\n\n### Conclusión\n\nRedis ofrece un conjunto poderoso de capacidades que pueden mejorar significativamente la eficiencia y la escalabilidad de los microservicios. Ya sea que estés buscando reducir la latencia, mejorar la comunicación entre componentes o simplificar la gestión de datos distribuidos, Redis puede ser una solución valiosa en tu arquitectura de microservicios. Sin embargo, es importante planificar cuidadosamente su implementación y considerar las necesidades específicas de tu aplicación para aprovechar al máximo esta poderosa herramienta.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [September 18, 2023](https://medium.com/p/555e5e3be4ba).\n\n[Canonical link](https://medium.com/@devjaime/estrategias-de-redis-en-microservicios-potenciando-el-rendimiento-y-la-escalabilidad-555e5e3be4ba)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"estrategias-de-redis-en-microservicios-potenciando-el-rendimiento-y-la-escalabilidad","text":"Estrategias de Redis en Microservicios: Potenciando el Rendimiento y la Escalabilidad"},{"depth":3,"slug":"estrategias-de-redis-en-microservicios-potenciando-el-rendimiento-y-la-escalabilidad-1","text":"Estrategias de Redis en Microservicios: Potenciando el Rendimiento y la Escalabilidad"},{"depth":3,"slug":"qué-esredis","text":"¿Qué es Redis?"},{"depth":3,"slug":"la-importancia-de-redis-en-microservicios","text":"La Importancia de Redis en Microservicios"},{"depth":3,"slug":"estrategias-clave-de-redis-en-microservicios","text":"Estrategias Clave de Redis en Microservicios"},{"depth":3,"slug":"1-caché-dedatos","text":"1. Caché de Datos"},{"depth":3,"slug":"2-cola-demensajes","text":"2. Cola de Mensajes"},{"depth":3,"slug":"3-control-desesiones","text":"3. Control de Sesiones"},{"depth":3,"slug":"4-almacenamiento-de-configuración","text":"4. Almacenamiento de Configuración"},{"depth":3,"slug":"5-monitoreo-ymétricas","text":"5. Monitoreo y Métricas"},{"depth":4,"slug":"a-continuación-algunos-ejemplos-en-nodejs-ygo","text":"A continuación algunos ejemplos en Nodejs y Go."},{"depth":3,"slug":"ejemplo-ennodejs","text":"Ejemplo en Node.js:"},{"depth":3,"slug":"1-caché-de-datos-con-redis-ennodejs","text":"1. Caché de Datos con Redis en Node.js:"},{"depth":3,"slug":"2-cola-de-mensajes-con-redis-en-nodejs-usando-el-módulobull","text":"2. Cola de Mensajes con Redis en Node.js (usando el módulo ‘bull’):"},{"depth":3,"slug":"3-control-de-sesiones-con-redis-en-nodejs-usando-express-session","text":"3. Control de Sesiones con Redis en Node.js (usando ‘express-session’):"},{"depth":3,"slug":"ejemplo-engo","text":"Ejemplo en Go:"},{"depth":3,"slug":"1-caché-de-datos-con-redis-en-go-usando-el-paquete-githubcomgo-redisredis","text":"1. Caché de Datos con Redis en Go (usando el paquete ‘github.com/go-redis/redis’):"},{"depth":3,"slug":"2-cola-de-mensajes-con-redis-en-go-usando-el-paquete-githubcomgo-redisredisv8","text":"2. Cola de Mensajes con Redis en Go (usando el paquete ‘github.com/go-redis/redis/v8’):"},{"depth":3,"slug":"conclusión","text":"Conclusión"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
