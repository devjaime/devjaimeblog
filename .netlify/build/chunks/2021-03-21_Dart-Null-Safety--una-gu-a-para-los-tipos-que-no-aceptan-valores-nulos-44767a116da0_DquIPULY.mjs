/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"dart-null-safety-una-gu√≠a-para-los-tipos-que-no-aceptan-valores-nulos\">Dart Null Safety: una gu√≠a para los tipos que no aceptan valores nulos</h1>\n<p>La introducci√≥n de Null Safety en Dart 2.9 marca un hito importante para el idioma. Null Safety(verificaci√≥n de valores nulos en espa√±ol)‚Ä¶</p>\n<hr>\n<h3 id=\"dart-null-safety-una-gu√≠a-para-los-tipos-que-no-aceptan-valoresnulos\">Dart Null Safety: una gu√≠a para los tipos que no aceptan valores¬†nulos</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*jvllq9-b3Kp6oDGQ.png\" alt=\"\"></p>\n<p>La introducci√≥n de Null Safety en Dart 2.9 marca un hito importante para el idioma. Null Safety(verificaci√≥n de valores nulos en espa√±ol) te ayuda a evitar toda una clase de problemas y permite algunas mejoras de rendimiento.</p>\n<p>Este art√≠culo describe los cambios y muestra c√≥mo utilizar las nuevas funciones de Null Safety con un ejemplo.</p>\n<p><em>puedes probar Null Safety en</em> <a href=\"https://nullsafety.dartpad.dev/\"><em>nullsafety.dartpad.dev</em></a>¬†<em>:</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*nVq4aw9jq-k5DRUT.png\" alt=\"\"></p>\n<p>Esto contiene un ‚Äú¬°Aprenda de los fragmentos!‚Äù men√∫ desplegable con mini-ejercicios para familiarizarse con la nueva sintaxis.</p>\n<h3 id=\"tabla-de-contenido\">Tabla de contenido</h3>\n<ul>\n<li>Algo de contexto</li>\n<li>Sistema de tipo dart</li>\n<li>Dart Null Safety: Beneficios</li>\n<li>Declaraci√≥n de variables que no aceptan valores NULL</li>\n<li>Declaraci√≥n de variables que aceptan valores NULL</li>\n<li>El operador de aserci√≥n</li>\n<li>An√°lisis de flujo: promoci√≥n</li>\n<li>An√°lisis de flujo: asignaci√≥n definitiva</li>\n<li>Usar variables que no aceptan valores NULL con clases</li>\n<li>Argumentos posicionales y con nombre que no aceptan valores NULL</li>\n<li>Operador de cascada con reconocimiento nulo</li>\n<li>Operador de sub√≠ndice nulo</li>\n<li>La palabra clave tard√≠a</li>\n<li>Variables est√°ticas y globales</li>\n<li>Conclusi√≥n</li>\n<li>Referencias</li>\n</ul>\n<h3 id=\"algo-decontexto\">Algo de¬†contexto</h3>\n<p>Las referencias nulas se <a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/\">introdujeron por primera vez</a> en 1965 en el lenguaje de programaci√≥n ALGOL y desde entonces han sido adoptadas por la mayor√≠a de los lenguajes de programaci√≥n convencionales.</p>\n<p>Sin embargo, los errores nulos son tan comunes que las referencias nulas se han denominado el error del bill√≥n de d√≥lares.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*xPVtP9-lEtpkmEj0\" alt=\"\"></p>\n<p>Entonces, veamos qu√© ha cambiado en Dart para abordar esto.</p>\n<h3 id=\"sistema-de-tipodart\">Sistema de tipo¬†dart</h3>\n<p>Antes de abordar Null Safety, hablemos del sistema de tipo Dart.</p>\n<p>Se dice que Dart tiene un <strong>sistema de tipo sound</strong> (sera por que a medida que escribe ‚Äú<strong>escucha</strong>‚Äù tus cambios y te informa tus errores). Cuando escribimos c√≥digo Dart, el <strong>verificador de tipos</strong> se asegura de que no podamos escribir algo como esto:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>int age = \"hello world\"; // A value of type `String` can't be assigned to a variable of type `int`</span></span></code></pre>\n<p>Este c√≥digo produce un error que nos dice que <em>‚Äú</em> <code>_String_</code><em>no se puede asignar un valor a una variable de tipo</em> <code>_int_</code><em>‚Äù</em>¬†.</p>\n<p>De manera similar, cuando escribimos una funci√≥n en Dart, podemos especificar un <strong>tipo de</strong> retorno¬†:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*FHXNjRdAEPAfhWfHq3hbCA.png\" alt=\"\"></p>\n<p>Debido a la <strong>seguridad</strong> del <strong>tipo</strong>¬†, Dart puede garantizar con un 100% de confianza que esta funci√≥n <strong>siempre</strong> devuelve un <code>int</code>.</p>\n<blockquote>\n<p><em>La seguridad de tipos nos ayuda a escribir programas m√°s seguros y a razonar m√°s f√°cilmente sobre el c√≥digo.</em></p>\n</blockquote>\n<p>Pero la seguridad de tipos por s√≠ sola no puede garantizar que una variable (o un valor de retorno) no sea <code>null</code>.</p>\n<p>Como resultado, este c√≥digo se compila, pero genera una excepci√≥n <strong>en tiempo de ejecuci√≥n</strong>¬†:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*zFa0gW0JZmYXXPje7vsASQ.png\" alt=\"\"></p>\n<p>En este ejemplo, es bastante f√°cil detectar el problema. Pero en bases de c√≥digo grandes es dif√≠cil hacer un seguimiento de lo que puede y no puede ser <code>null</code>.</p>\n<p>Las comprobaciones<code>null</code> en tiempo de ejecuci√≥n pueden mitigar el problema, pero agregan m√°s ruido:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*Q6avbzvWGMKc-VUMAlKyUg.png\" alt=\"\"></p>\n<p>Lo que realmente queremos aqu√≠ es decirle a Dart que el argumento<code>value</code> <strong>nunca</strong> deber√≠a ser <code>null</code>.</p>\n<p>Se necesita una mejor soluci√≥n, y ahora la tenemos. üòé</p>\n<h3 id=\"dart-null-safety-beneficios\">Dart Null Safety: Beneficios</h3>\n<p>Dart 2.9 presenta <strong>Sound Null Safety</strong> como una funci√≥n de lenguaje y aporta tres beneficios principales:</p>\n<ul>\n<li>Podemos escribir c√≥digo seguro para valores nulos con s√≥lidas garant√≠as de <strong>tiempo de compilaci√≥n</strong>¬†. Esto nos hace productivos porque Dart puede decirnos cuando estamos haciendo algo mal.</li>\n<li>Podemos declarar m√°s f√°cilmente nuestra <strong>intenci√≥n</strong>¬†. Esto conduce a una API que se autodocumentan y son f√°ciles de usar.</li>\n<li>El compilador de Dart puede optimizar nuestro c√≥digo, lo que resulta en programas m√°s peque√±os y r√°pidos.</li>\n</ul>\n<p>As√≠ que veamos c√≥mo funciona la seguridad nula en la pr√°ctica.</p>\n<h3 id=\"declaraci√≥n-de-variables-que-no-aceptan-valoresnull\">Declaraci√≥n de variables que no aceptan valores¬†NULL</h3>\n<p>El cambio de lenguaje principal es que <strong>de forma predeterminada</strong> todos los tipos ahora no admiten nulos¬†.</p>\n<p>Esto significa que este c√≥digo no se compila:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*1X07SFJIkQfInqUMGwR9Dg.png\" alt=\"\"></p>\n<p>Al usar variables que no aceptan valores NULL, debemos seguir una regla importante:</p>\n<blockquote>\n<p><em>Las variables que no aceptan valores NULL siempre deben inicializarse con valores que no sean nulos.</em></p>\n</blockquote>\n<p>Si razona en este sentido, ser√° m√°s f√°cil comprender todos los nuevos cambios de sintaxis.</p>\n<hr>\n<p>Repasemos este ejemplo:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*hpOuIYihEitiPttnPyT18g.png\" alt=\"\"></p>\n<p>Aqu√≠ se <strong>garantiza</strong> que tanto el argumento como el valor de retorno no son <code>null</code>.</p>\n<p>Como resultado, las comprobaciones <code>null</code> en <strong>tiempo de</strong> ejecuci√≥n ya no son necesarias y este c√≥digo ahora produce un error en <strong>tiempo de compilaci√≥n</strong>¬†:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*zFa0gW0JZmYXXPje7vsASQ.png\" alt=\"\"></p>\n<p>Pero si todos los tipos ahora <strong>no aceptan valores NULL</strong> de forma predeterminada, ¬øc√≥mo podemos declarar variables que <strong>aceptan valores NULL</strong> ?</p>\n<h3 id=\"declaraci√≥n-de-variables-que-aceptan-valoresnull\">Declaraci√≥n de variables que aceptan valores¬†NULL</h3>\n<p>El s√≠mbolo<code>**?**</code> es lo que necesitamos:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*ulEKWUQCzcJRx9IckHNWOg.png\" alt=\"\"></p>\n<p><em>Nota: no es necesario inicializar una variable que acepte valores NULL antes de usarla. Se inicializa</em> <code>_null_</code><em>de forma predeterminada.</em></p>\n<p>Aqu√≠ hay algunas otras formas de declarar variables que aceptan valores NULL:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*i96n-zRcMQVGxh4GF2MPuA.png\" alt=\"\"></p>\n<p>Las variables que aceptan valores NULL son una buena forma de expresar la <strong>ausencia</strong> de un valor y esto es √∫til en muchas API.</p>\n<p>Cuando dise√±e una API, preg√∫ntese si una variable debe ser null o no, y declare en consecuencia.</p>\n<p>Pero hay casos en los que sabemos que algo no puede ser <code>null</code>, pero no podemos <strong>demostr√°rselo</strong> al compilador. En estos casos, el operador de aserci√≥n puede ayudar.</p>\n<h3 id=\"el-operador-deaserci√≥n\">El operador de¬†aserci√≥n</h3>\n<p>Podemos usar el operador de aserci√≥n¬†<code>**!**</code>para asignar una expresi√≥n null a una variable no anulable:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*9l6QKqsMDl8km59Nkn8_4w.png\" alt=\"\"></p>\n<p>Al hacer esto, le estamos <strong>diciendo a</strong> Dart que <code>maybeValue</code>no es <code>null</code>, y es seguro asignarlo a una variable que no acepta valores NULL.</p>\n<p>Tenga en cuenta que la aplicaci√≥n del operador de aserci√≥n a un <code>null</code>valor arrojar√° una excepci√≥n de tiempo de ejecuci√≥n:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*Adc7XC3Ta5q8mXMKwmxSIA.png\" alt=\"\"></p>\n<p><em>Cuando sus suposiciones son incorrectas, el</em> <code>_!_</code><em>operador genera excepciones en tiempo de ejecuci√≥n</em></p>\n<hr>\n<p>A veces necesitamos trabajar con APIs que devuelven valores que aceptan valores NULL. Revisemos la funci√≥n<code>lastName</code>:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*73mRztMJkydiAR8rpfn90Q.png\" alt=\"\"></p>\n<p>Aqu√≠ el sistema de tipos no puede ayudar. Si nosotros <strong>sabemos</strong> que la funci√≥n <strong>va a</strong> devolver un valor que no es<code>null</code> para un argumento dado, hay que asignarlo a una variable no anulable <strong>tan pronto como sea posible</strong>¬†.</p>\n<p>Esto se hace con el operador<code>!</code>:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*WAWz6l_5fj2sE4MiF_IJQQ.png\" alt=\"\"></p>\n<p>En resumen:</p>\n<ul>\n<li>Intente crear variables que no admitan valores NULL cuando sea posible, ya que se <strong>garantizar√°</strong> que no lo est√©n <code>null</code>en el <strong>momento de la compilaci√≥n</strong>¬†.</li>\n<li>Si sabe que una expresi√≥n anulable no ser√° <code>null</code>, puede asignarla a una variable no anulable con el¬†<code>!</code>operador.</li>\n</ul>\n<h3 id=\"an√°lisis-de-flujo-promoci√≥n\">An√°lisis de flujo: promoci√≥n</h3>\n<p>Dart puede facilitarle la vida al tener en cuenta las comprobaciones <code>null</code> de las variables que aceptan valores NULL:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*AoVFL0HJLEYeyZbmCm8dqw.png\" alt=\"\"></p>\n<p>Aqu√≠ usamos una declaraci√≥n<code>if</code> para regresar antes si el argumento<code>value</code> es <code>null</code>.</p>\n<p>M√°s all√° de ese punto, <code>value</code>no puede ser<code>null</code>y se trata (o <strong>promociona</strong> ) a un valor que no acepta valores NULL. Por lo tanto, podemos usar con seguridad en <code>value.abs()</code>lugar de <code>value?.abs()</code>(con el operador consciente de nulos).</p>\n<p>De manera similar, podr√≠amos lanzar una excepci√≥n si el valor es <code>null</code>:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*1z9RmH3fm_pN0o1nO1QZFg.png\" alt=\"\"></p>\n<p>Una vez m√°s, <code>value</code>se promueve a un valor que no acepta valores NULL y¬†<code>?.</code>no se necesita el operador de reconocimiento de nulos¬†.</p>\n<p>En resumen:</p>\n<ul>\n<li>Utilice verificaciones nulas <strong>por adelantado</strong> para devolver antes o lanzar excepciones</li>\n<li>Despu√©s de las comprobaciones nulas, las variables que aceptan valores NULL se <strong>promueven</strong> para que no admitan valores NULL.</li>\n</ul>\n<p>Y despu√©s de que una variable anulable se haya verificado como nula, Dart te permite usarla como una variable no anulable, lo cual es bastante bueno.</p>\n<h3 id=\"an√°lisis-de-flujo-asignaci√≥n-definitiva\">An√°lisis de flujo: asignaci√≥n definitiva</h3>\n<p>Dart sabe d√≥nde se <strong>asignan las</strong> variables y d√≥nde se <strong>leen</strong>¬†.</p>\n<p>Este ejemplo muestra c√≥mo inicializar una variable que no acepta valores NULL <strong>despu√©s de</strong> verificar una condici√≥n:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*eK8BTupeVnw8C5KZcl__vQ.png\" alt=\"\"></p>\n<p>Siempre que se le d√© un valor a una variable que no acepta valores NULL <strong>antes</strong> de usarla, Dart no reclamara.</p>\n<h3 id=\"usar-variables-que-no-aceptan-valores-null-conclases\">Usar variables que no aceptan valores NULL con¬†clases</h3>\n<p>Las variables de instancia en las clases deben inicializarse si no aceptan valores NULL:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*Y59vP-rqo2_MHe2-PjEN5w.png\" alt=\"\"></p>\n<p>Si una variable de instancia que no acepta valores NULL no se puede inicializar con un valor predeterminado, config√∫relo con un constructor:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*QdlJQ5GrcqxW1zq3dzI1lA.png\" alt=\"\"></p>\n<p>Argumentos posicionales y con nombre que no aceptan valores NULL</p>\n<p>Con Null Safety, los argumentos con <strong>nombre que</strong> no aceptan <strong>valores</strong> NULL siempre deben ser <strong>obligatorios</strong> o tener un <strong>valor predeterminado</strong>¬†.</p>\n<p>Esto se aplica tanto a los m√©todos regulares como a los constructores de clases:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*CIHCJ3fXaY4KTcawF9FSXA.png\" alt=\"\"></p>\n<p>Podemos arreglar el c√≥digo anterior con el nuevo <code>required</code> <strong>modificador</strong>¬†, que reemplaza la <code>@required</code> <strong>anotaci√≥n anterior</strong>¬†:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*IW1Mi7g_kFC4QRK9kLSg9Q.png\" alt=\"\"></p>\n<p>Y cuando usamos las API anteriores, Dart puede decirnos si estamos haciendo algo mal:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*ZFA2149BBJNmRN2K6MQ3iQ.png\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*N1na7CkT0r8q0LTUT_kqmw.png\" alt=\"\"></p>\n<p>Los par√°metros <strong>posicionales</strong> est√°n sujetos a las mismas reglas:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*cQeQ7JMxZVwtmnDI2hF-Dg.png\" alt=\"\"></p>\n<p><em>Entre variables null y no null, argumentos con nombre y posicionales, valores obligatorios y predeterminados, hay mucho que asimilar. Si est√° confundido, recuerde la regla de oro:</em></p>\n<hr>\n<blockquote>\n<p><em>Las variables que no aceptan valores NULL siempre deben inicializarse con valores que no sean nulos.</em></p>\n</blockquote>\n<p><em>Para comprender completamente todas las funciones de seguridad nula, practique su uso con</em> <a href=\"https://dartpad.dev/?null_safety=true\"><em>Dartpad</em></a><em>. Dart le dir√° si est√° haciendo algo mal, as√≠ que lea los mensajes de error con atenci√≥n.</em> üîç</p>\n<h3 id=\"operador-de-cascada-con-reconocimiento-nulo\">Operador de cascada con reconocimiento nulo</h3>\n<p>Para hacer frente a Null Safety, el operador en cascada ahora adquiere una nuevos valores <code>null¬†?..</code>. Ejemplo:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*3a_ni6coMxemLuSgzkclLg.png\" alt=\"\"></p>\n<p>Las operaciones en cascada anteriores solo se ejecutar√°n si <code>path</code>no es as√≠ <code>null</code>.</p>\n<p>El operador de cascada con detecci√≥n de nulos puede <strong>provocar un cortocircuito</strong>¬†, por lo que solo¬†<code>?..</code>se necesita un operador al comienzo de la secuencia.</p>\n<h3 id=\"operador-de-sub√≠ndice-nulo\">Operador de sub√≠ndice nulo</h3>\n<p>Hasta ahora, verificar si una colecci√≥n era <code>null</code>antes de usar el operador de sub√≠ndice era detallado:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*lsntZAufevn7E-AQLoPB0w.png\" alt=\"\"></p>\n<p>Dart 2.9 presenta al <code>null</code>operador¬†<code>?[]</code>, lo que hace que esto sea mucho m√°s f√°cil:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*PUDgdjxpeFhPSPnD8PUNeg.png\" alt=\"\"></p>\n<h3 id=\"la-palabra-clavelate\">La palabra clave¬†late</h3>\n<p>Utilice la palabra <code>late</code> clave para inicializar una variable cuando se <strong>lee por primera vez</strong>¬†, en lugar de cuando se <strong>crea</strong>¬†.</p>\n<p>Un buen ejemplo es al inicializar variables en <code>initState()</code>:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*NOFIr5bh7smBQRDTfyBIYg.png\" alt=\"\"></p>\n<p>A√∫n mejor, <code>initState()</code>se puede eliminar por completo:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*mPQSU8bJ4eLT3qmz11rFMQ.png\" alt=\"\"></p>\n<p>Es com√∫n usar <code>late</code>en combinaci√≥n con <code>final</code>, para <strong>diferir</strong> la creaci√≥n de variables de <strong>solo lectura</strong> hasta el momento en que se leen por primera vez.</p>\n<p>Esto es ideal cuando se crean variables cuyo inicializador hace un trabajo pesado:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*82jm8t12bJ1Frm_IkQqC1g.png\" alt=\"\"></p>\n<p>Cuando se usa dentro de un cuerpo de funci√≥n, <code>late</code>y <code>final</code>se puede usar as√≠:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*-hUI5LOLN7KHQRVcPIRJVQ.png\" alt=\"\"></p>\n<p>Aunque no recomiendo el uso de variables late de esta manera. Porque este estilo puede resultar en errores de ejecuci√≥n no obvios. Ejemplo:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*6FJZdB8r6n8zNusRFbI9jA.png\" alt=\"\"></p>\n<p>Al declarar una variable<code>late</code> que no acepta valores NULL¬†, <strong>prometemos</strong> que no ser√° nula en tiempo de ejecuci√≥n, y Dart nos ayuda con algunas garant√≠as de tiempo de compilaci√≥n.</p>\n<p>Pero recomiendo usar solo <code>late con</code>moderaci√≥n y siempre inicializar las variables <code>late</code> cuando se declaran.</p>\n<h3 id=\"variables-est√°ticas-yglobales\">Variables est√°ticas y¬†globales</h3>\n<p>Todas las variables globales <strong>ahora deben inicializarse cuando se declaran, a</strong> menos que sean <code>late</code>:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*ODg745f-lNXbRuqr1jEavA.png\" alt=\"\"></p>\n<p>Lo mismo se aplica a las variables de clase est√°ticas:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*gDF7CmUZ77QGVvKWTnoZ0g.png\" alt=\"\"></p>\n<p>Pero como dije antes, no recomiendo usar <code>late de esta</code>forma, ya que puede provocar errores de tiempo de ejecuci√≥n.</p>\n<h3 id=\"conclusi√≥n\">Conclusi√≥n</h3>\n<p>Null Safety es un cambio importante para el lenguaje Dart y se ha introducido para ayudarte a escribir un c√≥digo mejor y m√°s seguro.</p>\n<p>Pero al final del d√≠a, Null Safety es solo una herramienta, y es su trabajo usarla correctamente.</p>\n<p>Cada vez que declare una variable en Dart, piense si deber√≠a ser null o no. Esto puede parecer un trabajo adicional, pero conducir√° a un mejor c√≥digo y Dart puede ayudarlo en el camino.</p>\n<p><a href=\"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\" title=\"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\"><strong>Donate to devjaime</strong><br>\n_Help support devjaime by donating or sharing with your friends._www.paypal.com</a><a href=\"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\"></a></p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hern√°ndez</a> on <a href=\"https://medium.com/p/44767a116da0\">March 21, 2021</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/dart-null-safety-una-gu%C3%ADa-para-los-tipos-que-no-aceptan-valores-nulos-44767a116da0\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Dart Null Safety: una gu√≠a para los tipos que no aceptan valores nulos ","description":"","tags":["code","Dart","Flutter"],"time":4,"featured":true,"timestamp":"2021-03-21T12:20:31-0300","filename":"2021-03-21_Dart-Null-Safety--una-gu-a-para-los-tipos-que-no-aceptan-valores-nulos-44767a116da0"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2021-03-21_Dart-Null-Safety--una-gu-a-para-los-tipos-que-no-aceptan-valores-nulos-44767a116da0.md";
				const url = "/blog/2021-03-21_Dart-Null-Safety--una-gu-a-para-los-tipos-que-no-aceptan-valores-nulos-44767a116da0";
				function rawContent() {
					return "   \n                                        \n                                                                                \n               \n                                 \n       \n              \n                                     \n                                                                                                          \n   \n\n\nDart Null Safety: una gu√≠a para los tipos que no aceptan valores nulos\n======================================================================\n\nLa introducci√≥n de Null Safety en Dart 2.9 marca un hito importante para el idioma. Null Safety(verificaci√≥n de valores nulos en espa√±ol)‚Ä¶\n\n* * *\n\n### Dart Null Safety: una gu√≠a para los tipos que no aceptan valores¬†nulos\n\n![](https://cdn-images-1.medium.com/max/800/0*jvllq9-b3Kp6oDGQ.png)\n\nLa introducci√≥n de Null Safety en Dart 2.9 marca un hito importante para el idioma. Null Safety(verificaci√≥n de valores nulos en espa√±ol) te ayuda a evitar toda una clase de problemas y permite algunas mejoras de rendimiento.\n\nEste art√≠culo describe los cambios y muestra c√≥mo utilizar las nuevas funciones de Null Safety con un ejemplo.\n\n_puedes probar Null Safety en_ [_nullsafety.dartpad.dev_](https://nullsafety.dartpad.dev/)¬†_:_\n\n![](https://cdn-images-1.medium.com/max/800/0*nVq4aw9jq-k5DRUT.png)\n\nEsto contiene un ‚Äú¬°Aprenda de los fragmentos!‚Äù men√∫ desplegable con mini-ejercicios para familiarizarse con la nueva sintaxis.\n\n### Tabla de contenido\n\n*   Algo de contexto\n*   Sistema de tipo dart\n*   Dart Null Safety: Beneficios\n*   Declaraci√≥n de variables que no aceptan valores NULL\n*   Declaraci√≥n de variables que aceptan valores NULL\n*   El operador de aserci√≥n\n*   An√°lisis de flujo: promoci√≥n\n*   An√°lisis de flujo: asignaci√≥n definitiva\n*   Usar variables que no aceptan valores NULL con clases\n*   Argumentos posicionales y con nombre que no aceptan valores NULL\n*   Operador de cascada con reconocimiento nulo\n*   Operador de sub√≠ndice nulo\n*   La palabra clave tard√≠a\n*   Variables est√°ticas y globales\n*   Conclusi√≥n\n*   Referencias\n\n### Algo de¬†contexto\n\nLas referencias nulas se [introdujeron por primera vez](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/) en 1965 en el lenguaje de programaci√≥n ALGOL y desde entonces han sido adoptadas por la mayor√≠a de los lenguajes de programaci√≥n convencionales.\n\nSin embargo, los errores nulos son tan comunes que las referencias nulas se han denominado el error del bill√≥n de d√≥lares.\n\n![](https://cdn-images-1.medium.com/max/800/0*xPVtP9-lEtpkmEj0)\n\nEntonces, veamos qu√© ha cambiado en Dart para abordar esto.\n\n### Sistema de tipo¬†dart\n\nAntes de abordar Null Safety, hablemos del sistema de tipo Dart.\n\nSe dice que Dart tiene un **sistema de tipo sound** (sera por que a medida que escribe ‚Äú**escucha**‚Äù tus cambios y te informa tus errores). Cuando escribimos c√≥digo Dart, el **verificador de tipos** se asegura de que no podamos escribir algo como esto:\n\n    int age = \"hello world\"; // A value of type `String` can't be assigned to a variable of type `int`\n\nEste c√≥digo produce un error que nos dice que _‚Äú_ `_String_`_no se puede asignar un valor a una variable de tipo_ `_int_`_\"_¬†.\n\nDe manera similar, cuando escribimos una funci√≥n en Dart, podemos especificar un **tipo de** retorno¬†:\n\n![](https://cdn-images-1.medium.com/max/800/1*FHXNjRdAEPAfhWfHq3hbCA.png)\n\nDebido a la **seguridad** del **tipo**¬†, Dart puede garantizar con un 100% de confianza que esta funci√≥n **siempre** devuelve un `int`.\n\n> _La seguridad de tipos nos ayuda a escribir programas m√°s seguros y a razonar m√°s f√°cilmente sobre el c√≥digo._\n\nPero la seguridad de tipos por s√≠ sola no puede garantizar que una variable (o un valor de retorno) no sea `null`.\n\nComo resultado, este c√≥digo se compila, pero genera una excepci√≥n **en tiempo de ejecuci√≥n**¬†:\n\n![](https://cdn-images-1.medium.com/max/800/1*zFa0gW0JZmYXXPje7vsASQ.png)\n\nEn este ejemplo, es bastante f√°cil detectar el problema. Pero en bases de c√≥digo grandes es dif√≠cil hacer un seguimiento de lo que puede y no puede ser `null`.\n\nLas comprobaciones`null` en tiempo de ejecuci√≥n pueden mitigar el problema, pero agregan m√°s ruido:\n\n![](https://cdn-images-1.medium.com/max/800/1*Q6avbzvWGMKc-VUMAlKyUg.png)\n\nLo que realmente queremos aqu√≠ es decirle a Dart que el argumento`value` **nunca** deber√≠a ser `null`.\n\nSe necesita una mejor soluci√≥n, y ahora la tenemos. üòé\n\n### Dart Null Safety: Beneficios\n\nDart 2.9 presenta **Sound Null Safety** como una funci√≥n de lenguaje y aporta tres beneficios principales:\n\n*   Podemos escribir c√≥digo seguro para valores nulos con s√≥lidas garant√≠as de **tiempo de compilaci√≥n**¬†. Esto nos hace productivos porque Dart puede decirnos cuando estamos haciendo algo mal.\n*   Podemos declarar m√°s f√°cilmente nuestra **intenci√≥n**¬†. Esto conduce a una API que se autodocumentan y son f√°ciles de usar.\n*   El compilador de Dart puede optimizar nuestro c√≥digo, lo que resulta en programas m√°s peque√±os y r√°pidos.\n\nAs√≠ que veamos c√≥mo funciona la seguridad nula en la pr√°ctica.\n\n### Declaraci√≥n de variables que no aceptan valores¬†NULL\n\nEl cambio de lenguaje principal es que **de forma predeterminada** todos los tipos ahora no admiten nulos¬†.\n\nEsto significa que este c√≥digo no se compila:\n\n![](https://cdn-images-1.medium.com/max/800/1*1X07SFJIkQfInqUMGwR9Dg.png)\n\nAl usar variables que no aceptan valores NULL, debemos seguir una regla importante:\n\n> _Las variables que no aceptan valores NULL siempre deben inicializarse con valores que no sean nulos._\n\nSi razona en este sentido, ser√° m√°s f√°cil comprender todos los nuevos cambios de sintaxis.\n\n* * *\n\nRepasemos este ejemplo:\n\n![](https://cdn-images-1.medium.com/max/800/1*hpOuIYihEitiPttnPyT18g.png)\n\nAqu√≠ se **garantiza** que tanto el argumento como el valor de retorno no son `null`.\n\nComo resultado, las comprobaciones `null` en **tiempo de** ejecuci√≥n ya no son necesarias y este c√≥digo ahora produce un error en **tiempo de compilaci√≥n**¬†:\n\n![](https://cdn-images-1.medium.com/max/800/1*zFa0gW0JZmYXXPje7vsASQ.png)\n\nPero si todos los tipos ahora **no aceptan valores NULL** de forma predeterminada, ¬øc√≥mo podemos declarar variables que **aceptan valores NULL** ?\n\n### Declaraci√≥n de variables que aceptan valores¬†NULL\n\nEl s√≠mbolo`**?**` es lo que necesitamos:\n\n![](https://cdn-images-1.medium.com/max/800/1*ulEKWUQCzcJRx9IckHNWOg.png)\n\n_Nota: no es necesario inicializar una variable que acepte valores NULL antes de usarla. Se inicializa_ `_null_`_de forma predeterminada._\n\nAqu√≠ hay algunas otras formas de declarar variables que aceptan valores NULL:\n\n![](https://cdn-images-1.medium.com/max/800/1*i96n-zRcMQVGxh4GF2MPuA.png)\n\nLas variables que aceptan valores NULL son una buena forma de expresar la **ausencia** de un valor y esto es √∫til en muchas API.\n\nCuando dise√±e una API, preg√∫ntese si una variable debe ser null o no, y declare en consecuencia.\n\nPero hay casos en los que sabemos que algo no puede ser `null`, pero no podemos **demostr√°rselo** al compilador. En estos casos, el operador de aserci√≥n puede ayudar.\n\n### El operador de¬†aserci√≥n\n\nPodemos usar el operador de aserci√≥n¬†`**!**`para asignar una expresi√≥n null a una variable no anulable:\n\n![](https://cdn-images-1.medium.com/max/800/1*9l6QKqsMDl8km59Nkn8_4w.png)\n\nAl hacer esto, le estamos **diciendo a** Dart que `maybeValue`no es `null`, y es seguro asignarlo a una variable que no acepta valores NULL.\n\nTenga en cuenta que la aplicaci√≥n del operador de aserci√≥n a un `null`valor arrojar√° una excepci√≥n de tiempo de ejecuci√≥n:\n\n![](https://cdn-images-1.medium.com/max/800/1*Adc7XC3Ta5q8mXMKwmxSIA.png)\n\n_Cuando sus suposiciones son incorrectas, el_ `_!_`_operador genera excepciones en tiempo de ejecuci√≥n_\n\n* * *\n\nA veces necesitamos trabajar con APIs que devuelven valores que aceptan valores NULL. Revisemos la funci√≥n`lastName`:\n\n![](https://cdn-images-1.medium.com/max/800/1*73mRztMJkydiAR8rpfn90Q.png)\n\nAqu√≠ el sistema de tipos no puede ayudar. Si nosotros **sabemos** que la funci√≥n **va a** devolver un valor que no es`null` para un argumento dado, hay que asignarlo a una variable no anulable **tan pronto como sea posible**¬†.\n\nEsto se hace con el operador`!`:\n\n![](https://cdn-images-1.medium.com/max/800/1*WAWz6l_5fj2sE4MiF_IJQQ.png)\n\nEn resumen:\n\n*   Intente crear variables que no admitan valores NULL cuando sea posible, ya que se **garantizar√°** que no lo est√©n `null`en el **momento de la compilaci√≥n**¬†.\n*   Si sabe que una expresi√≥n anulable no ser√° `null`, puede asignarla a una variable no anulable con el¬†`!`operador.\n\n### An√°lisis de flujo: promoci√≥n\n\nDart puede facilitarle la vida al tener en cuenta las comprobaciones `null` de las variables que aceptan valores NULL:\n\n![](https://cdn-images-1.medium.com/max/800/1*AoVFL0HJLEYeyZbmCm8dqw.png)\n\nAqu√≠ usamos una declaraci√≥n`if` para regresar antes si el argumento`value` es `null`.\n\nM√°s all√° de ese punto, `value`no puede ser`null`y se trata (o **promociona** ) a un valor que no acepta valores NULL. Por lo tanto, podemos usar con seguridad en `value.abs()`lugar de `value?.abs()`(con el operador consciente de nulos).\n\nDe manera similar, podr√≠amos lanzar una excepci√≥n si el valor es `null`:\n\n![](https://cdn-images-1.medium.com/max/800/1*1z9RmH3fm_pN0o1nO1QZFg.png)\n\nUna vez m√°s, `value`se promueve a un valor que no acepta valores NULL y¬†`?.`no se necesita el operador de reconocimiento de nulos¬†.\n\nEn resumen:\n\n*   Utilice verificaciones nulas **por adelantado** para devolver antes o lanzar excepciones\n*   Despu√©s de las comprobaciones nulas, las variables que aceptan valores NULL se **promueven** para que no admitan valores NULL.\n\nY despu√©s de que una variable anulable se haya verificado como nula, Dart te permite usarla como una variable no anulable, lo cual es bastante bueno.\n\n### An√°lisis de flujo: asignaci√≥n definitiva\n\nDart sabe d√≥nde se **asignan las** variables y d√≥nde se **leen**¬†.\n\nEste ejemplo muestra c√≥mo inicializar una variable que no acepta valores NULL **despu√©s de** verificar una condici√≥n:\n\n![](https://cdn-images-1.medium.com/max/800/1*eK8BTupeVnw8C5KZcl__vQ.png)\n\nSiempre que se le d√© un valor a una variable que no acepta valores NULL **antes** de usarla, Dart no reclamara.\n\n### Usar variables que no aceptan valores NULL con¬†clases\n\nLas variables de instancia en las clases deben inicializarse si no aceptan valores NULL:\n\n![](https://cdn-images-1.medium.com/max/800/1*Y59vP-rqo2_MHe2-PjEN5w.png)\n\nSi una variable de instancia que no acepta valores NULL no se puede inicializar con un valor predeterminado, config√∫relo con un constructor:\n\n![](https://cdn-images-1.medium.com/max/800/1*QdlJQ5GrcqxW1zq3dzI1lA.png)\n\nArgumentos posicionales y con nombre que no aceptan valores NULL\n\nCon Null Safety, los argumentos con **nombre que** no aceptan **valores** NULL siempre deben ser **obligatorios** o tener un **valor predeterminado**¬†.\n\nEsto se aplica tanto a los m√©todos regulares como a los constructores de clases:\n\n![](https://cdn-images-1.medium.com/max/800/1*CIHCJ3fXaY4KTcawF9FSXA.png)\n\nPodemos arreglar el c√≥digo anterior con el nuevo `required` **modificador**¬†, que reemplaza la `@required` **anotaci√≥n anterior**¬†:\n\n![](https://cdn-images-1.medium.com/max/800/1*IW1Mi7g_kFC4QRK9kLSg9Q.png)\n\nY cuando usamos las API anteriores, Dart puede decirnos si estamos haciendo algo mal:\n\n![](https://cdn-images-1.medium.com/max/800/1*ZFA2149BBJNmRN2K6MQ3iQ.png)\n\n![](https://cdn-images-1.medium.com/max/800/1*N1na7CkT0r8q0LTUT_kqmw.png)\n\nLos par√°metros **posicionales** est√°n sujetos a las mismas reglas:\n\n![](https://cdn-images-1.medium.com/max/800/1*cQeQ7JMxZVwtmnDI2hF-Dg.png)\n\n_Entre variables null y no null, argumentos con nombre y posicionales, valores obligatorios y predeterminados, hay mucho que asimilar. Si est√° confundido, recuerde la regla de oro:_\n\n* * *\n\n> _Las variables que no aceptan valores NULL siempre deben inicializarse con valores que no sean nulos._\n\n_Para comprender completamente todas las funciones de seguridad nula, practique su uso con_ [_Dartpad_](https://dartpad.dev/?null_safety=true)_. Dart le dir√° si est√° haciendo algo mal, as√≠ que lea los mensajes de error con atenci√≥n._ üîç\n\n### Operador de cascada con reconocimiento nulo\n\nPara hacer frente a Null Safety, el operador en cascada ahora adquiere una nuevos valores `null¬†?..`. Ejemplo:\n\n![](https://cdn-images-1.medium.com/max/800/1*3a_ni6coMxemLuSgzkclLg.png)\n\nLas operaciones en cascada anteriores solo se ejecutar√°n si `path`no es as√≠ `null`.\n\nEl operador de cascada con detecci√≥n de nulos puede **provocar un cortocircuito**¬†, por lo que solo¬†`?..`se necesita un operador al comienzo de la secuencia.\n\n### Operador de sub√≠ndice nulo\n\nHasta ahora, verificar si una colecci√≥n era `null`antes de usar el operador de sub√≠ndice era detallado:\n\n![](https://cdn-images-1.medium.com/max/800/1*lsntZAufevn7E-AQLoPB0w.png)\n\nDart 2.9 presenta al `null`operador¬†`?[]`, lo que hace que esto sea mucho m√°s f√°cil:\n\n![](https://cdn-images-1.medium.com/max/800/1*PUDgdjxpeFhPSPnD8PUNeg.png)\n\n### La palabra clave¬†late\n\nUtilice la palabra `late` clave para inicializar una variable cuando se **lee por primera vez**¬†, en lugar de cuando se **crea**¬†.\n\nUn buen ejemplo es al inicializar variables en `initState()`:\n\n![](https://cdn-images-1.medium.com/max/800/1*NOFIr5bh7smBQRDTfyBIYg.png)\n\nA√∫n mejor, `initState()`se puede eliminar por completo:\n\n![](https://cdn-images-1.medium.com/max/800/1*mPQSU8bJ4eLT3qmz11rFMQ.png)\n\nEs com√∫n usar `late`en combinaci√≥n con `final`, para **diferir** la creaci√≥n de variables de **solo lectura** hasta el momento en que se leen por primera vez.\n\nEsto es ideal cuando se crean variables cuyo inicializador hace un trabajo pesado:\n\n![](https://cdn-images-1.medium.com/max/800/1*82jm8t12bJ1Frm_IkQqC1g.png)\n\nCuando se usa dentro de un cuerpo de funci√≥n, `late`y `final`se puede usar as√≠:\n\n![](https://cdn-images-1.medium.com/max/800/1*-hUI5LOLN7KHQRVcPIRJVQ.png)\n\nAunque no recomiendo el uso de variables late de esta manera. Porque este estilo puede resultar en errores de ejecuci√≥n no obvios. Ejemplo:\n\n![](https://cdn-images-1.medium.com/max/800/1*6FJZdB8r6n8zNusRFbI9jA.png)\n\nAl declarar una variable`late` que no acepta valores NULL¬†, **prometemos** que no ser√° nula en tiempo de ejecuci√≥n, y Dart nos ayuda con algunas garant√≠as de tiempo de compilaci√≥n.\n\nPero recomiendo usar solo `late con`moderaci√≥n y siempre inicializar las variables `late` cuando se declaran.\n\n### Variables est√°ticas y¬†globales\n\nTodas las variables globales **ahora deben inicializarse cuando se declaran, a** menos que sean `late`:\n\n![](https://cdn-images-1.medium.com/max/800/1*ODg745f-lNXbRuqr1jEavA.png)\n\nLo mismo se aplica a las variables de clase est√°ticas:\n\n![](https://cdn-images-1.medium.com/max/800/1*gDF7CmUZ77QGVvKWTnoZ0g.png)\n\nPero como dije antes, no recomiendo usar `late de esta`forma, ya que puede provocar errores de tiempo de ejecuci√≥n.\n\n### Conclusi√≥n\n\nNull Safety es un cambio importante para el lenguaje Dart y se ha introducido para ayudarte a escribir un c√≥digo mejor y m√°s seguro.\n\nPero al final del d√≠a, Null Safety es solo una herramienta, y es su trabajo usarla correctamente.\n\nCada vez que declare una variable en Dart, piense si deber√≠a ser null o no. Esto puede parecer un trabajo adicional, pero conducir√° a un mejor c√≥digo y Dart puede ayudarlo en el camino.\n\n[**Donate to devjaime**  \n_Help support devjaime by donating or sharing with your friends._www.paypal.com](https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S \"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\")[](https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S)\n\nBy [Jaime Hern√°ndez](https://medium.com/@devjaime) on [March 21, 2021](https://medium.com/p/44767a116da0).\n\n[Canonical link](https://medium.com/@devjaime/dart-null-safety-una-gu%C3%ADa-para-los-tipos-que-no-aceptan-valores-nulos-44767a116da0)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"dart-null-safety-una-gu√≠a-para-los-tipos-que-no-aceptan-valores-nulos","text":"Dart Null Safety: una gu√≠a para los tipos que no aceptan valores nulos"},{"depth":3,"slug":"dart-null-safety-una-gu√≠a-para-los-tipos-que-no-aceptan-valoresnulos","text":"Dart Null Safety: una gu√≠a para los tipos que no aceptan valores¬†nulos"},{"depth":3,"slug":"tabla-de-contenido","text":"Tabla de contenido"},{"depth":3,"slug":"algo-decontexto","text":"Algo de¬†contexto"},{"depth":3,"slug":"sistema-de-tipodart","text":"Sistema de tipo¬†dart"},{"depth":3,"slug":"dart-null-safety-beneficios","text":"Dart Null Safety: Beneficios"},{"depth":3,"slug":"declaraci√≥n-de-variables-que-no-aceptan-valoresnull","text":"Declaraci√≥n de variables que no aceptan valores¬†NULL"},{"depth":3,"slug":"declaraci√≥n-de-variables-que-aceptan-valoresnull","text":"Declaraci√≥n de variables que aceptan valores¬†NULL"},{"depth":3,"slug":"el-operador-deaserci√≥n","text":"El operador de¬†aserci√≥n"},{"depth":3,"slug":"an√°lisis-de-flujo-promoci√≥n","text":"An√°lisis de flujo: promoci√≥n"},{"depth":3,"slug":"an√°lisis-de-flujo-asignaci√≥n-definitiva","text":"An√°lisis de flujo: asignaci√≥n definitiva"},{"depth":3,"slug":"usar-variables-que-no-aceptan-valores-null-conclases","text":"Usar variables que no aceptan valores NULL con¬†clases"},{"depth":3,"slug":"operador-de-cascada-con-reconocimiento-nulo","text":"Operador de cascada con reconocimiento nulo"},{"depth":3,"slug":"operador-de-sub√≠ndice-nulo","text":"Operador de sub√≠ndice nulo"},{"depth":3,"slug":"la-palabra-clavelate","text":"La palabra clave¬†late"},{"depth":3,"slug":"variables-est√°ticas-yglobales","text":"Variables est√°ticas y¬†globales"},{"depth":3,"slug":"conclusi√≥n","text":"Conclusi√≥n"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
