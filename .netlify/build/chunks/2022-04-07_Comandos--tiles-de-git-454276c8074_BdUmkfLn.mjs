/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"comandos-útiles-de-git\">Comandos útiles de git</h1>\n<p>Fusión — Merge</p>\n<hr>\n<h3 id=\"comandos-útiles-degit\">Comandos útiles de git</h3>\n<h3 id=\"fusiónmerge\">Fusión — Merge</h3>\n<p>Tener múltiples ramas (branches) es extremadamente conveniente para mantener los cambios nuevos separados entre sí y para asegurarse de que no envíes accidentalmente cambios no aprobados o incompletos a producción. Una vez que se hayan aprobado los cambios, ¡queremos recibir estos cambios en nuestra rama de producción!</p>\n<p>Una forma de obtener los cambios de una rama generalmente se realiza un<code>git merge</code>! Hay dos tipos de fusiones que Git puede realizar: un <strong>avance rápido</strong> o un <strong>avance sin avance rápido.</strong></p>\n<p>Es posible que esto no tenga mucho sentido en este momento, ¡así que veamos las diferencias!</p>\n<h3 id=\"avance-rápido----ff-fast-forward\">Avance rápido ( <code>--ff</code>) Fast-forward</h3>\n<p>Una <strong>fusión de avance rápido</strong> puede ocurrir cuando la rama actual no tiene confirmaciones adicionales en comparación con la rama que estamos fusionando.</p>\n<p>Git es… <em>perezoso</em> y primero intentará realizar la opción más fácil: ¡el avance rápido! Este tipo de fusión no crea una nueva confirmación, sino que fusiona las confirmaciones en la rama que estamos fusionando directamente en la rama actual</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*5mQ6R7QEMu3dSMnS.gif\" alt=\"\"></p>\n<p>¡Perfecto! Ahora tenemos todos los cambios que se hicieron en la rama disponibles en la rama master. Entonces, ¿de qué se trata el <strong>avance rápido</strong> ?</p>\n<h3 id=\"sin-avance-rápido----no-ff-no-fast-foward\">Sin avance rápido ( <code>--no-ff</code>) No-fast-foward</h3>\n<p>Es genial si tu rama actual no tiene confirmaciones adicionales en comparación con la rama que desea fusionar, ¡pero desafortunadamente ese rara vez es el caso! y no podrás hacer Fast-forward o avance rápido.</p>\n<p>Si realizamos cambios en la rama actual y la rama que deseamos fusionar no los tienes, git realizará una fusión <em>sin avance rápido</em> .</p>\n<p>Con una fusión sin avance rápido, Git crea una nueva <em>confirmación de fusión</em> en la rama activa. ¡Las confirmaciones principales de la confirmación apuntan tanto a la rama activa como a la rama que queremos fusionar!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*OOQzhyFY4Qpcosxl.gif\" alt=\"\"></p>\n<p>No es gran cosa, ¡una combinación perfecta! La rama<code>master</code>ahora contiene todos los cambios que hemos hecho en la rama<code>dev</code>.</p>\n<h3 id=\"fusionar-conflictos\">Fusionar conflictos</h3>\n<p>Aunque Git es bueno para decidir cómo fusionar ramas y agregar cambios a los archivos, no siempre puede tomar esta decisión por sí mismo 🙂 Esto puede suceder cuando las dos ramas que intentamos fusionar tienen cambios en la misma línea en el mismo archivo, o si una rama eliminó un archivo que otra rama modificó, y así sucesivamente.</p>\n<p>En ese caso, Git te pedirá que ayudes a decidir cuál de las dos opciones queremos conservar. Digamos que en ambas ramas, editamos la primera línea en el archivo <code>README.md</code>.</p>\n<p>Si queremos fusionarnos la rama<code>dev</code>con la rama<code>master</code>, esto terminará en un conflicto de fusión: y preguntara ¿le gustaría que se conservara la linea de la rama dev o la rama master?</p>\n<p>Cuando intente fusionar las ramas, Git le mostrará dónde ocurre el conflicto. Podemos eliminar manualmente los cambios que no queremos conservar, guardar los cambios, agregar el archivo modificado nuevamente y confirmar los cambios.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*-_YzzD3RmyC9_D8P.gif\" alt=\"\"></p>\n<p>Aunque los conflictos de fusión suelen ser bastante molestos, tiene mucho sentido: Git no debería simplemente <em>asumir</em> qué cambio queremos conservar.</p>\n<h3 id=\"rebase\">rebase</h3>\n<p>Acabamos de ver cómo podíamos aplicar cambios de una rama a otra realizando un <code>git merge</code>. Otra forma de agregar cambios de una rama a otra es realizando un <code>git rebase</code>.</p>\n<p>A <code>git rebase</code> <em>copia</em> las confirmaciones de la rama actual y coloca estas confirmaciones copiadas encima de la rama especificada.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*YcYoCIP1OJdx585y.gif\" alt=\"\"></p>\n<p>Perfecto, ya tenemos todos los cambios que se hicieron en la rama<code>master</code> disponibles en la rama<code>dev</code>!</p>\n<p>Una gran diferencia en comparación con la “merge” es que Git no intentará averiguar qué archivos conservar y no conservar. ¡La rama que estamos reorganizando siempre tiene los últimos cambios que queremos conservar! No te encontrarás con ningún conflicto de fusión de esta manera, y mantiene un buen historial lineal de Git.</p>\n<p>Este ejemplo muestra el cambio de base en la rama<code>master</code>. Sin embargo, en proyectos más grandes, por lo general no desea hacer eso. ¡ A <code>git rebase</code> <strong>cambia el historial del proyecto</strong> a medida que se crean nuevos hashes para las confirmaciones copiadas!</p>\n<p>El cambio de base es excelente siempre que esté trabajando en una rama de características y la rama principal se haya actualizado. ¡Puede obtener todas las actualizaciones en su rama, lo que evitaría futuros conflictos de fusión!</p>\n<h3 id=\"rebase-interactivo\">Rebase interactivo</h3>\n<p>¡Antes de reorganizar los commits, podemos modificarlos! 😃 Podemos hacerlo con un <em>rebase interactivo</em> . Una reorganización interactiva también puede ser útil en la rama en la que está trabajando actualmente y desea modificar algunas confirmaciones.</p>\n<p>Hay 6 acciones que podemos realizar en las confirmaciones que estamos reorganizando:</p>\n<ul>\n<li><code>reword</code>: Cambiar el mensaje de confirmación</li>\n<li><code>edit</code>: Modificar este compromiso</li>\n<li><code>squash</code>: fusionar la confirmación con la confirmación anterior</li>\n<li><code>fixup</code>: fusionar la confirmación con la confirmación anterior, sin conservar el mensaje de registro de la confirmación</li>\n<li><code>exec</code>: Ejecutar un comando en cada confirmación que queremos reorganizar</li>\n<li><code>drop</code>: Eliminar la confirmación</li>\n</ul>\n<p>¡Increíble! De esta manera, podemos tener control total sobre nuestras confirmaciones. Si queremos eliminar un compromiso, podemos simplemente hacerlo con el comando drop.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*Ihm5TYCT9wYLhjjV.gif\" alt=\"\"></p>\n<p>O si queremos juntar varias confirmaciones para obtener un historial más limpio, ¡no hay problema!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*5ylV4OfCIQ_Lobev.gif\" alt=\"\"></p>\n<h3 id=\"resettingrestablecer\">Resetting — Restablecer</h3>\n<p>Puede suceder que cometamos cambios que no queríamos más adelante. ¡ Tal vez sea un compromiso<code>WIP</code>, o tal vez un compromiso que introdujo errores! 🐛 En ese caso, podemos realizar un <code>git reset</code>.</p>\n<p>A <code>git reset</code>se deshace de todos los archivos provisionales actuales y nos da control sobre dónde <code>HEAD</code>debería apuntar.</p>\n<h3 id=\"soft-resetreiniciosuave\">Soft reset — Reinicio suave</h3>\n<p>¡ Un <em>restablecimiento parcial</em> se mueve <code>HEAD</code>a la confirmación especificada (o el índice de la confirmación en comparación con <code>HEAD</code>), sin deshacerse de los cambios que se introdujeron en las confirmaciones después!</p>\n<p>Digamos que no queremos conservar la confirmación <code>9e78i</code>que agregó un archivo <code>style.css</code>, y tampoco queremos conservar la confirmación <code>035cc</code>que agregó un archivo<code>index.js</code>.</p>\n<p>El archivo<code>style.css</code>Sin embargo, ¡ queremos mantener el <code>index.js</code> recién agregado! Un caso de uso perfecto para un restablecimiento parcial.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*aUw-pT5frZU8cACI.gif\" alt=\"\"></p>\n<p>Al escribir <code>git status</code>, verás que aún tenemos acceso a todos los cambios que se realizaron en las confirmaciones anteriores. ¡Esto es genial, ya que significa que podemos corregir el contenido de estos archivos y enviarlos nuevamente más adelante!</p>\n<h3 id=\"hard-resetrestablecimiento-completo\">Hard reset — Restablecimiento completo</h3>\n<p>A veces, no queremos conservar los cambios introducidos por ciertas confirmaciones. A diferencia de un restablecimiento parcial, ya no deberíamos necesitar tener acceso a ellos. Git simplemente debería restablecer su estado a donde estaba en la confirmación especificada: ¡esto incluso incluye los cambios en su directorio de trabajo y archivos preparados!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*i5obHkYWz8YroHGv.gif\" alt=\"\"></p>\n<p>Git ha descartado los cambios que se introdujeron en <code>9e78i</code>y <code>035cc</code>y ha restablecido su estado a donde estaba en el commit<code>ec5be</code>.</p>\n<hr>\n<h3 id=\"revertrevirtiendo\">revert — revirtiendo</h3>\n<p>Otra forma de deshacer los cambios es realizando un <code>git revert</code>. ¡Al revertir una determinada confirmación, creamos una <em>nueva confirmación</em> que contiene los cambios revertidos!</p>\n<p>Digamos que <code>ec5be</code>agregó un archivo<code>index.js</code>. ¡Más tarde, nos damos cuenta de que ya no queríamos que este cambio se introdujera por este compromiso! Vamos a revertir el commit<code>ec5be</code>.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*8sSA3q5f9un3TFrw.gif\" alt=\"\"></p>\n<p>¡Perfecto! La confirmación <code>9e78i</code>revirtió los cambios introducidos por el commit<code>ec5be</code>. Realizar un <code>git revert</code>es muy útil para deshacer un determinado compromiso, sin modificar el historial de la rama.</p>\n<h3 id=\"cherry-picking\">Cherry-picking</h3>\n<p>Cuando una determinada rama contiene un commit que introdujo los cambios que necesitamos en nuestra rama activa, ¡podemos ejecutar <code>cherry-pick</code>! .</p>\n<p><code>cherry-pick al</code>enviar una confirmación, creamos una nueva confirmación en nuestra rama activa que contiene los cambios que introdujo el commit<code>cherry-pick</code>.</p>\n<p>Digamos que el commit<code>76d12</code>en la rama<code>dev</code> agregó un cambio al archivo<code>index.js</code> que queremos en nuestra rama<code>master</code>. ¡No queremos <em>todo</em> , solo nos importa este único commit!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*h9Dzw1Ore-z4OYpU.gif\" alt=\"\"></p>\n<p>¡ Genial, la rama maestra ahora contiene los cambios que se introdujeron en el commit<code>76d12</code>!</p>\n<h3 id=\"fetching\">Fetching</h3>\n<p>Si tenemos una rama remota de Git, por ejemplo, una rama en Github, ¡puede suceder que la rama remota tenga commit que la rama actual no tiene! Tal vez se fusionó otra rama, tu compañero impulsó una solución rápida, y así sucesivamente.</p>\n<p>¡Podemos obtener estos cambios localmente, realizando un <code>git fetch</code>en la rama remota! No afecta a tu rama local de ninguna manera: <code>fetch</code>simplemente descarga nuevos datos.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*p45hIZ9Vf94hww0j.gif\" alt=\"\"></p>\n<p>¡Ahora podemos ver todos los cambios que se han realizado desde la última vez que presionamos! Podemos decidir qué queremos hacer con los nuevos datos ahora que los tenemos localmente.</p>\n<h3 id=\"pulling\">Pulling</h3>\n<p>Aunque un <code>git fetch</code>es muy útil para obtener la información remota de una rama, también podemos realizar un <code>git pull</code>.</p>\n<p><code>git pull</code>es en realidad dos comandos en uno: a <code>git fetch</code>y a <code>git merge</code>. Cuando extraemos cambios desde el origen, primero obtenemos todos los datos como lo hicimos con un <code>git fetch</code>, después de lo cual los cambios más recientes se fusionan automáticamente en la rama local.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*U8WnlxnOHUaEO_H0.gif\" alt=\"\"></p>\n<p>Impresionante, ahora estamos perfectamente sincronizados con la rama remota y tenemos todos los cambios más recientes.</p>\n<hr>\n<h3 id=\"reflog\">Reflog</h3>\n<p>Todo el mundo comete errores, ¡y eso está totalmente bien! A veces puede parecer que has estropeado tanto tu repositorio de git que solo quieres eliminarlo por completo.</p>\n<p><code>git reflog</code>es un comando muy útil para mostrar un registro de todas las acciones que se han realizado. Esto incluye fusiones, reinicios, reversiones: básicamente cualquier alteración en su rama.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*wEQ4XLAoLWJ203Ya.gif\" alt=\"\"></p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/454276c8074\">April 7, 2022</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/comandos-%C3%BAtiles-de-git-454276c8074\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Comandos útiles de git","description":"","tags":["code","git"],"time":4,"featured":true,"timestamp":"2022-04-07T12:20:31-0300","filename":"2022-04-07_Comandos--tiles-de-git-454276c8074"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2022-04-07_Comandos--tiles-de-git-454276c8074.md";
				const url = "/blog/2022-04-07_Comandos--tiles-de-git-454276c8074";
				function rawContent() {
					return "   \n                                        \n                               \n               \n                     \n       \n              \n                                     \n                                                         \n   \n\n\nComandos útiles de git\n======================\n\nFusión — Merge\n\n* * *\n\n### Comandos útiles de git\n\n### Fusión — Merge\n\nTener múltiples ramas (branches) es extremadamente conveniente para mantener los cambios nuevos separados entre sí y para asegurarse de que no envíes accidentalmente cambios no aprobados o incompletos a producción. Una vez que se hayan aprobado los cambios, ¡queremos recibir estos cambios en nuestra rama de producción!\n\nUna forma de obtener los cambios de una rama generalmente se realiza un`git merge`! Hay dos tipos de fusiones que Git puede realizar: un **avance rápido** o un **avance sin avance rápido.**\n\nEs posible que esto no tenga mucho sentido en este momento, ¡así que veamos las diferencias!\n\n### Avance rápido ( `--ff`) Fast-forward\n\nUna **fusión de avance rápido** puede ocurrir cuando la rama actual no tiene confirmaciones adicionales en comparación con la rama que estamos fusionando.\n\nGit es… _perezoso_ y primero intentará realizar la opción más fácil: ¡el avance rápido! Este tipo de fusión no crea una nueva confirmación, sino que fusiona las confirmaciones en la rama que estamos fusionando directamente en la rama actual\n\n![](https://cdn-images-1.medium.com/max/800/0*5mQ6R7QEMu3dSMnS.gif)\n\n¡Perfecto! Ahora tenemos todos los cambios que se hicieron en la rama disponibles en la rama master. Entonces, ¿de qué se trata el **avance rápido** ?\n\n### Sin avance rápido ( `--no-ff`) No-fast-foward\n\nEs genial si tu rama actual no tiene confirmaciones adicionales en comparación con la rama que desea fusionar, ¡pero desafortunadamente ese rara vez es el caso! y no podrás hacer Fast-forward o avance rápido.\n\nSi realizamos cambios en la rama actual y la rama que deseamos fusionar no los tienes, git realizará una fusión _sin avance rápido_ .\n\nCon una fusión sin avance rápido, Git crea una nueva _confirmación de fusión_ en la rama activa. ¡Las confirmaciones principales de la confirmación apuntan tanto a la rama activa como a la rama que queremos fusionar!\n\n![](https://cdn-images-1.medium.com/max/800/0*OOQzhyFY4Qpcosxl.gif)\n\nNo es gran cosa, ¡una combinación perfecta! La rama`master`ahora contiene todos los cambios que hemos hecho en la rama`dev`.\n\n### Fusionar conflictos\n\nAunque Git es bueno para decidir cómo fusionar ramas y agregar cambios a los archivos, no siempre puede tomar esta decisión por sí mismo 🙂 Esto puede suceder cuando las dos ramas que intentamos fusionar tienen cambios en la misma línea en el mismo archivo, o si una rama eliminó un archivo que otra rama modificó, y así sucesivamente.\n\nEn ese caso, Git te pedirá que ayudes a decidir cuál de las dos opciones queremos conservar. Digamos que en ambas ramas, editamos la primera línea en el archivo `README.md`.\n\nSi queremos fusionarnos la rama`dev`con la rama`master`, esto terminará en un conflicto de fusión: y preguntara ¿le gustaría que se conservara la linea de la rama dev o la rama master?\n\nCuando intente fusionar las ramas, Git le mostrará dónde ocurre el conflicto. Podemos eliminar manualmente los cambios que no queremos conservar, guardar los cambios, agregar el archivo modificado nuevamente y confirmar los cambios.\n\n![](https://cdn-images-1.medium.com/max/800/0*-_YzzD3RmyC9_D8P.gif)\n\nAunque los conflictos de fusión suelen ser bastante molestos, tiene mucho sentido: Git no debería simplemente _asumir_ qué cambio queremos conservar.\n\n### rebase\n\nAcabamos de ver cómo podíamos aplicar cambios de una rama a otra realizando un `git merge`. Otra forma de agregar cambios de una rama a otra es realizando un `git rebase`.\n\nA `git rebase` _copia_ las confirmaciones de la rama actual y coloca estas confirmaciones copiadas encima de la rama especificada.\n\n![](https://cdn-images-1.medium.com/max/800/0*YcYoCIP1OJdx585y.gif)\n\nPerfecto, ya tenemos todos los cambios que se hicieron en la rama`master` disponibles en la rama`dev`!\n\nUna gran diferencia en comparación con la “merge” es que Git no intentará averiguar qué archivos conservar y no conservar. ¡La rama que estamos reorganizando siempre tiene los últimos cambios que queremos conservar! No te encontrarás con ningún conflicto de fusión de esta manera, y mantiene un buen historial lineal de Git.\n\nEste ejemplo muestra el cambio de base en la rama`master`. Sin embargo, en proyectos más grandes, por lo general no desea hacer eso. ¡ A `git rebase` **cambia el historial del proyecto** a medida que se crean nuevos hashes para las confirmaciones copiadas!\n\nEl cambio de base es excelente siempre que esté trabajando en una rama de características y la rama principal se haya actualizado. ¡Puede obtener todas las actualizaciones en su rama, lo que evitaría futuros conflictos de fusión!\n\n### Rebase interactivo\n\n¡Antes de reorganizar los commits, podemos modificarlos! 😃 Podemos hacerlo con un _rebase interactivo_ . Una reorganización interactiva también puede ser útil en la rama en la que está trabajando actualmente y desea modificar algunas confirmaciones.\n\nHay 6 acciones que podemos realizar en las confirmaciones que estamos reorganizando:\n\n*   `reword`: Cambiar el mensaje de confirmación\n*   `edit`: Modificar este compromiso\n*   `squash`: fusionar la confirmación con la confirmación anterior\n*   `fixup`: fusionar la confirmación con la confirmación anterior, sin conservar el mensaje de registro de la confirmación\n*   `exec`: Ejecutar un comando en cada confirmación que queremos reorganizar\n*   `drop`: Eliminar la confirmación\n\n¡Increíble! De esta manera, podemos tener control total sobre nuestras confirmaciones. Si queremos eliminar un compromiso, podemos simplemente hacerlo con el comando drop.\n\n![](https://cdn-images-1.medium.com/max/800/0*Ihm5TYCT9wYLhjjV.gif)\n\nO si queremos juntar varias confirmaciones para obtener un historial más limpio, ¡no hay problema!\n\n![](https://cdn-images-1.medium.com/max/800/0*5ylV4OfCIQ_Lobev.gif)\n\n### Resetting — Restablecer\n\nPuede suceder que cometamos cambios que no queríamos más adelante. ¡ Tal vez sea un compromiso`WIP`, o tal vez un compromiso que introdujo errores! 🐛 En ese caso, podemos realizar un `git reset`.\n\nA `git reset`se deshace de todos los archivos provisionales actuales y nos da control sobre dónde `HEAD`debería apuntar.\n\n### Soft reset — Reinicio suave\n\n¡ Un _restablecimiento parcial_ se mueve `HEAD`a la confirmación especificada (o el índice de la confirmación en comparación con `HEAD`), sin deshacerse de los cambios que se introdujeron en las confirmaciones después!\n\nDigamos que no queremos conservar la confirmación `9e78i`que agregó un archivo `style.css`, y tampoco queremos conservar la confirmación `035cc`que agregó un archivo`index.js`.\n\nEl archivo`style.css`Sin embargo, ¡ queremos mantener el `index.js` recién agregado! Un caso de uso perfecto para un restablecimiento parcial.\n\n![](https://cdn-images-1.medium.com/max/800/0*aUw-pT5frZU8cACI.gif)\n\nAl escribir `git status`, verás que aún tenemos acceso a todos los cambios que se realizaron en las confirmaciones anteriores. ¡Esto es genial, ya que significa que podemos corregir el contenido de estos archivos y enviarlos nuevamente más adelante!\n\n### Hard reset — Restablecimiento completo\n\nA veces, no queremos conservar los cambios introducidos por ciertas confirmaciones. A diferencia de un restablecimiento parcial, ya no deberíamos necesitar tener acceso a ellos. Git simplemente debería restablecer su estado a donde estaba en la confirmación especificada: ¡esto incluso incluye los cambios en su directorio de trabajo y archivos preparados!\n\n![](https://cdn-images-1.medium.com/max/800/0*i5obHkYWz8YroHGv.gif)\n\nGit ha descartado los cambios que se introdujeron en `9e78i`y `035cc`y ha restablecido su estado a donde estaba en el commit`ec5be`.\n\n* * *\n\n### revert — revirtiendo\n\nOtra forma de deshacer los cambios es realizando un `git revert`. ¡Al revertir una determinada confirmación, creamos una _nueva confirmación_ que contiene los cambios revertidos!\n\nDigamos que `ec5be`agregó un archivo`index.js`. ¡Más tarde, nos damos cuenta de que ya no queríamos que este cambio se introdujera por este compromiso! Vamos a revertir el commit`ec5be`.\n\n![](https://cdn-images-1.medium.com/max/800/0*8sSA3q5f9un3TFrw.gif)\n\n¡Perfecto! La confirmación `9e78i`revirtió los cambios introducidos por el commit`ec5be`. Realizar un `git revert`es muy útil para deshacer un determinado compromiso, sin modificar el historial de la rama.\n\n### Cherry-picking\n\nCuando una determinada rama contiene un commit que introdujo los cambios que necesitamos en nuestra rama activa, ¡podemos ejecutar `cherry-pick`! .\n\n`cherry-pick al`enviar una confirmación, creamos una nueva confirmación en nuestra rama activa que contiene los cambios que introdujo el commit`cherry-pick`.\n\nDigamos que el commit`76d12`en la rama`dev` agregó un cambio al archivo`index.js` que queremos en nuestra rama`master`. ¡No queremos _todo_ , solo nos importa este único commit!\n\n![](https://cdn-images-1.medium.com/max/800/0*h9Dzw1Ore-z4OYpU.gif)\n\n¡ Genial, la rama maestra ahora contiene los cambios que se introdujeron en el commit`76d12`!\n\n### Fetching\n\nSi tenemos una rama remota de Git, por ejemplo, una rama en Github, ¡puede suceder que la rama remota tenga commit que la rama actual no tiene! Tal vez se fusionó otra rama, tu compañero impulsó una solución rápida, y así sucesivamente.\n\n¡Podemos obtener estos cambios localmente, realizando un `git fetch`en la rama remota! No afecta a tu rama local de ninguna manera: `fetch`simplemente descarga nuevos datos.\n\n![](https://cdn-images-1.medium.com/max/800/0*p45hIZ9Vf94hww0j.gif)\n\n¡Ahora podemos ver todos los cambios que se han realizado desde la última vez que presionamos! Podemos decidir qué queremos hacer con los nuevos datos ahora que los tenemos localmente.\n\n### Pulling\n\nAunque un `git fetch`es muy útil para obtener la información remota de una rama, también podemos realizar un `git pull`.\n\n`git pull`es en realidad dos comandos en uno: a `git fetch`y a `git merge`. Cuando extraemos cambios desde el origen, primero obtenemos todos los datos como lo hicimos con un `git fetch`, después de lo cual los cambios más recientes se fusionan automáticamente en la rama local.\n\n![](https://cdn-images-1.medium.com/max/800/0*U8WnlxnOHUaEO_H0.gif)\n\nImpresionante, ahora estamos perfectamente sincronizados con la rama remota y tenemos todos los cambios más recientes.\n\n* * *\n\n### Reflog\n\nTodo el mundo comete errores, ¡y eso está totalmente bien! A veces puede parecer que has estropeado tanto tu repositorio de git que solo quieres eliminarlo por completo.\n\n`git reflog`es un comando muy útil para mostrar un registro de todas las acciones que se han realizado. Esto incluye fusiones, reinicios, reversiones: básicamente cualquier alteración en su rama.\n\n![](https://cdn-images-1.medium.com/max/800/0*wEQ4XLAoLWJ203Ya.gif)\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [April 7, 2022](https://medium.com/p/454276c8074).\n\n[Canonical link](https://medium.com/@devjaime/comandos-%C3%BAtiles-de-git-454276c8074)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"comandos-útiles-de-git","text":"Comandos útiles de git"},{"depth":3,"slug":"comandos-útiles-degit","text":"Comandos útiles de git"},{"depth":3,"slug":"fusiónmerge","text":"Fusión — Merge"},{"depth":3,"slug":"avance-rápido----ff-fast-forward","text":"Avance rápido ( --ff) Fast-forward"},{"depth":3,"slug":"sin-avance-rápido----no-ff-no-fast-foward","text":"Sin avance rápido ( --no-ff) No-fast-foward"},{"depth":3,"slug":"fusionar-conflictos","text":"Fusionar conflictos"},{"depth":3,"slug":"rebase","text":"rebase"},{"depth":3,"slug":"rebase-interactivo","text":"Rebase interactivo"},{"depth":3,"slug":"resettingrestablecer","text":"Resetting — Restablecer"},{"depth":3,"slug":"soft-resetreiniciosuave","text":"Soft reset — Reinicio suave"},{"depth":3,"slug":"hard-resetrestablecimiento-completo","text":"Hard reset — Restablecimiento completo"},{"depth":3,"slug":"revertrevirtiendo","text":"revert — revirtiendo"},{"depth":3,"slug":"cherry-picking","text":"Cherry-picking"},{"depth":3,"slug":"fetching","text":"Fetching"},{"depth":3,"slug":"pulling","text":"Pulling"},{"depth":3,"slug":"reflog","text":"Reflog"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
