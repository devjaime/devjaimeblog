/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"haystack-construyendo-aplicaciones-de-ia-con-componentes-modulares\">Haystack: Construyendo Aplicaciones de IA con Componentes Modulares</h1>\n<p>Haystack es un marco de trabajo de código abierto para construir aplicaciones de inteligencia artificial (IA) en Python. Este marco permite…</p>\n<hr>\n<h3 id=\"haystack-construyendo-aplicaciones-de-ia-con-componentes-modulares-1\">Haystack: Construyendo Aplicaciones de IA con Componentes Modulares</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*2QbWYDFq9mxX_5dRS2YpTg.png\" alt=\"\"></p>\n<p>Haystack es un marco de trabajo de código abierto para construir aplicaciones de inteligencia artificial (IA) en Python. Este marco permite combinar diferentes componentes para crear <em>pipelines</em> que ejecutan tareas específicas en aplicaciones de IA. En este blog, exploraremos cómo utilizar Haystack para crear una aplicación básica de búsqueda de documentos, partiendo desde la inicialización de los componentes hasta la ejecución de la <em>pipeline</em>.</p>\n<h3 id=\"componentes-la-base-detodo\">Componentes: La Base de Todo</h3>\n<p>Los componentes son las unidades fundamentales en Haystack. Cada componente realiza una tarea específica, como procesar texto, generar incrustaciones (<em>embeddings</em>) o escribir documentos en un almacén. A continuación, se muestra un ejemplo de cómo inicializar un componente de incrustación de documentos utilizando el modelo <code>text-embedding-3-small</code> de OpenAI.</p>\n<p>pythonfrom haystack.components.embedders import OpenAIDocumentEmbedder<br>\nembedder = OpenAIDocumentEmbedder(model=“text-embedding-3-small”)</p>\n<p>Este componente tomará documentos como entrada y generará sus respectivas representaciones embebidas.</p>\n<h3 id=\"pipelines-conectando-componentes\">Pipelines: Conectando Componentes</h3>\n<p>Una <em>pipeline</em> en Haystack es simplemente una cadena de componentes conectados entre sí. Estas <em>pipelines</em> permiten realizar tareas complejas al pasar los datos de un componente a otro de manera secuencial.</p>\n<p>Para construir una <em>pipeline</em> de indexación de documentos, primero necesitamos inicializar un almacén de documentos. En este caso, utilizaremos <code>InMemoryDocumentStore</code>, un almacén simple que no requiere configuración adicional.</p>\n<p>from haystack.document_stores.in_memory import InMemoryDocumentStore<br>\ndocument_store = InMemoryDocumentStore()</p>\n<h3 id=\"creando-una-pipeline-de-indexación\">Creando una Pipeline de Indexación</h3>\n<p>Nuestra <em>pipeline</em> de indexación tomará archivos de texto, los convertirá en documentos, los dividirá en fragmentos manejables, generará incrustaciones para cada fragmento y finalmente los almacenará en nuestro almacén de documentos.</p>\n<p>from haystack import Pipeline<br>\nfrom haystack.components.converters.txt import TextFileToDocument<br>\nfrom haystack.components.preprocessors.document_splitter import DocumentSplitter<br>\nfrom haystack.components.writers import DocumentWriter<br>\nconverter = TextFileToDocument()<br>\nsplitter = DocumentSplitter()<br>\nembedder = OpenAIDocumentEmbedder()<br>\nwriter = DocumentWriter(document_store=document_store)<br>\nindexing_pipeline = Pipeline()<br>\nindexing_pipeline.add_component(“converter”, converter)<br>\nindexing_pipeline.add_component(“splitter”, splitter)<br>\nindexing_pipeline.add_component(“embedder”, embedder)<br>\nindexing_pipeline.add_component(“writer”, writer)</p>\n<p>Una vez que los componentes están añadidos, es necesario conectarlos para que los datos fluyan entre ellos:</p>\n<p>indexing_pipeline.connect(“converter”, “splitter”)<br>\nindexing_pipeline.connect(“splitter”, “embedder”)<br>\nindexing_pipeline.connect(“embedder”, “writer”)</p>\n<p>Finalmente, ejecutamos la <em>pipeline</em> para indexar nuestros documentos:</p>\n<p>indexing_pipeline.run({“converter”: {“sources”: [‘data/davinci.txt’]}})</p>\n<h3 id=\"creando-una-pipeline-de-búsqueda-de-documentos\">Creando una Pipeline de Búsqueda de Documentos</h3>\n<p>Una vez que los documentos están indexados, podemos crear una <em>pipeline</em> para buscar información relevante en ellos. Al igual que la <em>pipeline</em> de indexación, necesitamos varios componentes, como un incrustador de consultas y un recuperador de documentos basado en incrustaciones.</p>\n<p>rom haystack.components.embedders import OpenAITextEmbedder<br>\nfrom haystack.components.retrievers.in_memory import InMemoryEmbeddingRetriever<br>\nquery_embedder = OpenAITextEmbedder()<br>\nretriever = InMemoryEmbeddingRetriever(document_store=document_store)<br>\ndocument_search = Pipeline()<br>\ndocument_search.add_component(“query_embedder”, query_embedder)<br>\ndocument_search.add_component(“retriever”, retriever)<br>\ndocument_search.connect(“query_embedder.embedding”, “retriever.query_embedding”)</p>\n<h3 id=\"ejecución-de-labúsqueda\">Ejecución de la Búsqueda</h3>\n<p>Para buscar en los documentos, formulamos una pregunta y ejecutamos la <em>pipeline</em> de búsqueda.</p>\n<p>question = “How old was Davinci when he died?“<br>\nresults = document_search.run({“query_embedder”: {“text”: question}})</p>\n<p>Los resultados devueltos incluirán los documentos que mejor respondan a la pregunta.</p>\n<p>for i, document in enumerate(results[“retriever”][“documents”]):<br>\nprint(f”DOCUMENT {i}“)<br>\nprint(document.content)</p>\n<h3 id=\"exploración-de-nuevas-preguntas-yajustes\">Exploración de Nuevas Preguntas y Ajustes</h3>\n<p>Puedes ajustar los parámetros de búsqueda, como el número de resultados (<code>top_k</code>) o probar con diferentes preguntas.</p>\n<p>question = “Where was Davinci born?“<br>\nresults = document_search.run({“query_embedder”: {“text”: question}, “retriever”: {“top_k”: 3}})</p>\n<p>Esta flexibilidad permite personalizar la <em>pipeline</em> según las necesidades de la aplicación.</p>\n<h3 id=\"conclusión\">Conclusión</h3>\n<p>Haystack ofrece un enfoque modular para construir aplicaciones de IA al permitir la combinación de componentes en <em>pipelines</em>. Este enfoque hace que sea fácil experimentar y escalar las aplicaciones de IA, desde la indexación de documentos hasta la búsqueda avanzada.</p>\n<p>Para los desarrolladores interesados en construir aplicaciones de búsqueda, generación de respuestas o análisis de documentos, Haystack proporciona las herramientas necesarias para combinar componentes y lograr resultados precisos y eficientes.</p>\n<p>Si deseas explorar más sobre Haystack y sus capacidades, visita su documentación oficial. <a href=\"https://docs.haystack.deepset.ai/docs/intro\">https://docs.haystack.deepset.ai/docs/intro</a></p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/02d1ae93a849\">August 28, 2024</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/haystack-construyendo-aplicaciones-de-ia-con-componentes-modulares-02d1ae93a849\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Haystack: Construyendo Aplicaciones de IA con Componentes Modulares ","description":"","tags":["code","HayStack"],"time":4,"featured":true,"timestamp":"2024-08-28T12:20:32-0300","filename":"2024-08-28_Haystack--Construyendo-Aplicaciones-de-IA-con-Componentes-Modulares-02d1ae93a849"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2024-08-28_Haystack--Construyendo-Aplicaciones-de-IA-con-Componentes-Modulares-02d1ae93a849.md";
				const url = "/blog/2024-08-28_Haystack--Construyendo-Aplicaciones-de-IA-con-Componentes-Modulares-02d1ae93a849";
				function rawContent() {
					return "   \n                                        \n                                                                             \n               \n                          \n       \n              \n                                     \n                                                                                                       \n   \n\nHaystack: Construyendo Aplicaciones de IA con Componentes Modulares\n===================================================================\n\nHaystack es un marco de trabajo de código abierto para construir aplicaciones de inteligencia artificial (IA) en Python. Este marco permite…\n\n* * *\n\n### Haystack: Construyendo Aplicaciones de IA con Componentes Modulares\n\n![](https://cdn-images-1.medium.com/max/800/1*2QbWYDFq9mxX_5dRS2YpTg.png)\n\nHaystack es un marco de trabajo de código abierto para construir aplicaciones de inteligencia artificial (IA) en Python. Este marco permite combinar diferentes componentes para crear _pipelines_ que ejecutan tareas específicas en aplicaciones de IA. En este blog, exploraremos cómo utilizar Haystack para crear una aplicación básica de búsqueda de documentos, partiendo desde la inicialización de los componentes hasta la ejecución de la _pipeline_.\n\n### Componentes: La Base de Todo\n\nLos componentes son las unidades fundamentales en Haystack. Cada componente realiza una tarea específica, como procesar texto, generar incrustaciones (_embeddings_) o escribir documentos en un almacén. A continuación, se muestra un ejemplo de cómo inicializar un componente de incrustación de documentos utilizando el modelo `text-embedding-3-small` de OpenAI.\n\npythonfrom haystack.components.embedders import OpenAIDocumentEmbedder  \nembedder = OpenAIDocumentEmbedder(model=\"text-embedding-3-small\")\n\nEste componente tomará documentos como entrada y generará sus respectivas representaciones embebidas.\n\n### Pipelines: Conectando Componentes\n\nUna _pipeline_ en Haystack es simplemente una cadena de componentes conectados entre sí. Estas _pipelines_ permiten realizar tareas complejas al pasar los datos de un componente a otro de manera secuencial.\n\nPara construir una _pipeline_ de indexación de documentos, primero necesitamos inicializar un almacén de documentos. En este caso, utilizaremos `InMemoryDocumentStore`, un almacén simple que no requiere configuración adicional.\n\nfrom haystack.document\\_stores.in\\_memory import InMemoryDocumentStore  \ndocument\\_store = InMemoryDocumentStore()\n\n### Creando una Pipeline de Indexación\n\nNuestra _pipeline_ de indexación tomará archivos de texto, los convertirá en documentos, los dividirá en fragmentos manejables, generará incrustaciones para cada fragmento y finalmente los almacenará en nuestro almacén de documentos.\n\nfrom haystack import Pipeline  \nfrom haystack.components.converters.txt import TextFileToDocument  \nfrom haystack.components.preprocessors.document\\_splitter import DocumentSplitter  \nfrom haystack.components.writers import DocumentWriter  \nconverter = TextFileToDocument()  \nsplitter = DocumentSplitter()  \nembedder = OpenAIDocumentEmbedder()  \nwriter = DocumentWriter(document\\_store=document\\_store)  \nindexing\\_pipeline = Pipeline()  \nindexing\\_pipeline.add\\_component(\"converter\", converter)  \nindexing\\_pipeline.add\\_component(\"splitter\", splitter)  \nindexing\\_pipeline.add\\_component(\"embedder\", embedder)  \nindexing\\_pipeline.add\\_component(\"writer\", writer)\n\nUna vez que los componentes están añadidos, es necesario conectarlos para que los datos fluyan entre ellos:\n\nindexing\\_pipeline.connect(\"converter\", \"splitter\")  \nindexing\\_pipeline.connect(\"splitter\", \"embedder\")  \nindexing\\_pipeline.connect(\"embedder\", \"writer\")\n\nFinalmente, ejecutamos la _pipeline_ para indexar nuestros documentos:\n\nindexing\\_pipeline.run({\"converter\": {\"sources\": \\['data/davinci.txt'\\]}})\n\n### Creando una Pipeline de Búsqueda de Documentos\n\nUna vez que los documentos están indexados, podemos crear una _pipeline_ para buscar información relevante en ellos. Al igual que la _pipeline_ de indexación, necesitamos varios componentes, como un incrustador de consultas y un recuperador de documentos basado en incrustaciones.\n\nrom haystack.components.embedders import OpenAITextEmbedder  \nfrom haystack.components.retrievers.in\\_memory import InMemoryEmbeddingRetriever  \nquery\\_embedder \\= OpenAITextEmbedder()  \nretriever = InMemoryEmbeddingRetriever(document\\_store=document\\_store)  \ndocument\\_search = Pipeline()  \ndocument\\_search.add\\_component(\"query\\_embedder\", query\\_embedder)  \ndocument\\_search.add\\_component(\"retriever\", retriever)  \ndocument\\_search.connect(\"query\\_embedder.embedding\", \"retriever.query\\_embedding\")\n\n### Ejecución de la Búsqueda\n\nPara buscar en los documentos, formulamos una pregunta y ejecutamos la _pipeline_ de búsqueda.\n\nquestion = \"How old was Davinci when he died?\"  \nresults = document\\_search.run({\"query\\_embedder\": {\"text\": question}})\n\nLos resultados devueltos incluirán los documentos que mejor respondan a la pregunta.\n\nfor i, document in enumerate(results\\[\"retriever\"\\]\\[\"documents\"\\]):  \n    print(f\"DOCUMENT {i}\")  \n    print(document.content)\n\n### Exploración de Nuevas Preguntas y Ajustes\n\nPuedes ajustar los parámetros de búsqueda, como el número de resultados (`top_k`) o probar con diferentes preguntas.\n\nquestion = \"Where was Davinci born?\"  \nresults = document\\_search.run({\"query\\_embedder\": {\"text\": question}, \"retriever\": {\"top\\_k\": 3}})\n\nEsta flexibilidad permite personalizar la _pipeline_ según las necesidades de la aplicación.\n\n### Conclusión\n\nHaystack ofrece un enfoque modular para construir aplicaciones de IA al permitir la combinación de componentes en _pipelines_. Este enfoque hace que sea fácil experimentar y escalar las aplicaciones de IA, desde la indexación de documentos hasta la búsqueda avanzada.\n\nPara los desarrolladores interesados en construir aplicaciones de búsqueda, generación de respuestas o análisis de documentos, Haystack proporciona las herramientas necesarias para combinar componentes y lograr resultados precisos y eficientes.\n\nSi deseas explorar más sobre Haystack y sus capacidades, visita su documentación oficial. [https://docs.haystack.deepset.ai/docs/intro](https://docs.haystack.deepset.ai/docs/intro)\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [August 28, 2024](https://medium.com/p/02d1ae93a849).\n\n[Canonical link](https://medium.com/@devjaime/haystack-construyendo-aplicaciones-de-ia-con-componentes-modulares-02d1ae93a849)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"haystack-construyendo-aplicaciones-de-ia-con-componentes-modulares","text":"Haystack: Construyendo Aplicaciones de IA con Componentes Modulares"},{"depth":3,"slug":"haystack-construyendo-aplicaciones-de-ia-con-componentes-modulares-1","text":"Haystack: Construyendo Aplicaciones de IA con Componentes Modulares"},{"depth":3,"slug":"componentes-la-base-detodo","text":"Componentes: La Base de Todo"},{"depth":3,"slug":"pipelines-conectando-componentes","text":"Pipelines: Conectando Componentes"},{"depth":3,"slug":"creando-una-pipeline-de-indexación","text":"Creando una Pipeline de Indexación"},{"depth":3,"slug":"creando-una-pipeline-de-búsqueda-de-documentos","text":"Creando una Pipeline de Búsqueda de Documentos"},{"depth":3,"slug":"ejecución-de-labúsqueda","text":"Ejecución de la Búsqueda"},{"depth":3,"slug":"exploración-de-nuevas-preguntas-yajustes","text":"Exploración de Nuevas Preguntas y Ajustes"},{"depth":3,"slug":"conclusión","text":"Conclusión"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
