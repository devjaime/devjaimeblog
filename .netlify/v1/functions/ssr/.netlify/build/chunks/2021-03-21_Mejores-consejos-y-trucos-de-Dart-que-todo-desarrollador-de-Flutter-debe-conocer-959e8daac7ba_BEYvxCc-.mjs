/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"mejores-consejos-y-trucos-de-dart-que-todo-desarrollador-de-flutter-debe-conocer\">Mejores consejos y trucos de Dart que todo desarrollador de Flutter debe conocer</h1>\n<p>En este tutorial, comparto mis mejores consejos y trucos de Dart que mejorarán su estilo de codificación como desarrollador de Flutter.</p>\n<hr>\n<h3 id=\"mejores-consejos-y-trucos-de-dart-que-todo-desarrollador-de-flutter-debeconocer\">Mejores consejos y trucos de Dart que todo desarrollador de Flutter debe conocer</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*Xi6L_7owmvTd6D7A.png\" alt=\"\"></p>\n<p>En este tutorial, comparto mis mejores consejos y trucos de Dart que mejorarán tu estilo de codificación como desarrollador de Flutter.</p>\n<p>Puede usarlos para escribir código más conciso y efectivo, y aprovechar al máximo el lenguaje Dart.</p>\n<p>¿Listo? ¡Empecemos!</p>\n<h3 id=\"1-sabías-dart-admite-la-multiplicación-decadenas\">1. ¿Sabías? Dart admite la multiplicación de cadenas.</h3>\n<p>Aquí hay un programa simple que muestra cómo imprimir un árbol de Navidad con multiplicación de cadenas:</p>\n<p>Genial, ¿no es así? 😉</p>\n<p>Puede usar esto para verificar cómo encaja una cadena larga dentro de un <code>Text</code>widget:</p>\n<h3 id=\"2-necesita-ejecutar-varios-future-al-mismo-tiempo-utilice-futurewait\">2. ¿Necesita ejecutar varios Future al mismo tiempo? Utilice Future.wait.</h3>\n<p>Considere esta clase de API simulada que nos dice los últimos números de casos de COVID:</p>\n<p>Para ejecutar todos estos Future al mismo tiempo, utilice <code>Future.wait</code>. Esto toma una <strong>lista o Future</strong> y devuelve una <strong>lista de Future</strong>:</p>\n<p>Esto es ideal cuando los Future son <strong>independientes</strong> y no necesitan ejecutarse <strong>secuencialmente</strong> .</p>\n<h3 id=\"3-implemente-un-método-de-llamada-en-sus-clases-de-dart-para-hacerlas-invocables-como-unafunción\">3. Implemente un método de “llamada” en sus clases de Dart para hacerlas invocables como una función.</h3>\n<p>Aquí hay una <code>PasswordValidator</code>clase de ejemplo :</p>\n<p>Debido a que el método tiene un nombre <code>call</code>, podemos declarar una instancia de clase y usarla <strong>como si</strong> fuera un método:</p>\n<h3 id=\"4-necesita-invocar-una-devolución-de-llamada-pero-solo-si-no-es-nula-utilice-la-sintaxis-call\">4. ¿Necesita invocar una devolución de llamada pero solo si no es nula? Utilice la sintaxis “? .Call ()”.</h3>\n<p>Supongamos que tenemos una clase de widget personalizada que debería llamar a una <code>onDragCompleted</code>devolución de llamada cuando se produce un evento determinado:</p>\n<p>Pero hay una forma más sencilla (tenga en cuenta el uso de <code>?.</code>):</p>\n<h3 id=\"5-usar-funciones-anónimas-y-funciones-como-argumentos\">5. Usar funciones anónimas y funciones como argumentos</h3>\n<p>En Dart, las funciones son <strong>ciudadanos de primera clase</strong> y se pueden pasar <strong>como argumentos</strong> a otras funciones.</p>\n<p>Aquí hay un código que define una función anónima y la asigna a una variable <code>sayHi(di hola)</code>:</p>\n<p>Luego <code>sayHi</code>se pasa a una función <code>welcome</code> que toma un <code>Function</code>argumento y lo usa para saludar al usuario.</p>\n<p><code>String Function(String)</code>es un <strong>tipo de función</strong> que toma un argumento <code>String</code> y devuelve un <code>String</code>. Debido a que la función anónima anterior tiene la misma <strong>firma</strong> , se puede pasar directamente como un argumento o mediante la variable<code>sayHi</code>.</p>\n<hr>\n<p>Este estilo de codificación es común cuando se utiliza operadores funcionales, tales como <code>map</code>, <code>where</code>, y <code>reduce</code>.</p>\n<p>Por ejemplo, aquí hay una función simple para calcular el cuadrado de un número:</p>\n<p>Aquí pasamos <code>square</code>como argumento, porque su firma es exactamente lo que espera el operador del mapa. Esto significa que no necesitamos expandirlo con una función anónima:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>values.map((value) => square(value)).toList();</span></span></code></pre>\n<h3 id=\"6-puede-utilizar-collection-if-y-spreads-con-lists-sets-ymaps\">6. Puede utilizar collection-if y spreads con lists, sets y maps</h3>\n<p>Collection-if y spreads son muy útiles cuando escribes tu interfaz de usuario como código.</p>\n<p>¿Pero sabías que también puedes usarlos con maps?</p>\n<p>Considere este ejemplo:</p>\n<p>Aquí estamos declarando un <code>restaurant</code>maps, y sólo la adición de la <code>avgRating</code>y <code>numRatings</code>valores clave-valor si <code>addRatings</code>es <code>true</code>. Y debido a que estamos agregando más de un par clave-valor, necesitamos usar el operador de propagación ( <code>...</code>).</p>\n<h3 id=\"7-necesita-iterar-a-través-de-un-maps-de-una-manera-segura-para-nulos-utiliza-entries\">7. ¿Necesita iterar a través de un maps de una manera segura para nulos? Utiliza `.entries`:</h3>\n<p>Supone que tiene este mapa:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>const timeSpent = &#x3C;String, double>{  'Blogging': 10.5,  'YouTube': 30.5,  'Courses': 75.2,};</span></span></code></pre>\n<p>A continuación, te muestro cómo puedes escribir un bucle para ejecutar algún código utilizando todos los pares clave-valor:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>for (var entry in timeSpent.entries) {  // hacer algo con claves y valores  print('${entry.key}: ${entry.value}');}</span></span></code></pre>\n<p>Al iterar en la variable<code>entries</code>, tiene acceso a todos los pares clave-valor <strong>de una manera segura para nulos</strong> .</p>\n<p>Esto es más conciso y menos propenso a errores que esto:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>for (var key in timeSpent.keys) {  final value = timeSpent[key]!;  print('$key: $value');}</span></span></code></pre>\n<p>El código anterior requiere usar el operador de aserción ( <code>!</code>) al leer los valores, ya que Dart no puede garantizar que exista un valor para una clave determinada.</p>\n<h3 id=\"8-utilice-constructores-con-nombre-y-listas-de-inicializadores-para-obtener-api-más-faciles-deusar\">8. Utilice constructores con nombre y listas de inicializadores para obtener API más faciles de usar.</h3>\n<p>Suponga que desea declarar una clase que representa un valor de temperatura.</p>\n<p>Puede hacer que la API de su clase sea inequívoca y admitir <strong>tanto</strong> Celsius como Fahrenheit con dos constructores con nombre:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>class Temperature {  Temperature.celsius(this.celsius);  Temperature.fahrenheit(double fahrenheit)    : celsius = (fahrenheit - 32) / 1.8;  double celsius;}</span></span></code></pre>\n<p>Esta clase solo necesita una variable <strong>almacenada</strong> para representar la temperatura y usa una lista de inicializadores para convertir Fahrenheit a Celsius.</p>\n<p>Esto significa que puede declarar valores de temperatura como este:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>final temp1 = Temperature.celsius(30);final temp2 = Temperature.fahrenheit(90);</span></span></code></pre>\n<h3 id=\"9-getters-ysetters\">9. Getters y setters</h3>\n<p>En la <code>Temperature</code>clase anterior, <code>celsius</code>se declara como una variable almacenada.</p>\n<p>Pero los usuarios pueden preferir <strong>obtener</strong> o <strong>establecer</strong> la temperatura en grados Fahrenheit.</p>\n<p>Esto se hace fácilmente con getters y setters, que le permiten definir variables calculadas. Aquí está la clase actualizada:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>class Temperature {  Temperature.celsius(this.celsius);  Temperature.fahrenheit(double fahrenheit)    : celsius = (fahrenheit - 32) / 1.8;  double celsius;  double get fahrenheit    => celsius * 1.8 + 32;  set fahrenheit(double fahrenheit)    => celsius = (fahrenheit - 32) / 1.8;}</span></span></code></pre>\n<p>Esto facilita la obtención o el ajuste de la temperatura con grados Fahrenheit o Celsius:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>final temp1 = Temperature.celsius(30);print(temp1.fahrenheit);final temp2 = Temperature.fahrenheit(90);temp2.celsius = 28;</span></span></code></pre>\n<p><strong>En pocas palabras</strong> : utilice constructores, getters y setters con nombre para mejorar el diseño de sus clases.</p>\n<h3 id=\"10-utilice-guiones-bajos-para-argumentos-de-función-no-utilizados\">10. Utilice guiones bajos para argumentos de función no utilizados</h3>\n<p>En Flutter a menudo usamos widgets que toman argumentos de función. Un ejemplo común de esto es <code>ListView.builder</code>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>class MyListView extends StatelessWidget {  @override  Widget build(BuildContext context) {    return ListView.builder(      itemBuilder: (context, index) => ListTile(        title: Text('todos iguales'),      ),      itemCount: 10,    );  }}</span></span></code></pre>\n<p>En este caso, no estamos usando los <code>(context, index)</code>argumentos en <code>itemBuilder</code>. Entonces podemos reemplazarlos con guiones bajos en su lugar:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>ListView.builder(  itemBuilder: (_, __) => ListTile(    title: Text('todos iguales'),  ),  itemCount: 10,)</span></span></code></pre>\n<p><em>Nota: los dos argumentos son diferentes (</em> <code>___</code><em>y</em> <code>____</code><em>) ya que son</em> <strong><em>identificadores separados</em></strong> <em>.</em></p>\n<h3 id=\"11-necesita-una-clase-que-solo-se-pueda-instanciar-una-vez-también-conocida-como-singleton-utiliza-una-variable-de-instancia-estática-con-un-constructor-privado\">11. ¿Necesita una clase que solo se pueda instanciar una vez (también conocida como singleton)? Utiliza una variable de instancia estática con un constructor privado.</h3>\n<p>La propiedad más importante de un singleton es que solo puede haber <strong>una instancia</strong> de él en todo el programa. Esto es útil para modelar cosas como un sistema de archivos.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>// file_system.dartclass FileSystem {  FileSystem._();  static final instance = FileSystem._();}</span></span></code></pre>\n<p>Para crear un singleton en Dart, puede declarar un constructor con nombre y hacerlo privado usando la sintaxis<code>_</code>.</p>\n<p>Luego, puede usarlo para crear una instancia final estática de tu clase.</p>\n<p>Y como resultado, cualquier código en otros archivos solo podrá acceder a esta clase a través de la variable<code>instance</code>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>// some_other_file.dartfinal fs = FileSystem.instance;// </span></span></code></pre>\n<p><em>Nota: los singleton pueden ocasionar muchos problemas si no se tiene cuidado. Asegúrese de comprender las desventajas antes de usarlos.</em></p>\n<h3 id=\"12-necesita-una-colección-de-artículos-únicos-utilice-un-conjunto-en-lugar-de-unalista\">12. ¿Necesita una colección de artículos únicos? Utilice un conjunto en lugar de una lista.</h3>\n<p>El tipo de colección más utilizado en Dart es <code>List</code>.</p>\n<p>Pero las listas pueden tener elementos duplicados y, a veces, esto no es lo que queremos:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>const citiesList = [  'London',  'Paris',  'Rome',  'London',];</span></span></code></pre>\n<p>Podemos usar un <code>Set</code>siempre que necesitemos una colección de valores únicos (tenga en cuenta el uso de <code>final</code>):</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>// </span></span></code></pre>\n<p>El código anterior genera una advertencia porque <code>London</code>se incluye dos veces. Si intentamos hacer lo mismo con un conjunto<code>const</code>, obtenemos un error y nuestro código no se compila:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>// </span></span></code></pre>\n<p>Cuando trabajamos con conjuntos, tenemos acceso a las API útiles, tales como <code>union</code>, <code>difference</code>y <code>intersection</code>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>citiesSet.union({'Delhi', 'Moscow'});citiesSet.difference({'London', 'Madrid'});citiesSet.intersection({'London', 'Berlin'});</span></span></code></pre>\n<blockquote>\n<p><em>En pocas palabras: cuando cree una colección, pregúntese si desea que sus artículos sean únicos y considere usar un conjunto.</em></p>\n</blockquote>\n<h3 id=\"13-cómo-usar-try-on-catch-rethrowfinally\">13. Cómo usar try, on, catch, rethrow,finally.</h3>\n<p><code>try</code>y <code>catch</code>son ideales cuando se trabaja con API basadas en el futuro que pueden generar una excepción si algo sale mal.</p>\n<p>Aquí hay un ejemplo completo que muestra cómo aprovecharlos al máximo:</p>\n<p>Algunas notas:</p>\n<ul>\n<li>puede agregar varias cláusulas<code>on</code> para manejar excepciones de diferentes tipos.</li>\n<li>puede tener una cláusula<code>catch</code> de reserva para manejar todas las excepciones que no coincidan con ninguno de los tipos anteriores.</li>\n<li>puede usar una declaración<code>rethrow</code> para lanzar la excepción actual en la pila de llamadas <strong>mientras se conserva el seguimiento de la pila</strong> .</li>\n<li>puede usar <code>finally</code>para ejecutar algún código después de que se <code>Future</code>haya completado, independientemente de si tuvo éxito o no.</li>\n</ul>\n<p>Si está utilizando o diseñando algunas API basadas en el futuro, asegúrese de manejar las excepciones según sea necesario.</p>\n<h3 id=\"14-constructores-comunes-delfuture\">14. Constructores comunes del future</h3>\n<p>La clase<code>Future en Dart</code>viene con algunos constructores de fábrica prácticos: <code>Future.delayed</code>, <code>Future.value</code>y <code>Future.error</code>.</p>\n<p>Podemos usar <code>Future.delayed</code>para crear un <code>Future</code>que espere un cierto retraso. El segundo argumento es una función anónima (opcional) que puede usar para completar con un valor o arrojar un error:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>await Future.delayed(Duration(seconds: 2), () => 'Latte');</span></span></code></pre>\n<p>Pero a veces queremos crear un <code>Future</code>que se complete de inmediato:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>await Future.value('Cappuccino');await Future.error(Exception('</span></span></code></pre>\n<p>Podemos utilizar <code>Future.value</code>para completar correctamente con un valor, o <code>Future.error</code>para completar con un error.</p>\n<p>Puede utilizar estos constructores para simular la respuesta de sus API basadas en Future. Esto es útil al escribir clases simuladas en su código de prueba.</p>\n<h3 id=\"15-common-stream-constructors\">15. Common Stream constructors</h3>\n<p>La clase Stream también viene con algunos constructores útiles. Éstos son los más comunes:</p>\n<p>utilizar <code>Stream.fromIterable</code>para crear a <code>Stream</code>partir de una lista de valores.</p>\n<ul>\n<li>utilícelo <code>Stream.value</code>si solo tiene un valor.</li>\n<li>utilizar <code>Stream.empty</code>para crear una secuencia vacía.</li>\n<li>utilícelo <code>Stream.error</code>para crear una secuencia que contenga un valor de error.</li>\n<li>utilícelo <code>Stream.fromFuture</code>para crear una secuencia que contendrá solo un valor, y ese valor estará disponible cuando se complete el futuro.</li>\n<li>utilizar <code>Stream.periodic</code>para crear un flujo periódico de eventos. Puede especificar a <code>Duration</code>como el intervalo de tiempo entre eventos y una función anónima para generar cada valor dado su índice en la secuencia.</li>\n</ul>\n<h3 id=\"16-generadores-sincronizados-y-asíncronos\">16. Generadores sincronizados y asíncronos</h3>\n<p>En Dart podemos definir un generador <strong>síncrono</strong> como una función que devuelve un <code>Iterable</code>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>Iterable&#x3C;int> count(int n) sync* {  for (var i = 1; i &#x3C;= n; i++) {    yield i;  }}</span></span></code></pre>\n<p>Esto usa la sintaxis<code>sync*</code>. Dentro de la función podemos “generar” <code>yield</code>múltiples valores. Estos se devolverán como una <code>Iterable</code>cuando se complete la función.</p>\n<hr>\n<p>Por otro lado, un generador <strong>asincrónico</strong> es una función que devuelve <code>Stream</code>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>Stream&#x3C;int> countStream(int n) async* {  for (var i = 1; i &#x3C;= n; i++) {    yield i;  }}</span></span></code></pre>\n<p>Esto usa esta <code>async*</code>sintaxis. Dentro de la función podemos valores <code>yield</code>como en el caso sincrónico.</p>\n<p>Pero si queremos, podemos <code>await</code>hacerlo en las API basadas en el futuro, porque este es un generador <strong>asincrónico</strong> :</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>Stream&#x3C;int> countStream(int n) async* {  for (var i = 1; i &#x3C;= n; i++) {    // </span></span></code></pre>\n<h3 id=\"conclusión\">Conclusión</h3>\n<p>Espero que hayas disfrutado de mis mejores consejos y trucos de Dart para desarrolladores de Flutter.</p>\n<p>¿Mi desafío para ti?</p>\n<p>Úselos para mejorar el código en sus aplicaciones Flutter. Y déjame saber cuál fue tu favorito <a href=\"https://twitter.com/HsJhernandez\">en Twitter</a> . 😉</p>\n<p><a href=\"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\" title=\"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\"><strong>Donate to devjaime</strong><br>\n_Help support devjaime by donating or sharing with your friends._www.paypal.com</a><a href=\"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\"></a></p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/959e8daac7ba\">March 21, 2021</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/mejores-consejos-y-trucos-de-dart-que-todo-desarrollador-de-flutter-debe-conocer-959e8daac7ba\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Mejores consejos y trucos de Dart que todo desarrollador de Flutter debe conocer","description":"","tags":["code","dart","flutter"],"time":4,"featured":true,"timestamp":"2021-03-21T12:20:31-0300","filename":"2021-03-21_Mejores-consejos-y-trucos-de-Dart-que-todo-desarrollador-de-Flutter-debe-conocer-959e8daac7ba"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2021-03-21_Mejores-consejos-y-trucos-de-Dart-que-todo-desarrollador-de-Flutter-debe-conocer-959e8daac7ba.md";
				const url = "/blog/2021-03-21_Mejores-consejos-y-trucos-de-Dart-que-todo-desarrollador-de-Flutter-debe-conocer-959e8daac7ba";
				function rawContent() {
					return "   \n                                        \n                                                                                         \n               \n                                 \n       \n              \n                                     \n                                                                                                                    \n   \n\nMejores consejos y trucos de Dart que todo desarrollador de Flutter debe conocer\n================================================================================\n\nEn este tutorial, comparto mis mejores consejos y trucos de Dart que mejorarán su estilo de codificación como desarrollador de Flutter.\n\n* * *\n\n### Mejores consejos y trucos de Dart que todo desarrollador de Flutter debe conocer\n\n![](https://cdn-images-1.medium.com/max/800/0*Xi6L_7owmvTd6D7A.png)\n\nEn este tutorial, comparto mis mejores consejos y trucos de Dart que mejorarán tu estilo de codificación como desarrollador de Flutter.\n\nPuede usarlos para escribir código más conciso y efectivo, y aprovechar al máximo el lenguaje Dart.\n\n¿Listo? ¡Empecemos!\n\n### 1\\. ¿Sabías? Dart admite la multiplicación de cadenas.\n\nAquí hay un programa simple que muestra cómo imprimir un árbol de Navidad con multiplicación de cadenas:\n\nGenial, ¿no es así? 😉\n\nPuede usar esto para verificar cómo encaja una cadena larga dentro de un `Text`widget:\n\n### 2\\. ¿Necesita ejecutar varios Future al mismo tiempo? Utilice Future.wait.\n\nConsidere esta clase de API simulada que nos dice los últimos números de casos de COVID:\n\nPara ejecutar todos estos Future al mismo tiempo, utilice `Future.wait`. Esto toma una **lista o Future** y devuelve una **lista de Future**:\n\nEsto es ideal cuando los Future son **independientes** y no necesitan ejecutarse **secuencialmente** .\n\n### 3\\. Implemente un método de “llamada” en sus clases de Dart para hacerlas invocables como una función.\n\nAquí hay una `PasswordValidator`clase de ejemplo :\n\nDebido a que el método tiene un nombre `call`, podemos declarar una instancia de clase y usarla **como si** fuera un método:\n\n### 4\\. ¿Necesita invocar una devolución de llamada pero solo si no es nula? Utilice la sintaxis “? .Call ()”.\n\nSupongamos que tenemos una clase de widget personalizada que debería llamar a una `onDragCompleted`devolución de llamada cuando se produce un evento determinado:\n\nPero hay una forma más sencilla (tenga en cuenta el uso de `?.`):\n\n### 5\\. Usar funciones anónimas y funciones como argumentos\n\nEn Dart, las funciones son **ciudadanos de primera clase** y se pueden pasar **como argumentos** a otras funciones.\n\nAquí hay un código que define una función anónima y la asigna a una variable `sayHi(di hola)`:\n\nLuego `sayHi`se pasa a una función `welcome` que toma un `Function`argumento y lo usa para saludar al usuario.\n\n`String Function(String)`es un **tipo de función** que toma un argumento `String` y devuelve un `String`. Debido a que la función anónima anterior tiene la misma **firma** , se puede pasar directamente como un argumento o mediante la variable`sayHi`.\n\n* * *\n\nEste estilo de codificación es común cuando se utiliza operadores funcionales, tales como `map`, `where`, y `reduce`.\n\nPor ejemplo, aquí hay una función simple para calcular el cuadrado de un número:\n\nAquí pasamos `square`como argumento, porque su firma es exactamente lo que espera el operador del mapa. Esto significa que no necesitamos expandirlo con una función anónima:\n\n    values.map((value) => square(value)).toList();\n\n### 6\\. Puede utilizar collection-if y spreads con lists, sets y maps\n\nCollection-if y spreads son muy útiles cuando escribes tu interfaz de usuario como código.\n\n¿Pero sabías que también puedes usarlos con maps?\n\nConsidere este ejemplo:\n\nAquí estamos declarando un `restaurant`maps, y sólo la adición de la `avgRating`y `numRatings`valores clave-valor si `addRatings`es `true`. Y debido a que estamos agregando más de un par clave-valor, necesitamos usar el operador de propagación ( `...`).\n\n### 7\\. ¿Necesita iterar a través de un maps de una manera segura para nulos? Utiliza \\`.entries\\`:\n\nSupone que tiene este mapa:\n\n    const timeSpent = <String, double>{  'Blogging': 10.5,  'YouTube': 30.5,  'Courses': 75.2,};\n\nA continuación, te muestro cómo puedes escribir un bucle para ejecutar algún código utilizando todos los pares clave-valor:\n\n    for (var entry in timeSpent.entries) {  // hacer algo con claves y valores  print('${entry.key}: ${entry.value}');}\n\nAl iterar en la variable`entries`, tiene acceso a todos los pares clave-valor **de una manera segura para nulos** .\n\nEsto es más conciso y menos propenso a errores que esto:\n\n    for (var key in timeSpent.keys) {  final value = timeSpent[key]!;  print('$key: $value');}\n\nEl código anterior requiere usar el operador de aserción ( `!`) al leer los valores, ya que Dart no puede garantizar que exista un valor para una clave determinada.\n\n### 8\\. Utilice constructores con nombre y listas de inicializadores para obtener API más faciles de usar.\n\nSuponga que desea declarar una clase que representa un valor de temperatura.\n\nPuede hacer que la API de su clase sea inequívoca y admitir **tanto** Celsius como Fahrenheit con dos constructores con nombre:\n\n    class Temperature {  Temperature.celsius(this.celsius);  Temperature.fahrenheit(double fahrenheit)    : celsius = (fahrenheit - 32) / 1.8;  double celsius;}\n\nEsta clase solo necesita una variable **almacenada** para representar la temperatura y usa una lista de inicializadores para convertir Fahrenheit a Celsius.\n\nEsto significa que puede declarar valores de temperatura como este:\n\n    final temp1 = Temperature.celsius(30);final temp2 = Temperature.fahrenheit(90);\n\n### 9\\. Getters y setters\n\nEn la `Temperature`clase anterior, `celsius`se declara como una variable almacenada.\n\nPero los usuarios pueden preferir **obtener** o **establecer** la temperatura en grados Fahrenheit.\n\nEsto se hace fácilmente con getters y setters, que le permiten definir variables calculadas. Aquí está la clase actualizada:\n\n    class Temperature {  Temperature.celsius(this.celsius);  Temperature.fahrenheit(double fahrenheit)    : celsius = (fahrenheit - 32) / 1.8;  double celsius;  double get fahrenheit    => celsius * 1.8 + 32;  set fahrenheit(double fahrenheit)    => celsius = (fahrenheit - 32) / 1.8;}\n\nEsto facilita la obtención o el ajuste de la temperatura con grados Fahrenheit o Celsius:\n\n    final temp1 = Temperature.celsius(30);print(temp1.fahrenheit);final temp2 = Temperature.fahrenheit(90);temp2.celsius = 28;\n\n**En pocas palabras** : utilice constructores, getters y setters con nombre para mejorar el diseño de sus clases.\n\n### 10\\. Utilice guiones bajos para argumentos de función no utilizados\n\nEn Flutter a menudo usamos widgets que toman argumentos de función. Un ejemplo común de esto es `ListView.builder`:\n\n    class MyListView extends StatelessWidget {  @override  Widget build(BuildContext context) {    return ListView.builder(      itemBuilder: (context, index) => ListTile(        title: Text('todos iguales'),      ),      itemCount: 10,    );  }}\n\nEn este caso, no estamos usando los `(context, index)`argumentos en `itemBuilder`. Entonces podemos reemplazarlos con guiones bajos en su lugar:\n\n    ListView.builder(  itemBuilder: (_, __) => ListTile(    title: Text('todos iguales'),  ),  itemCount: 10,)\n\n_Nota: los dos argumentos son diferentes (_ `___`_y_ `____`_) ya que son_ **_identificadores separados_** _._\n\n### 11\\. ¿Necesita una clase que solo se pueda instanciar una vez (también conocida como singleton)? Utiliza una variable de instancia estática con un constructor privado.\n\nLa propiedad más importante de un singleton es que solo puede haber **una instancia** de él en todo el programa. Esto es útil para modelar cosas como un sistema de archivos.\n\n    // file_system.dartclass FileSystem {  FileSystem._();  static final instance = FileSystem._();}\n\nPara crear un singleton en Dart, puede declarar un constructor con nombre y hacerlo privado usando la sintaxis`_`.\n\nLuego, puede usarlo para crear una instancia final estática de tu clase.\n\nY como resultado, cualquier código en otros archivos solo podrá acceder a esta clase a través de la variable`instance`:\n\n    // some_other_file.dartfinal fs = FileSystem.instance;// \n\n_Nota: los singleton pueden ocasionar muchos problemas si no se tiene cuidado. Asegúrese de comprender las desventajas antes de usarlos._\n\n### 12\\. ¿Necesita una colección de artículos únicos? Utilice un conjunto en lugar de una lista.\n\nEl tipo de colección más utilizado en Dart es `List`.\n\nPero las listas pueden tener elementos duplicados y, a veces, esto no es lo que queremos:\n\n    const citiesList = [  'London',  'Paris',  'Rome',  'London',];\n\nPodemos usar un `Set`siempre que necesitemos una colección de valores únicos (tenga en cuenta el uso de `final`):\n\n    // \n\nEl código anterior genera una advertencia porque `London`se incluye dos veces. Si intentamos hacer lo mismo con un conjunto`const`, obtenemos un error y nuestro código no se compila:\n\n    // \n\nCuando trabajamos con conjuntos, tenemos acceso a las API útiles, tales como `union`, `difference`y `intersection`:\n\n    citiesSet.union({'Delhi', 'Moscow'});citiesSet.difference({'London', 'Madrid'});citiesSet.intersection({'London', 'Berlin'});\n\n> _En pocas palabras: cuando cree una colección, pregúntese si desea que sus artículos sean únicos y considere usar un conjunto._\n\n### 13\\. Cómo usar try, on, catch, rethrow,finally.\n\n`try`y `catch`son ideales cuando se trabaja con API basadas en el futuro que pueden generar una excepción si algo sale mal.\n\nAquí hay un ejemplo completo que muestra cómo aprovecharlos al máximo:\n\nAlgunas notas:\n\n*   puede agregar varias cláusulas`on` para manejar excepciones de diferentes tipos.\n*   puede tener una cláusula`catch` de reserva para manejar todas las excepciones que no coincidan con ninguno de los tipos anteriores.\n*   puede usar una declaración`rethrow` para lanzar la excepción actual en la pila de llamadas **mientras se conserva el seguimiento de la pila** .\n*   puede usar `finally`para ejecutar algún código después de que se `Future`haya completado, independientemente de si tuvo éxito o no.\n\nSi está utilizando o diseñando algunas API basadas en el futuro, asegúrese de manejar las excepciones según sea necesario.\n\n### 14\\. Constructores comunes del future\n\nLa clase`Future en Dart`viene con algunos constructores de fábrica prácticos: `Future.delayed`, `Future.value`y `Future.error`.\n\nPodemos usar `Future.delayed`para crear un `Future`que espere un cierto retraso. El segundo argumento es una función anónima (opcional) que puede usar para completar con un valor o arrojar un error:\n\n    await Future.delayed(Duration(seconds: 2), () => 'Latte');\n\nPero a veces queremos crear un `Future`que se complete de inmediato:\n\n    await Future.value('Cappuccino');await Future.error(Exception('\n\nPodemos utilizar `Future.value`para completar correctamente con un valor, o `Future.error`para completar con un error.\n\nPuede utilizar estos constructores para simular la respuesta de sus API basadas en Future. Esto es útil al escribir clases simuladas en su código de prueba.\n\n### 15\\. Common Stream constructors\n\nLa clase Stream también viene con algunos constructores útiles. Éstos son los más comunes:\n\nutilizar `Stream.fromIterable`para crear a `Stream`partir de una lista de valores.\n\n*   utilícelo `Stream.value`si solo tiene un valor.\n*   utilizar `Stream.empty`para crear una secuencia vacía.\n*   utilícelo `Stream.error`para crear una secuencia que contenga un valor de error.\n*   utilícelo `Stream.fromFuture`para crear una secuencia que contendrá solo un valor, y ese valor estará disponible cuando se complete el futuro.\n*   utilizar `Stream.periodic`para crear un flujo periódico de eventos. Puede especificar a `Duration`como el intervalo de tiempo entre eventos y una función anónima para generar cada valor dado su índice en la secuencia.\n\n### 16\\. Generadores sincronizados y asíncronos\n\nEn Dart podemos definir un generador **síncrono** como una función que devuelve un `Iterable`:\n\n    Iterable<int> count(int n) sync* {  for (var i = 1; i <= n; i++) {    yield i;  }}\n\nEsto usa la sintaxis`sync*`. Dentro de la función podemos \"generar\" `yield`múltiples valores. Estos se devolverán como una `Iterable`cuando se complete la función.\n\n* * *\n\nPor otro lado, un generador **asincrónico** es una función que devuelve `Stream`:\n\n    Stream<int> countStream(int n) async* {  for (var i = 1; i <= n; i++) {    yield i;  }}\n\nEsto usa esta `async*`sintaxis. Dentro de la función podemos valores `yield`como en el caso sincrónico.\n\nPero si queremos, podemos `await`hacerlo en las API basadas en el futuro, porque este es un generador **asincrónico** :\n\n    Stream<int> countStream(int n) async* {  for (var i = 1; i <= n; i++) {    // \n\n### Conclusión\n\nEspero que hayas disfrutado de mis mejores consejos y trucos de Dart para desarrolladores de Flutter.\n\n¿Mi desafío para ti?\n\nÚselos para mejorar el código en sus aplicaciones Flutter. Y déjame saber cuál fue tu favorito [en Twitter](https://twitter.com/HsJhernandez) . 😉\n\n[**Donate to devjaime**  \n_Help support devjaime by donating or sharing with your friends._www.paypal.com](https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S \"https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S\")[](https://www.paypal.com/donate/?hosted_button_id=AHPZLS6ZR2A7S)\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [March 21, 2021](https://medium.com/p/959e8daac7ba).\n\n[Canonical link](https://medium.com/@devjaime/mejores-consejos-y-trucos-de-dart-que-todo-desarrollador-de-flutter-debe-conocer-959e8daac7ba)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"mejores-consejos-y-trucos-de-dart-que-todo-desarrollador-de-flutter-debe-conocer","text":"Mejores consejos y trucos de Dart que todo desarrollador de Flutter debe conocer"},{"depth":3,"slug":"mejores-consejos-y-trucos-de-dart-que-todo-desarrollador-de-flutter-debeconocer","text":"Mejores consejos y trucos de Dart que todo desarrollador de Flutter debe conocer"},{"depth":3,"slug":"1-sabías-dart-admite-la-multiplicación-decadenas","text":"1. ¿Sabías? Dart admite la multiplicación de cadenas."},{"depth":3,"slug":"2-necesita-ejecutar-varios-future-al-mismo-tiempo-utilice-futurewait","text":"2. ¿Necesita ejecutar varios Future al mismo tiempo? Utilice Future.wait."},{"depth":3,"slug":"3-implemente-un-método-de-llamada-en-sus-clases-de-dart-para-hacerlas-invocables-como-unafunción","text":"3. Implemente un método de “llamada” en sus clases de Dart para hacerlas invocables como una función."},{"depth":3,"slug":"4-necesita-invocar-una-devolución-de-llamada-pero-solo-si-no-es-nula-utilice-la-sintaxis-call","text":"4. ¿Necesita invocar una devolución de llamada pero solo si no es nula? Utilice la sintaxis “? .Call ()”."},{"depth":3,"slug":"5-usar-funciones-anónimas-y-funciones-como-argumentos","text":"5. Usar funciones anónimas y funciones como argumentos"},{"depth":3,"slug":"6-puede-utilizar-collection-if-y-spreads-con-lists-sets-ymaps","text":"6. Puede utilizar collection-if y spreads con lists, sets y maps"},{"depth":3,"slug":"7-necesita-iterar-a-través-de-un-maps-de-una-manera-segura-para-nulos-utiliza-entries","text":"7. ¿Necesita iterar a través de un maps de una manera segura para nulos? Utiliza `.entries`:"},{"depth":3,"slug":"8-utilice-constructores-con-nombre-y-listas-de-inicializadores-para-obtener-api-más-faciles-deusar","text":"8. Utilice constructores con nombre y listas de inicializadores para obtener API más faciles de usar."},{"depth":3,"slug":"9-getters-ysetters","text":"9. Getters y setters"},{"depth":3,"slug":"10-utilice-guiones-bajos-para-argumentos-de-función-no-utilizados","text":"10. Utilice guiones bajos para argumentos de función no utilizados"},{"depth":3,"slug":"11-necesita-una-clase-que-solo-se-pueda-instanciar-una-vez-también-conocida-como-singleton-utiliza-una-variable-de-instancia-estática-con-un-constructor-privado","text":"11. ¿Necesita una clase que solo se pueda instanciar una vez (también conocida como singleton)? Utiliza una variable de instancia estática con un constructor privado."},{"depth":3,"slug":"12-necesita-una-colección-de-artículos-únicos-utilice-un-conjunto-en-lugar-de-unalista","text":"12. ¿Necesita una colección de artículos únicos? Utilice un conjunto en lugar de una lista."},{"depth":3,"slug":"13-cómo-usar-try-on-catch-rethrowfinally","text":"13. Cómo usar try, on, catch, rethrow,finally."},{"depth":3,"slug":"14-constructores-comunes-delfuture","text":"14. Constructores comunes del future"},{"depth":3,"slug":"15-common-stream-constructors","text":"15. Common Stream constructors"},{"depth":3,"slug":"16-generadores-sincronizados-y-asíncronos","text":"16. Generadores sincronizados y asíncronos"},{"depth":3,"slug":"conclusión","text":"Conclusión"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
