/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"construyendo-subconsultas-eficientes-en-postgresql-con-ctes-ejemplos-en-retail-y-banca\">Construyendo Subconsultas Eficientes en PostgreSQL con CTEs: Ejemplos en Retail y Banca</h1>\n<p>En el mundo del desarrollo de bases de datos, las subconsultas son una herramienta poderosa que nos permite realizar consultas complejas de…</p>\n<hr>\n<h3 id=\"construyendo-subconsultas-eficientes-en-postgresql-con-ctes-ejemplos-en-retail-ybanca\">Construyendo Subconsultas Eficientes en PostgreSQL con CTEs: Ejemplos en Retail y Banca</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*TYMInECvXoCjO5qA\" alt=\"\"></p>\n<p>generada con IA OpenIA</p>\n<p>En el mundo del desarrollo de bases de datos, las subconsultas son una herramienta poderosa que nos permite realizar consultas complejas de manera modular y eficiente. PostgreSQL, uno de los sistemas de gestión de bases de datos más avanzados y populares, ofrece una técnica llamada Common Table Expressions (CTEs) para optimizar y ejecutar subconsultas. En este blog, exploraremos cómo construir subconsultas eficientes en PostgreSQL utilizando CTEs con ejemplos prácticos en los sectores de retail y banca.</p>\n<h3 id=\"qué-son-lasctes\">¿Qué son las CTEs?</h3>\n<p>Las Common Table Expressions (CTEs) son una forma de definir consultas temporales que pueden ser referenciadas dentro de la consulta principal. Las CTEs mejoran la legibilidad y el mantenimiento del código SQL, especialmente cuando se trata de consultas complejas. Se definen utilizando la cláusula <code>**WITH**</code>.</p>\n<h3 id=\"ventajas-de-lasctes\">Ventajas de las CTEs</h3>\n<ul>\n<li><strong>Legibilidad</strong>: Las CTEs hacen que las consultas sean más fáciles de leer y entender.</li>\n<li><strong>Reutilización de código</strong>: Permiten reutilizar una subconsulta en varias partes de la consulta principal.</li>\n<li><strong>Mantenimiento</strong>: Facilitan el mantenimiento del código, ya que las subconsultas se definen de forma clara y separada.</li>\n</ul>\n<h3 id=\"ejemplos-de-ctes-en-retail-ybanca\">Ejemplos de CTEs en Retail y Banca</h3>\n<h3 id=\"ejemplo-en-retail-filtrar-productos-por-preciopromedio\">Ejemplo en Retail: Filtrar Productos por Precio Promedio</h3>\n<p>Supongamos que queremos crear una subconsulta que filtre productos con un precio mayor al promedio y luego usar esta subconsulta en la consulta principal.</p>\n<p>WITH filtered_products AS (<br>\nSELECT nombre_producto, precio<br>\nFROM productos<br>\nWHERE precio > (SELECT AVG(precio) FROM productos)<br>\n)<br>\nSELECT nombre_producto, precio<br>\nFROM filtered_products;</p>\n<p>En este ejemplo, la CTE <code>filtered_products</code> selecciona los productos cuyo precio es mayor que el precio promedio de todos los productos. Luego, la consulta principal selecciona todos los productos de la CTE.</p>\n<h3 id=\"ejemplo-en-banca-filtrar-cuentas-por-saldopromedio\">Ejemplo en Banca: Filtrar Cuentas por Saldo Promedio</h3>\n<p>Queremos crear una subconsulta que filtre cuentas con un saldo mayor al promedio y luego usar esta subconsulta en la consulta principal.</p>\n<p>WITH filtered_accounts AS (<br>\nSELECT numero_cuenta, saldo<br>\nFROM cuentas_bancarias<br>\nWHERE saldo > (SELECT AVG(saldo) FROM cuentas_bancarias)<br>\n)<br>\nSELECT numero_cuenta, saldo<br>\nFROM filtered_accounts;</p>\n<p>En este ejemplo, la CTE <code>filtered_accounts</code> selecciona las cuentas cuyo saldo es mayor que el saldo promedio de todas las cuentas bancarias. Luego, la consulta principal selecciona todas las cuentas de la CTE.</p>\n<h3 id=\"ejemplo-en-retail-productos-por-categoría-con-preciopromedio\">Ejemplo en Retail: Productos por Categoría con Precio Promedio</h3>\n<p>Queremos obtener el precio promedio de los productos por cada categoría y mostrarlo junto con el nombre del producto y su precio.</p>\n<p>WITH category_averages AS (<br>\nSELECT categoria_id, AVG(precio) AS precio_promedio<br>\nFROM productos<br>\nGROUP BY categoria_id<br>\n)<br>\nSELECT p.nombre_producto, p.precio, ca.precio_promedio<br>\nFROM productos p<br>\nJOIN category_averages ca ON p.categoria_id = ca.categoria_id;</p>\n<p>En este ejemplo, la CTE <code>category_averages</code> calcula el precio promedio de los productos por categoría. Luego, la consulta principal une los productos con los precios promedio por categoría.</p>\n<h3 id=\"ejemplo-en-banca-saldos-promedios-por-tipo-decuenta\">Ejemplo en Banca: Saldos Promedios por Tipo de Cuenta</h3>\n<p>Queremos obtener el saldo promedio de las cuentas por cada tipo de cuenta y mostrarlo junto con el número de cuenta y su saldo.</p>\n<p>WITH account_type_averages AS (<br>\nSELECT tipo_cuenta, AVG(saldo) AS saldo_promedio<br>\nFROM cuentas_bancarias<br>\nGROUP BY tipo_cuenta<br>\n)<br>\nSELECT c.numero_cuenta, c.saldo, ata.saldo_promedio<br>\nFROM cuentas_bancarias c<br>\nJOIN account_type_averages ata ON c.tipo_cuenta = ata.tipo_cuenta;</p>\n<p>En este ejemplo, la CTE <code>account_type_averages</code> calcula el saldo promedio de las cuentas por tipo de cuenta. Luego, la consulta principal une las cuentas bancarias con los saldos promedio por tipo de cuenta.</p>\n<h3 id=\"ejemplo-en-retail-productos-con-ventastotales\">Ejemplo en Retail: Productos con Ventas Totales</h3>\n<p>Queremos calcular el total de ventas por producto y mostrarlo junto con el nombre del producto.</p>\n<p>WITH total_sales AS (<br>\nSELECT producto_id, SUM(cantidad * precio) AS ventas_totales<br>\nFROM ventas<br>\nGROUP BY producto_id<br>\n)<br>\nSELECT p.nombre_producto, ts.ventas_totales<br>\nFROM productos p<br>\nJOIN total_sales ts ON p.producto_id = ts.producto_id;</p>\n<p>En este ejemplo, la CTE <code>total_sales</code> calcula el total de ventas por producto. Luego, la consulta principal une los productos con sus ventas totales.</p>\n<h3 id=\"ejemplo-en-banca-cuentas-con-transacciones-recientes\">Ejemplo en Banca: Cuentas con Transacciones Recientes</h3>\n<p>Queremos obtener las cuentas que han tenido transacciones en el último mes y mostrar el número de cuenta junto con el saldo.</p>\n<p>WITH recent_transactions AS (<br>\nSELECT DISTINCT numero_cuenta<br>\nFROM transacciones<br>\nWHERE fecha > CURRENT_DATE - INTERVAL ‘1 month’<br>\n)<br>\nSELECT c.numero_cuenta, c.saldo<br>\nFROM cuentas_bancarias c<br>\nJOIN recent_transactions rt ON c.numero_cuenta = rt.numero_cuenta;</p>\n<p>En este ejemplo, la CTE <code>recent_transactions</code> selecciona las cuentas que han tenido transacciones en el último mes. Luego, la consulta principal une estas cuentas con su saldo.</p>\n<h3 id=\"conclusión\">Conclusión</h3>\n<p>Las CTEs son una herramienta esencial en PostgreSQL para realizar subconsultas de manera eficiente y legible. Al entender cómo y cuándo utilizar CTEs, podemos optimizar el rendimiento de nuestras bases de datos y obtener resultados más precisos. Ya sea en el sector retail o en la banca, las CTEs pueden ayudarnos a extraer información valiosa y tomar decisiones informadas.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/a60c8ae0780a\">August 3, 2024</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/construyendo-subconsultas-eficientes-en-postgresql-con-ctes-ejemplos-en-retail-y-banca-a60c8ae0780a\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Construyendo Subconsultas Eficientes en PostgreSQL con CTEs: Ejemplos en Retail y Banca","description":"","tags":["code","PostgressSQL","CTEs"],"time":4,"featured":true,"timestamp":"2024-08-03T12:20:32-0300","filename":"2024-08-03_Construyendo-Subconsultas-Eficientes-en-PostgreSQL-con-CTEs--Ejemplos-en-Retail-y-Banca-a60c8ae0780a"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2024-08-03_Construyendo-Subconsultas-Eficientes-en-PostgreSQL-con-CTEs--Ejemplos-en-Retail-y-Banca-a60c8ae0780a.md";
				const url = "/blog/2024-08-03_Construyendo-Subconsultas-Eficientes-en-PostgreSQL-con-CTEs--Ejemplos-en-Retail-y-Banca-a60c8ae0780a";
				function rawContent() {
					return "   \n                                        \n                                                                                                \n               \n                                      \n       \n              \n                                     \n                                                                                                                           \n   \n\nConstruyendo Subconsultas Eficientes en PostgreSQL con CTEs: Ejemplos en Retail y Banca\n=======================================================================================\n\nEn el mundo del desarrollo de bases de datos, las subconsultas son una herramienta poderosa que nos permite realizar consultas complejas de…\n\n* * *\n\n### Construyendo Subconsultas Eficientes en PostgreSQL con CTEs: Ejemplos en Retail y Banca\n\n![](https://cdn-images-1.medium.com/max/800/0*TYMInECvXoCjO5qA)\n\ngenerada con IA OpenIA\n\nEn el mundo del desarrollo de bases de datos, las subconsultas son una herramienta poderosa que nos permite realizar consultas complejas de manera modular y eficiente. PostgreSQL, uno de los sistemas de gestión de bases de datos más avanzados y populares, ofrece una técnica llamada Common Table Expressions (CTEs) para optimizar y ejecutar subconsultas. En este blog, exploraremos cómo construir subconsultas eficientes en PostgreSQL utilizando CTEs con ejemplos prácticos en los sectores de retail y banca.\n\n### ¿Qué son las CTEs?\n\nLas Common Table Expressions (CTEs) son una forma de definir consultas temporales que pueden ser referenciadas dentro de la consulta principal. Las CTEs mejoran la legibilidad y el mantenimiento del código SQL, especialmente cuando se trata de consultas complejas. Se definen utilizando la cláusula `**WITH**`.\n\n### Ventajas de las CTEs\n\n*   **Legibilidad**: Las CTEs hacen que las consultas sean más fáciles de leer y entender.\n*   **Reutilización de código**: Permiten reutilizar una subconsulta en varias partes de la consulta principal.\n*   **Mantenimiento**: Facilitan el mantenimiento del código, ya que las subconsultas se definen de forma clara y separada.\n\n### Ejemplos de CTEs en Retail y Banca\n\n### Ejemplo en Retail: Filtrar Productos por Precio Promedio\n\nSupongamos que queremos crear una subconsulta que filtre productos con un precio mayor al promedio y luego usar esta subconsulta en la consulta principal.\n\nWITH filtered\\_products AS (  \n  SELECT nombre\\_producto, precio  \n  FROM productos  \n  WHERE precio \\> (SELECT AVG(precio) FROM productos)  \n)  \nSELECT nombre\\_producto, precio  \nFROM filtered\\_products;\n\nEn este ejemplo, la CTE `filtered_products` selecciona los productos cuyo precio es mayor que el precio promedio de todos los productos. Luego, la consulta principal selecciona todos los productos de la CTE.\n\n### Ejemplo en Banca: Filtrar Cuentas por Saldo Promedio\n\nQueremos crear una subconsulta que filtre cuentas con un saldo mayor al promedio y luego usar esta subconsulta en la consulta principal.\n\nWITH filtered\\_accounts AS (  \n  SELECT numero\\_cuenta, saldo  \n  FROM cuentas\\_bancarias  \n  WHERE saldo \\> (SELECT AVG(saldo) FROM cuentas\\_bancarias)  \n)  \nSELECT numero\\_cuenta, saldo  \nFROM filtered\\_accounts;\n\nEn este ejemplo, la CTE `filtered_accounts` selecciona las cuentas cuyo saldo es mayor que el saldo promedio de todas las cuentas bancarias. Luego, la consulta principal selecciona todas las cuentas de la CTE.\n\n### Ejemplo en Retail: Productos por Categoría con Precio Promedio\n\nQueremos obtener el precio promedio de los productos por cada categoría y mostrarlo junto con el nombre del producto y su precio.\n\nWITH category\\_averages AS (  \n  SELECT categoria\\_id, AVG(precio) AS precio\\_promedio  \n  FROM productos  \n  GROUP BY categoria\\_id  \n)  \nSELECT p.nombre\\_producto, p.precio, ca.precio\\_promedio  \nFROM productos p  \nJOIN category\\_averages ca ON p.categoria\\_id \\= ca.categoria\\_id;\n\nEn este ejemplo, la CTE `category_averages` calcula el precio promedio de los productos por categoría. Luego, la consulta principal une los productos con los precios promedio por categoría.\n\n### Ejemplo en Banca: Saldos Promedios por Tipo de Cuenta\n\nQueremos obtener el saldo promedio de las cuentas por cada tipo de cuenta y mostrarlo junto con el número de cuenta y su saldo.\n\nWITH account\\_type\\_averages AS (  \n  SELECT tipo\\_cuenta, AVG(saldo) AS saldo\\_promedio  \n  FROM cuentas\\_bancarias  \n  GROUP BY tipo\\_cuenta  \n)  \nSELECT c.numero\\_cuenta, c.saldo, ata.saldo\\_promedio  \nFROM cuentas\\_bancarias c  \nJOIN account\\_type\\_averages ata ON c.tipo\\_cuenta \\= ata.tipo\\_cuenta;\n\nEn este ejemplo, la CTE `account_type_averages` calcula el saldo promedio de las cuentas por tipo de cuenta. Luego, la consulta principal une las cuentas bancarias con los saldos promedio por tipo de cuenta.\n\n### Ejemplo en Retail: Productos con Ventas Totales\n\nQueremos calcular el total de ventas por producto y mostrarlo junto con el nombre del producto.\n\nWITH total\\_sales AS (  \n  SELECT producto\\_id, SUM(cantidad \\* precio) AS ventas\\_totales  \n  FROM ventas  \n  GROUP BY producto\\_id  \n)  \nSELECT p.nombre\\_producto, ts.ventas\\_totales  \nFROM productos p  \nJOIN total\\_sales ts ON p.producto\\_id \\= ts.producto\\_id;\n\nEn este ejemplo, la CTE `total_sales` calcula el total de ventas por producto. Luego, la consulta principal une los productos con sus ventas totales.\n\n### Ejemplo en Banca: Cuentas con Transacciones Recientes\n\nQueremos obtener las cuentas que han tenido transacciones en el último mes y mostrar el número de cuenta junto con el saldo.\n\nWITH recent\\_transactions AS (  \n  SELECT DISTINCT numero\\_cuenta  \n  FROM transacciones  \n  WHERE fecha \\> CURRENT\\_DATE \\- INTERVAL '1 month'  \n)  \nSELECT c.numero\\_cuenta, c.saldo  \nFROM cuentas\\_bancarias c  \nJOIN recent\\_transactions rt ON c.numero\\_cuenta \\= rt.numero\\_cuenta;\n\nEn este ejemplo, la CTE `recent_transactions` selecciona las cuentas que han tenido transacciones en el último mes. Luego, la consulta principal une estas cuentas con su saldo.\n\n### Conclusión\n\nLas CTEs son una herramienta esencial en PostgreSQL para realizar subconsultas de manera eficiente y legible. Al entender cómo y cuándo utilizar CTEs, podemos optimizar el rendimiento de nuestras bases de datos y obtener resultados más precisos. Ya sea en el sector retail o en la banca, las CTEs pueden ayudarnos a extraer información valiosa y tomar decisiones informadas.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [August 3, 2024](https://medium.com/p/a60c8ae0780a).\n\n[Canonical link](https://medium.com/@devjaime/construyendo-subconsultas-eficientes-en-postgresql-con-ctes-ejemplos-en-retail-y-banca-a60c8ae0780a)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"construyendo-subconsultas-eficientes-en-postgresql-con-ctes-ejemplos-en-retail-y-banca","text":"Construyendo Subconsultas Eficientes en PostgreSQL con CTEs: Ejemplos en Retail y Banca"},{"depth":3,"slug":"construyendo-subconsultas-eficientes-en-postgresql-con-ctes-ejemplos-en-retail-ybanca","text":"Construyendo Subconsultas Eficientes en PostgreSQL con CTEs: Ejemplos en Retail y Banca"},{"depth":3,"slug":"qué-son-lasctes","text":"¿Qué son las CTEs?"},{"depth":3,"slug":"ventajas-de-lasctes","text":"Ventajas de las CTEs"},{"depth":3,"slug":"ejemplos-de-ctes-en-retail-ybanca","text":"Ejemplos de CTEs en Retail y Banca"},{"depth":3,"slug":"ejemplo-en-retail-filtrar-productos-por-preciopromedio","text":"Ejemplo en Retail: Filtrar Productos por Precio Promedio"},{"depth":3,"slug":"ejemplo-en-banca-filtrar-cuentas-por-saldopromedio","text":"Ejemplo en Banca: Filtrar Cuentas por Saldo Promedio"},{"depth":3,"slug":"ejemplo-en-retail-productos-por-categoría-con-preciopromedio","text":"Ejemplo en Retail: Productos por Categoría con Precio Promedio"},{"depth":3,"slug":"ejemplo-en-banca-saldos-promedios-por-tipo-decuenta","text":"Ejemplo en Banca: Saldos Promedios por Tipo de Cuenta"},{"depth":3,"slug":"ejemplo-en-retail-productos-con-ventastotales","text":"Ejemplo en Retail: Productos con Ventas Totales"},{"depth":3,"slug":"ejemplo-en-banca-cuentas-con-transacciones-recientes","text":"Ejemplo en Banca: Cuentas con Transacciones Recientes"},{"depth":3,"slug":"conclusión","text":"Conclusión"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
