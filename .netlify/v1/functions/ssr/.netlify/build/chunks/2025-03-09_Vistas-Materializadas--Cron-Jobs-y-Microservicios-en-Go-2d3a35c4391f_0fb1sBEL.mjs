/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"vistas-materializadas-cron-jobs-y-microservicios-en-go\">Vistas Materializadas, Cron Jobs y Microservicios en Go</h1>\n<p>Las vistas materializadas son una herramienta poderosa en bases de datos relacionales, especialmente en PostgreSQL, para mejorar elâ€¦</p>\n<hr>\n<h3 id=\"vistas-materializadas-cron-jobs-y-microservicios-engo\">Vistas Materializadas, Cron Jobs y Microservicios enÂ Go</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*mxCxErqTczpxdscXzihOuQ.png\" alt=\"\"></p>\n<blockquote>\n<p>Las <strong>vistas materializadas</strong> son una herramienta poderosa en bases de datos relacionales, especialmente en <strong>PostgreSQL</strong>, para mejorar el rendimiento de consultas en sistemas con grandes volÃºmenes de datos. Sin embargo, para mantenerlas actualizadas, es necesario contar con un mecanismo de <strong>actualizaciÃ³n periÃ³dica</strong>, como un <strong>cron job</strong> o una <strong>Cloud Function</strong>.</p>\n</blockquote>\n<p>En este blog, exploraremos cÃ³mo integrar <strong>vistas materializadas</strong> con <strong>microservicios en Go</strong>, utilizando <strong>cron jobs</strong> en Kubernetes o <strong>Cloud Functions</strong> en GCP/AWS para refrescarlas automÃ¡ticamente.</p>\n<h3 id=\"1-quÃ©-es-una-vista-materializada\">1. Â¿QuÃ© es una Vista Materializada?</h3>\n<p>Una vista materializada es similar a una vista normal, pero los datos se almacenan fÃ­sicamente en la base de datos. Esto permite mejorar la velocidad de consultas a cambio de requerir actualizaciones periÃ³dicas para reflejar los cambios en los datos originales.</p>\n<p><strong>Ejemplo de creaciÃ³n en PostgreSQL:</strong></p>\n<p>CREATE MATERIALIZED VIEW ventas_diarias AS<br>\nSELECT fecha, SUM(monto) AS total_ventas<br>\nFROM transacciones<br>\nGROUP BY fecha;</p>\n<p>Para actualizar esta vista:</p>\n<p>REFRESH MATERIALIZED VIEW ventas_diarias;</p>\n<h3 id=\"2-actualizaciÃ³n-con-un-microservicio-engo\">2. ActualizaciÃ³n con un Microservicio enÂ Go</h3>\n<p>Podemos usar <strong>pgx</strong> para ejecutar la actualizaciÃ³n desde un servicio en <strong>Go</strong>.</p>\n<h3 id=\"21-configuraciÃ³n-del-cliente-postgresql\">2.1 ConfiguraciÃ³n del Cliente PostgreSQL</h3>\n<p>Instalamos el driver:</p>\n<p>go get github.com/jackc/pgx/v5</p>\n<p>CÃ³digo en Go para actualizar la vista:</p>\n<p>package main<br>\nimport (<br>\nâ€œcontext\"<br>\n\"fmt\"<br>\n\"log\"<br>\n\"time\"<br>\n\"github.com/jackc/pgx/v5/pgxpoolâ€<br>\n)<br>\nconst dbURL = â€œpostgres://user:password@host:5432/dbnameâ€<br>\nfunc refreshMaterializedView(db *pgxpool.Pool) {<br>\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)<br>\ndefer cancel()<br>\n_, err := db.Exec(ctx, â€œREFRESH MATERIALIZED VIEW ventas_diarias;â€œ)<br>\nif err != nil {<br>\nlog.Fatalf(â€œError actualizando vista: %vâ€, err)<br>\n}<br>\nfmt.Println(â€œVista materializada actualizada correctamenteâ€)<br>\n}<br>\nfunc main() {<br>\ndb, err := pgxpool.New(context.Background(), dbURL)<br>\nif err != nil {<br>\nlog.Fatalf(â€œNo se pudo conectar a la base de datos: %vâ€, err)<br>\n}<br>\ndefer db.Close()<br>\nrefreshMaterializedView(db)<br>\n}</p>\n<p>3. AutomatizaciÃ³n con un Cron Job en Kubernetes</p>\n<p>Si usamos Kubernetes, podemos definir un <strong>CronJob</strong> que ejecute nuestro microservicio periÃ³dicamente:</p>\n<p>apiVersion: batch/v1<br>\nkind: CronJob<br>\nmetadata:<br>\nname: refrescar-vista<br>\nspec:<br>\nschedule: â€œ0 * * * *â€ # Cada hora<br>\njobTemplate:<br>\nspec:<br>\ntemplate:<br>\nspec:<br>\ncontainers:<br>\n- name: refrescar-vista<br>\nimage: mi-registro/miservicio:latest<br>\ncommand: [â€œ/app/mainâ€]<br>\nrestartPolicy: OnFailure</p>\n<h3 id=\"4-alternativa-con-cloud-functions-engcp\">4. Alternativa con Cloud Functions enÂ GCP</h3>\n<p>Podemos usar una <strong>Cloud Function</strong> en <strong>Go</strong> que se ejecute con Cloud Scheduler:</p>\n<h3 id=\"41-cÃ³digo-para-la-cloudfunction\">4.1 CÃ³digo para la CloudÂ Function</h3>\n<p>package refrescarvista<br>\nimport (<br>\nâ€œcontext\"<br>\n\"database/sql\"<br>\n\"log\"<br>\n\"net/httpâ€<br>\n_ â€œgithub.com/lib/pqâ€<br>\n)<br>\nconst dbURL = â€œpostgres://user:password@host:5432/dbnameâ€<br>\nfunc RefreshView(w http.ResponseWriter, r *http.Request) {<br>\ndb, err := sql.Open(â€œpostgresâ€, dbURL)<br>\nif err != nil {<br>\nhttp.Error(w, â€œError conectando a la BDâ€, http.StatusInternalServerError)<br>\nreturn<br>\n}<br>\ndefer db.Close()<br>\n_, err = db.Exec(â€œREFRESH MATERIALIZED VIEW ventas_diarias;â€œ)<br>\nif err != nil {<br>\nhttp.Error(w, â€œError actualizando vistaâ€, http.StatusInternalServerError)<br>\nreturn<br>\n}<br>\nw.Write([]byte(â€œVista actualizadaâ€))<br>\n}</p>\n<h3 id=\"42-programaciÃ³n-con-cloud-scheduler\">4.2 ProgramaciÃ³n con Cloud Scheduler</h3>\n<p>Podemos crear una tarea en <strong>Cloud Scheduler</strong> para ejecutar esta funciÃ³n periÃ³dicamente:</p>\n<p>gcloud scheduler jobs create http refrescar-vista \\<br>\nâ€”schedule=â€œ0 * * * *â€ \\<br>\nâ€”uri=â€œ<a href=\"https://REGION-PROJECT%5C_ID.cloudfunctions.net/refrescarvista\">https://REGION-PROJECT\\_ID.cloudfunctions.net/refrescarvista</a>â€ \\<br>\nâ€”http-method=GET</p>\n<h3 id=\"5-conclusiÃ³n\">5. ConclusiÃ³n</h3>\n<p>Las vistas materializadas son una excelente opciÃ³n para mejorar el rendimiento de consultas en bases de datos relacionales. En este blog, vimos cÃ³mo integrarlas con <strong>Go</strong> usando:</p>\n<ul>\n<li>Un <strong>microservicio en Go</strong> para actualizar la vista.</li>\n<li>Un <strong>CronJob en Kubernetes</strong> para automatizar la tarea.</li>\n<li>Una <strong>Cloud Function en GCP</strong> con <strong>Cloud Scheduler</strong> como alternativa serverless.</li>\n</ul>\n<p>Esto permite una arquitectura flexible y escalable para manejar grandes volÃºmenes de datos de manera eficiente. ğŸš€</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime HernÃ¡ndez</a> on <a href=\"https://medium.com/p/2d3a35c4391f\">March 9, 2025</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/vistas-materializadas-cron-jobs-y-microservicios-en-go-2d3a35c4391f\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Vistas Materializadas, Cron Jobs y Microservicios en Go","description":"","tags":["code","Go","Vistas Materializadas","CronJob","microservicios"],"time":4,"featured":true,"timestamp":"2025-03-09T12:20:33-0300","filename":"2025-03-09_Vistas-Materializadas--Cron-Jobs-y-Microservicios-en-Go-2d3a35c4391f"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2025-03-09_Vistas-Materializadas--Cron-Jobs-y-Microservicios-en-Go-2d3a35c4391f.md";
				const url = "/blog/2025-03-09_Vistas-Materializadas--Cron-Jobs-y-Microservicios-en-Go-2d3a35c4391f";
				function rawContent() {
					return "   \n                                        \n                                                                \n               \n                                                                          \n       \n              \n                                     \n                                                                                           \n   \n\nVistas Materializadas, Cron Jobs y Microservicios en Go\n=======================================================\n\nLas vistas materializadas son una herramienta poderosa en bases de datos relacionales, especialmente en PostgreSQL, para mejorar elâ€¦\n\n* * *\n\n### Vistas Materializadas, Cron Jobs y Microservicios enÂ Go\n\n![](https://cdn-images-1.medium.com/max/800/1*mxCxErqTczpxdscXzihOuQ.png)\n\n> Las **vistas materializadas** son una herramienta poderosa en bases de datos relacionales, especialmente en **PostgreSQL**, para mejorar el rendimiento de consultas en sistemas con grandes volÃºmenes de datos. Sin embargo, para mantenerlas actualizadas, es necesario contar con un mecanismo de **actualizaciÃ³n periÃ³dica**, como un **cron job** o una **Cloud Function**.\n\nEn este blog, exploraremos cÃ³mo integrar **vistas materializadas** con **microservicios en Go**, utilizando **cron jobs** en Kubernetes o **Cloud Functions** en GCP/AWS para refrescarlas automÃ¡ticamente.\n\n### 1\\. Â¿QuÃ© es una Vista Materializada?\n\nUna vista materializada es similar a una vista normal, pero los datos se almacenan fÃ­sicamente en la base de datos. Esto permite mejorar la velocidad de consultas a cambio de requerir actualizaciones periÃ³dicas para reflejar los cambios en los datos originales.\n\n**Ejemplo de creaciÃ³n en PostgreSQL:**\n\nCREATE MATERIALIZED VIEW ventas\\_diarias AS  \nSELECT fecha, SUM(monto) AS total\\_ventas  \nFROM transacciones  \nGROUP BY fecha;\n\nPara actualizar esta vista:\n\nREFRESH MATERIALIZED VIEW ventas\\_diarias;\n\n### 2\\. ActualizaciÃ³n con un Microservicio enÂ Go\n\nPodemos usar **pgx** para ejecutar la actualizaciÃ³n desde un servicio en **Go**.\n\n### 2.1 ConfiguraciÃ³n del Cliente PostgreSQL\n\nInstalamos el driver:\n\ngo get github.com/jackc/pgx/v5\n\nCÃ³digo en Go para actualizar la vista:\n\npackage main  \nimport (  \n \"context\"  \n \"fmt\"  \n \"log\"  \n \"time\"  \n \"github.com/jackc/pgx/v5/pgxpool\"  \n)  \nconst dbURL = \"postgres://user:password@host:5432/dbname\"  \nfunc refreshMaterializedView(db \\*pgxpool.Pool) {  \n ctx, cancel := context.WithTimeout(context.Background(), 5\\*time.Second)  \n defer cancel()  \n \\_, err := db.Exec(ctx, \"REFRESH MATERIALIZED VIEW ventas\\_diarias;\")  \n if err != nil {  \n  log.Fatalf(\"Error actualizando vista: %v\", err)  \n }  \n fmt.Println(\"Vista materializada actualizada correctamente\")  \n}  \nfunc main() {  \n db, err := pgxpool.New(context.Background(), dbURL)  \n if err != nil {  \n  log.Fatalf(\"No se pudo conectar a la base de datos: %v\", err)  \n }  \n defer db.Close()  \n refreshMaterializedView(db)  \n}\n\n3\\. AutomatizaciÃ³n con un Cron Job en Kubernetes\n\nSi usamos Kubernetes, podemos definir un **CronJob** que ejecute nuestro microservicio periÃ³dicamente:\n\napiVersion: batch/v1  \nkind: CronJob  \nmetadata:  \n  name: refrescar-vista  \nspec:  \n  schedule: \"0 \\* \\* \\* \\*\" \\# Cada hora  \n  jobTemplate:  \n    spec:  \n      template:  \n        spec:  \n          containers:  \n          \\- name: refrescar-vista  \n            image: mi-registro/miservicio:latest  \n            command: \\[\"/app/main\"\\]  \n          restartPolicy: OnFailure\n\n### 4\\. Alternativa con Cloud Functions enÂ GCP\n\nPodemos usar una **Cloud Function** en **Go** que se ejecute con Cloud Scheduler:\n\n### 4.1 CÃ³digo para la CloudÂ Function\n\npackage refrescarvista  \nimport (  \n \"context\"  \n \"database/sql\"  \n \"log\"  \n \"net/http\"  \n \\_ \"github.com/lib/pq\"  \n)  \nconst dbURL = \"postgres://user:password@host:5432/dbname\"  \nfunc RefreshView(w http.ResponseWriter, r \\*http.Request) {  \n db, err := sql.Open(\"postgres\", dbURL)  \n if err != nil {  \n  http.Error(w, \"Error conectando a la BD\", http.StatusInternalServerError)  \n  return  \n }  \n defer db.Close()  \n \\_, err = db.Exec(\"REFRESH MATERIALIZED VIEW ventas\\_diarias;\")  \n if err != nil {  \n  http.Error(w, \"Error actualizando vista\", http.StatusInternalServerError)  \n  return  \n }  \n w.Write(\\[\\]byte(\"Vista actualizada\"))  \n}\n\n### 4.2 ProgramaciÃ³n con Cloud Scheduler\n\nPodemos crear una tarea en **Cloud Scheduler** para ejecutar esta funciÃ³n periÃ³dicamente:\n\ngcloud scheduler jobs create http refrescar-vista \\\\  \n    \\--schedule=\"0 \\* \\* \\* \\*\" \\\\  \n    \\--uri=\"https://REGION-PROJECT\\_ID.cloudfunctions.net/refrescarvista\" \\\\  \n    \\--http-method=GET\n\n### 5\\. ConclusiÃ³n\n\nLas vistas materializadas son una excelente opciÃ³n para mejorar el rendimiento de consultas en bases de datos relacionales. En este blog, vimos cÃ³mo integrarlas con **Go** usando:\n\n*   Un **microservicio en Go** para actualizar la vista.\n*   Un **CronJob en Kubernetes** para automatizar la tarea.\n*   Una **Cloud Function en GCP** con **Cloud Scheduler** como alternativa serverless.\n\nEsto permite una arquitectura flexible y escalable para manejar grandes volÃºmenes de datos de manera eficiente. ğŸš€\n\nBy [Jaime HernÃ¡ndez](https://medium.com/@devjaime) on [March 9, 2025](https://medium.com/p/2d3a35c4391f).\n\n[Canonical link](https://medium.com/@devjaime/vistas-materializadas-cron-jobs-y-microservicios-en-go-2d3a35c4391f)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"vistas-materializadas-cron-jobs-y-microservicios-en-go","text":"Vistas Materializadas, Cron Jobs y Microservicios en Go"},{"depth":3,"slug":"vistas-materializadas-cron-jobs-y-microservicios-engo","text":"Vistas Materializadas, Cron Jobs y Microservicios enÂ Go"},{"depth":3,"slug":"1-quÃ©-es-una-vista-materializada","text":"1. Â¿QuÃ© es una Vista Materializada?"},{"depth":3,"slug":"2-actualizaciÃ³n-con-un-microservicio-engo","text":"2. ActualizaciÃ³n con un Microservicio enÂ Go"},{"depth":3,"slug":"21-configuraciÃ³n-del-cliente-postgresql","text":"2.1 ConfiguraciÃ³n del Cliente PostgreSQL"},{"depth":3,"slug":"4-alternativa-con-cloud-functions-engcp","text":"4. Alternativa con Cloud Functions enÂ GCP"},{"depth":3,"slug":"41-cÃ³digo-para-la-cloudfunction","text":"4.1 CÃ³digo para la CloudÂ Function"},{"depth":3,"slug":"42-programaciÃ³n-con-cloud-scheduler","text":"4.2 ProgramaciÃ³n con Cloud Scheduler"},{"depth":3,"slug":"5-conclusiÃ³n","text":"5. ConclusiÃ³n"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
