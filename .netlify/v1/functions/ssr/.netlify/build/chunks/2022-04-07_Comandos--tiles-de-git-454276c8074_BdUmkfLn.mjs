/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"comandos-√∫tiles-de-git\">Comandos √∫tiles de git</h1>\n<p>Fusi√≥n‚Ää‚Äî‚ÄäMerge</p>\n<hr>\n<h3 id=\"comandos-√∫tiles-degit\">Comandos √∫tiles de¬†git</h3>\n<h3 id=\"fusi√≥nmerge\">Fusi√≥n‚Ää‚Äî‚ÄäMerge</h3>\n<p>Tener m√∫ltiples ramas (branches) es extremadamente conveniente para mantener los cambios nuevos separados entre s√≠ y para asegurarse de que no env√≠es accidentalmente cambios no aprobados o incompletos a producci√≥n. Una vez que se hayan aprobado los cambios, ¬°queremos recibir estos cambios en nuestra rama de producci√≥n!</p>\n<p>Una forma de obtener los cambios de una rama generalmente se realiza un<code>git merge</code>! Hay dos tipos de fusiones que Git puede realizar: un <strong>avance r√°pido</strong> o un <strong>avance sin avance r√°pido.</strong></p>\n<p>Es posible que esto no tenga mucho sentido en este momento, ¬°as√≠ que veamos las diferencias!</p>\n<h3 id=\"avance-r√°pido----ff-fast-forward\">Avance r√°pido ( <code>--ff</code>) Fast-forward</h3>\n<p>Una <strong>fusi√≥n de avance r√°pido</strong> puede ocurrir cuando la rama actual no tiene confirmaciones adicionales en comparaci√≥n con la rama que estamos fusionando.</p>\n<p>Git es‚Ä¶ <em>perezoso</em> y primero intentar√° realizar la opci√≥n m√°s f√°cil: ¬°el avance r√°pido! Este tipo de fusi√≥n no crea una nueva confirmaci√≥n, sino que fusiona las confirmaciones en la rama que estamos fusionando directamente en la rama actual</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*5mQ6R7QEMu3dSMnS.gif\" alt=\"\"></p>\n<p>¬°Perfecto! Ahora tenemos todos los cambios que se hicieron en la rama disponibles en la rama master. Entonces, ¬øde qu√© se trata el <strong>avance r√°pido</strong>¬†?</p>\n<h3 id=\"sin-avance-r√°pido----no-ff-no-fast-foward\">Sin avance r√°pido ( <code>--no-ff</code>) No-fast-foward</h3>\n<p>Es genial si tu rama actual no tiene confirmaciones adicionales en comparaci√≥n con la rama que desea fusionar, ¬°pero desafortunadamente ese rara vez es el caso! y no podr√°s hacer Fast-forward o avance r√°pido.</p>\n<p>Si realizamos cambios en la rama actual y la rama que deseamos fusionar no los tienes, git realizar√° una fusi√≥n <em>sin avance r√°pido</em>¬†.</p>\n<p>Con una fusi√≥n sin avance r√°pido, Git crea una nueva <em>confirmaci√≥n de fusi√≥n</em> en la rama activa. ¬°Las confirmaciones principales de la confirmaci√≥n apuntan tanto a la rama activa como a la rama que queremos fusionar!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*OOQzhyFY4Qpcosxl.gif\" alt=\"\"></p>\n<p>No es gran cosa, ¬°una combinaci√≥n perfecta! La rama<code>master</code>ahora contiene todos los cambios que hemos hecho en la rama<code>dev</code>.</p>\n<h3 id=\"fusionar-conflictos\">Fusionar conflictos</h3>\n<p>Aunque Git es bueno para decidir c√≥mo fusionar ramas y agregar cambios a los archivos, no siempre puede tomar esta decisi√≥n por s√≠ mismo üôÇ Esto puede suceder cuando las dos ramas que intentamos fusionar tienen cambios en la misma l√≠nea en el mismo archivo, o si una rama elimin√≥ un archivo que otra rama modific√≥, y as√≠ sucesivamente.</p>\n<p>En ese caso, Git te pedir√° que ayudes a decidir cu√°l de las dos opciones queremos conservar. Digamos que en ambas ramas, editamos la primera l√≠nea en el archivo <code>README.md</code>.</p>\n<p>Si queremos fusionarnos la rama<code>dev</code>con la rama<code>master</code>, esto terminar√° en un conflicto de fusi√≥n: y preguntara ¬øle gustar√≠a que se conservara la linea de la rama dev o la rama master?</p>\n<p>Cuando intente fusionar las ramas, Git le mostrar√° d√≥nde ocurre el conflicto. Podemos eliminar manualmente los cambios que no queremos conservar, guardar los cambios, agregar el archivo modificado nuevamente y confirmar los cambios.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*-_YzzD3RmyC9_D8P.gif\" alt=\"\"></p>\n<p>Aunque los conflictos de fusi√≥n suelen ser bastante molestos, tiene mucho sentido: Git no deber√≠a simplemente <em>asumir</em> qu√© cambio queremos conservar.</p>\n<h3 id=\"rebase\">rebase</h3>\n<p>Acabamos de ver c√≥mo pod√≠amos aplicar cambios de una rama a otra realizando un <code>git merge</code>. Otra forma de agregar cambios de una rama a otra es realizando un <code>git rebase</code>.</p>\n<p>A <code>git rebase</code> <em>copia</em> las confirmaciones de la rama actual y coloca estas confirmaciones copiadas encima de la rama especificada.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*YcYoCIP1OJdx585y.gif\" alt=\"\"></p>\n<p>Perfecto, ya tenemos todos los cambios que se hicieron en la rama<code>master</code> disponibles en la rama<code>dev</code>!</p>\n<p>Una gran diferencia en comparaci√≥n con la ‚Äúmerge‚Äù es que Git no intentar√° averiguar qu√© archivos conservar y no conservar. ¬°La rama que estamos reorganizando siempre tiene los √∫ltimos cambios que queremos conservar! No te encontrar√°s con ning√∫n conflicto de fusi√≥n de esta manera, y mantiene un buen historial lineal de Git.</p>\n<p>Este ejemplo muestra el cambio de base en la rama<code>master</code>. Sin embargo, en proyectos m√°s grandes, por lo general no desea hacer eso. ¬°¬†A <code>git rebase</code> <strong>cambia el historial del proyecto</strong> a medida que se crean nuevos hashes para las confirmaciones copiadas!</p>\n<p>El cambio de base es excelente siempre que est√© trabajando en una rama de caracter√≠sticas y la rama principal se haya actualizado. ¬°Puede obtener todas las actualizaciones en su rama, lo que evitar√≠a futuros conflictos de fusi√≥n!</p>\n<h3 id=\"rebase-interactivo\">Rebase interactivo</h3>\n<p>¬°Antes de reorganizar los commits, podemos modificarlos! üòÉ Podemos hacerlo con un <em>rebase interactivo</em>¬†. Una reorganizaci√≥n interactiva tambi√©n puede ser √∫til en la rama en la que est√° trabajando actualmente y desea modificar algunas confirmaciones.</p>\n<p>Hay 6 acciones que podemos realizar en las confirmaciones que estamos reorganizando:</p>\n<ul>\n<li><code>reword</code>: Cambiar el mensaje de confirmaci√≥n</li>\n<li><code>edit</code>: Modificar este compromiso</li>\n<li><code>squash</code>: fusionar la confirmaci√≥n con la confirmaci√≥n anterior</li>\n<li><code>fixup</code>: fusionar la confirmaci√≥n con la confirmaci√≥n anterior, sin conservar el mensaje de registro de la confirmaci√≥n</li>\n<li><code>exec</code>: Ejecutar un comando en cada confirmaci√≥n que queremos reorganizar</li>\n<li><code>drop</code>: Eliminar la confirmaci√≥n</li>\n</ul>\n<p>¬°Incre√≠ble! De esta manera, podemos tener control total sobre nuestras confirmaciones. Si queremos eliminar un compromiso, podemos simplemente hacerlo con el comando drop.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*Ihm5TYCT9wYLhjjV.gif\" alt=\"\"></p>\n<p>O si queremos juntar varias confirmaciones para obtener un historial m√°s limpio, ¬°no hay problema!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*5ylV4OfCIQ_Lobev.gif\" alt=\"\"></p>\n<h3 id=\"resettingrestablecer\">Resetting‚Ää‚Äî‚ÄäRestablecer</h3>\n<p>Puede suceder que cometamos cambios que no quer√≠amos m√°s adelante. ¬°¬†Tal vez sea un compromiso<code>WIP</code>, o tal vez un compromiso que introdujo errores! üêõ En ese caso, podemos realizar un <code>git reset</code>.</p>\n<p>A <code>git reset</code>se deshace de todos los archivos provisionales actuales y nos da control sobre d√≥nde <code>HEAD</code>deber√≠a apuntar.</p>\n<h3 id=\"soft-resetreiniciosuave\">Soft reset‚Ää‚Äî‚ÄäReinicio¬†suave</h3>\n<p>¬°¬†Un <em>restablecimiento parcial</em> se mueve <code>HEAD</code>a la confirmaci√≥n especificada (o el √≠ndice de la confirmaci√≥n en comparaci√≥n con <code>HEAD</code>), sin deshacerse de los cambios que se introdujeron en las confirmaciones despu√©s!</p>\n<p>Digamos que no queremos conservar la confirmaci√≥n <code>9e78i</code>que agreg√≥ un archivo <code>style.css</code>, y tampoco queremos conservar la confirmaci√≥n <code>035cc</code>que agreg√≥ un archivo<code>index.js</code>.</p>\n<p>El archivo<code>style.css</code>Sin embargo, ¬°¬†queremos mantener el <code>index.js</code> reci√©n agregado! Un caso de uso perfecto para un restablecimiento parcial.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*aUw-pT5frZU8cACI.gif\" alt=\"\"></p>\n<p>Al escribir <code>git status</code>, ver√°s que a√∫n tenemos acceso a todos los cambios que se realizaron en las confirmaciones anteriores. ¬°Esto es genial, ya que significa que podemos corregir el contenido de estos archivos y enviarlos nuevamente m√°s adelante!</p>\n<h3 id=\"hard-resetrestablecimiento-completo\">Hard reset‚Ää‚Äî‚ÄäRestablecimiento completo</h3>\n<p>A veces, no queremos conservar los cambios introducidos por ciertas confirmaciones. A diferencia de un restablecimiento parcial, ya no deber√≠amos necesitar tener acceso a ellos. Git simplemente deber√≠a restablecer su estado a donde estaba en la confirmaci√≥n especificada: ¬°esto incluso incluye los cambios en su directorio de trabajo y archivos preparados!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*i5obHkYWz8YroHGv.gif\" alt=\"\"></p>\n<p>Git ha descartado los cambios que se introdujeron en <code>9e78i</code>y <code>035cc</code>y ha restablecido su estado a donde estaba en el commit<code>ec5be</code>.</p>\n<hr>\n<h3 id=\"revertrevirtiendo\">revert‚Ää‚Äî‚Äärevirtiendo</h3>\n<p>Otra forma de deshacer los cambios es realizando un <code>git revert</code>. ¬°Al revertir una determinada confirmaci√≥n, creamos una <em>nueva confirmaci√≥n</em> que contiene los cambios revertidos!</p>\n<p>Digamos que <code>ec5be</code>agreg√≥ un archivo<code>index.js</code>. ¬°M√°s tarde, nos damos cuenta de que ya no quer√≠amos que este cambio se introdujera por este compromiso! Vamos a revertir el commit<code>ec5be</code>.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*8sSA3q5f9un3TFrw.gif\" alt=\"\"></p>\n<p>¬°Perfecto! La confirmaci√≥n <code>9e78i</code>revirti√≥ los cambios introducidos por el commit<code>ec5be</code>. Realizar un <code>git revert</code>es muy √∫til para deshacer un determinado compromiso, sin modificar el historial de la rama.</p>\n<h3 id=\"cherry-picking\">Cherry-picking</h3>\n<p>Cuando una determinada rama contiene un commit que introdujo los cambios que necesitamos en nuestra rama activa, ¬°podemos ejecutar <code>cherry-pick</code>!¬†.</p>\n<p><code>cherry-pick al</code>enviar una confirmaci√≥n, creamos una nueva confirmaci√≥n en nuestra rama activa que contiene los cambios que introdujo el commit<code>cherry-pick</code>.</p>\n<p>Digamos que el commit<code>76d12</code>en la rama<code>dev</code> agreg√≥ un cambio al archivo<code>index.js</code> que queremos en nuestra rama<code>master</code>. ¬°No queremos <em>todo</em>¬†, solo nos importa este √∫nico commit!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*h9Dzw1Ore-z4OYpU.gif\" alt=\"\"></p>\n<p>¬°¬†Genial, la rama maestra ahora contiene los cambios que se introdujeron en el commit<code>76d12</code>!</p>\n<h3 id=\"fetching\">Fetching</h3>\n<p>Si tenemos una rama remota de Git, por ejemplo, una rama en Github, ¬°puede suceder que la rama remota tenga commit que la rama actual no tiene! Tal vez se fusion√≥ otra rama, tu compa√±ero impuls√≥ una soluci√≥n r√°pida, y as√≠ sucesivamente.</p>\n<p>¬°Podemos obtener estos cambios localmente, realizando un <code>git fetch</code>en la rama remota! No afecta a tu rama local de ninguna manera: <code>fetch</code>simplemente descarga nuevos datos.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*p45hIZ9Vf94hww0j.gif\" alt=\"\"></p>\n<p>¬°Ahora podemos ver todos los cambios que se han realizado desde la √∫ltima vez que presionamos! Podemos decidir qu√© queremos hacer con los nuevos datos ahora que los tenemos localmente.</p>\n<h3 id=\"pulling\">Pulling</h3>\n<p>Aunque un <code>git fetch</code>es muy √∫til para obtener la informaci√≥n remota de una rama, tambi√©n podemos realizar un <code>git pull</code>.</p>\n<p><code>git pull</code>es en realidad dos comandos en uno: a <code>git fetch</code>y a <code>git merge</code>. Cuando extraemos cambios desde el origen, primero obtenemos todos los datos como lo hicimos con un <code>git fetch</code>, despu√©s de lo cual los cambios m√°s recientes se fusionan autom√°ticamente en la rama local.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*U8WnlxnOHUaEO_H0.gif\" alt=\"\"></p>\n<p>Impresionante, ahora estamos perfectamente sincronizados con la rama remota y tenemos todos los cambios m√°s recientes.</p>\n<hr>\n<h3 id=\"reflog\">Reflog</h3>\n<p>Todo el mundo comete errores, ¬°y eso est√° totalmente bien! A veces puede parecer que has estropeado tanto tu repositorio de git que solo quieres eliminarlo por completo.</p>\n<p><code>git reflog</code>es un comando muy √∫til para mostrar un registro de todas las acciones que se han realizado. Esto incluye fusiones, reinicios, reversiones: b√°sicamente cualquier alteraci√≥n en su rama.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*wEQ4XLAoLWJ203Ya.gif\" alt=\"\"></p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hern√°ndez</a> on <a href=\"https://medium.com/p/454276c8074\">April 7, 2022</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/comandos-%C3%BAtiles-de-git-454276c8074\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Comandos √∫tiles de git","description":"","tags":["code","git"],"time":4,"featured":true,"timestamp":"2022-04-07T12:20:31-0300","filename":"2022-04-07_Comandos--tiles-de-git-454276c8074"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2022-04-07_Comandos--tiles-de-git-454276c8074.md";
				const url = "/blog/2022-04-07_Comandos--tiles-de-git-454276c8074";
				function rawContent() {
					return "   \n                                        \n                               \n               \n                     \n       \n              \n                                     \n                                                         \n   \n\n\nComandos √∫tiles de git\n======================\n\nFusi√≥n‚Ää‚Äî‚ÄäMerge\n\n* * *\n\n### Comandos √∫tiles de¬†git\n\n### Fusi√≥n‚Ää‚Äî‚ÄäMerge\n\nTener m√∫ltiples ramas (branches) es extremadamente conveniente para mantener los cambios nuevos separados entre s√≠ y para asegurarse de que no env√≠es accidentalmente cambios no aprobados o incompletos a producci√≥n. Una vez que se hayan aprobado los cambios, ¬°queremos recibir estos cambios en nuestra rama de producci√≥n!\n\nUna forma de obtener los cambios de una rama generalmente se realiza un`git merge`! Hay dos tipos de fusiones que Git puede realizar: un **avance r√°pido** o un **avance sin avance r√°pido.**\n\nEs posible que esto no tenga mucho sentido en este momento, ¬°as√≠ que veamos las diferencias!\n\n### Avance r√°pido ( `--ff`) Fast-forward\n\nUna **fusi√≥n de avance r√°pido** puede ocurrir cuando la rama actual no tiene confirmaciones adicionales en comparaci√≥n con la rama que estamos fusionando.\n\nGit es‚Ä¶ _perezoso_ y primero intentar√° realizar la opci√≥n m√°s f√°cil: ¬°el avance r√°pido! Este tipo de fusi√≥n no crea una nueva confirmaci√≥n, sino que fusiona las confirmaciones en la rama que estamos fusionando directamente en la rama actual\n\n![](https://cdn-images-1.medium.com/max/800/0*5mQ6R7QEMu3dSMnS.gif)\n\n¬°Perfecto! Ahora tenemos todos los cambios que se hicieron en la rama disponibles en la rama master. Entonces, ¬øde qu√© se trata el **avance r√°pido**¬†?\n\n### Sin avance r√°pido ( `--no-ff`) No-fast-foward\n\nEs genial si tu rama actual no tiene confirmaciones adicionales en comparaci√≥n con la rama que desea fusionar, ¬°pero desafortunadamente ese rara vez es el caso! y no podr√°s hacer Fast-forward o avance r√°pido.\n\nSi realizamos cambios en la rama actual y la rama que deseamos fusionar no los tienes, git realizar√° una fusi√≥n _sin avance r√°pido_¬†.\n\nCon una fusi√≥n sin avance r√°pido, Git crea una nueva _confirmaci√≥n de fusi√≥n_ en la rama activa. ¬°Las confirmaciones principales de la confirmaci√≥n apuntan tanto a la rama activa como a la rama que queremos fusionar!\n\n![](https://cdn-images-1.medium.com/max/800/0*OOQzhyFY4Qpcosxl.gif)\n\nNo es gran cosa, ¬°una combinaci√≥n perfecta! La rama`master`ahora contiene todos los cambios que hemos hecho en la rama`dev`.\n\n### Fusionar conflictos\n\nAunque Git es bueno para decidir c√≥mo fusionar ramas y agregar cambios a los archivos, no siempre puede tomar esta decisi√≥n por s√≠ mismo üôÇ Esto puede suceder cuando las dos ramas que intentamos fusionar tienen cambios en la misma l√≠nea en el mismo archivo, o si una rama elimin√≥ un archivo que otra rama modific√≥, y as√≠ sucesivamente.\n\nEn ese caso, Git te pedir√° que ayudes a decidir cu√°l de las dos opciones queremos conservar. Digamos que en ambas ramas, editamos la primera l√≠nea en el archivo `README.md`.\n\nSi queremos fusionarnos la rama`dev`con la rama`master`, esto terminar√° en un conflicto de fusi√≥n: y preguntara ¬øle gustar√≠a que se conservara la linea de la rama dev o la rama master?\n\nCuando intente fusionar las ramas, Git le mostrar√° d√≥nde ocurre el conflicto. Podemos eliminar manualmente los cambios que no queremos conservar, guardar los cambios, agregar el archivo modificado nuevamente y confirmar los cambios.\n\n![](https://cdn-images-1.medium.com/max/800/0*-_YzzD3RmyC9_D8P.gif)\n\nAunque los conflictos de fusi√≥n suelen ser bastante molestos, tiene mucho sentido: Git no deber√≠a simplemente _asumir_ qu√© cambio queremos conservar.\n\n### rebase\n\nAcabamos de ver c√≥mo pod√≠amos aplicar cambios de una rama a otra realizando un `git merge`. Otra forma de agregar cambios de una rama a otra es realizando un `git rebase`.\n\nA `git rebase` _copia_ las confirmaciones de la rama actual y coloca estas confirmaciones copiadas encima de la rama especificada.\n\n![](https://cdn-images-1.medium.com/max/800/0*YcYoCIP1OJdx585y.gif)\n\nPerfecto, ya tenemos todos los cambios que se hicieron en la rama`master` disponibles en la rama`dev`!\n\nUna gran diferencia en comparaci√≥n con la ‚Äúmerge‚Äù es que Git no intentar√° averiguar qu√© archivos conservar y no conservar. ¬°La rama que estamos reorganizando siempre tiene los √∫ltimos cambios que queremos conservar! No te encontrar√°s con ning√∫n conflicto de fusi√≥n de esta manera, y mantiene un buen historial lineal de Git.\n\nEste ejemplo muestra el cambio de base en la rama`master`. Sin embargo, en proyectos m√°s grandes, por lo general no desea hacer eso. ¬°¬†A `git rebase` **cambia el historial del proyecto** a medida que se crean nuevos hashes para las confirmaciones copiadas!\n\nEl cambio de base es excelente siempre que est√© trabajando en una rama de caracter√≠sticas y la rama principal se haya actualizado. ¬°Puede obtener todas las actualizaciones en su rama, lo que evitar√≠a futuros conflictos de fusi√≥n!\n\n### Rebase interactivo\n\n¬°Antes de reorganizar los commits, podemos modificarlos! üòÉ Podemos hacerlo con un _rebase interactivo_¬†. Una reorganizaci√≥n interactiva tambi√©n puede ser √∫til en la rama en la que est√° trabajando actualmente y desea modificar algunas confirmaciones.\n\nHay 6 acciones que podemos realizar en las confirmaciones que estamos reorganizando:\n\n*   `reword`: Cambiar el mensaje de confirmaci√≥n\n*   `edit`: Modificar este compromiso\n*   `squash`: fusionar la confirmaci√≥n con la confirmaci√≥n anterior\n*   `fixup`: fusionar la confirmaci√≥n con la confirmaci√≥n anterior, sin conservar el mensaje de registro de la confirmaci√≥n\n*   `exec`: Ejecutar un comando en cada confirmaci√≥n que queremos reorganizar\n*   `drop`: Eliminar la confirmaci√≥n\n\n¬°Incre√≠ble! De esta manera, podemos tener control total sobre nuestras confirmaciones. Si queremos eliminar un compromiso, podemos simplemente hacerlo con el comando drop.\n\n![](https://cdn-images-1.medium.com/max/800/0*Ihm5TYCT9wYLhjjV.gif)\n\nO si queremos juntar varias confirmaciones para obtener un historial m√°s limpio, ¬°no hay problema!\n\n![](https://cdn-images-1.medium.com/max/800/0*5ylV4OfCIQ_Lobev.gif)\n\n### Resetting‚Ää‚Äî‚ÄäRestablecer\n\nPuede suceder que cometamos cambios que no quer√≠amos m√°s adelante. ¬°¬†Tal vez sea un compromiso`WIP`, o tal vez un compromiso que introdujo errores! üêõ En ese caso, podemos realizar un `git reset`.\n\nA `git reset`se deshace de todos los archivos provisionales actuales y nos da control sobre d√≥nde `HEAD`deber√≠a apuntar.\n\n### Soft reset‚Ää‚Äî‚ÄäReinicio¬†suave\n\n¬°¬†Un _restablecimiento parcial_ se mueve `HEAD`a la confirmaci√≥n especificada (o el √≠ndice de la confirmaci√≥n en comparaci√≥n con `HEAD`), sin deshacerse de los cambios que se introdujeron en las confirmaciones despu√©s!\n\nDigamos que no queremos conservar la confirmaci√≥n `9e78i`que agreg√≥ un archivo `style.css`, y tampoco queremos conservar la confirmaci√≥n `035cc`que agreg√≥ un archivo`index.js`.\n\nEl archivo`style.css`Sin embargo, ¬°¬†queremos mantener el `index.js` reci√©n agregado! Un caso de uso perfecto para un restablecimiento parcial.\n\n![](https://cdn-images-1.medium.com/max/800/0*aUw-pT5frZU8cACI.gif)\n\nAl escribir `git status`, ver√°s que a√∫n tenemos acceso a todos los cambios que se realizaron en las confirmaciones anteriores. ¬°Esto es genial, ya que significa que podemos corregir el contenido de estos archivos y enviarlos nuevamente m√°s adelante!\n\n### Hard reset‚Ää‚Äî‚ÄäRestablecimiento completo\n\nA veces, no queremos conservar los cambios introducidos por ciertas confirmaciones. A diferencia de un restablecimiento parcial, ya no deber√≠amos necesitar tener acceso a ellos. Git simplemente deber√≠a restablecer su estado a donde estaba en la confirmaci√≥n especificada: ¬°esto incluso incluye los cambios en su directorio de trabajo y archivos preparados!\n\n![](https://cdn-images-1.medium.com/max/800/0*i5obHkYWz8YroHGv.gif)\n\nGit ha descartado los cambios que se introdujeron en `9e78i`y `035cc`y ha restablecido su estado a donde estaba en el commit`ec5be`.\n\n* * *\n\n### revert‚Ää‚Äî‚Äärevirtiendo\n\nOtra forma de deshacer los cambios es realizando un `git revert`. ¬°Al revertir una determinada confirmaci√≥n, creamos una _nueva confirmaci√≥n_ que contiene los cambios revertidos!\n\nDigamos que `ec5be`agreg√≥ un archivo`index.js`. ¬°M√°s tarde, nos damos cuenta de que ya no quer√≠amos que este cambio se introdujera por este compromiso! Vamos a revertir el commit`ec5be`.\n\n![](https://cdn-images-1.medium.com/max/800/0*8sSA3q5f9un3TFrw.gif)\n\n¬°Perfecto! La confirmaci√≥n `9e78i`revirti√≥ los cambios introducidos por el commit`ec5be`. Realizar un `git revert`es muy √∫til para deshacer un determinado compromiso, sin modificar el historial de la rama.\n\n### Cherry-picking\n\nCuando una determinada rama contiene un commit que introdujo los cambios que necesitamos en nuestra rama activa, ¬°podemos ejecutar `cherry-pick`!¬†.\n\n`cherry-pick al`enviar una confirmaci√≥n, creamos una nueva confirmaci√≥n en nuestra rama activa que contiene los cambios que introdujo el commit`cherry-pick`.\n\nDigamos que el commit`76d12`en la rama`dev` agreg√≥ un cambio al archivo`index.js` que queremos en nuestra rama`master`. ¬°No queremos _todo_¬†, solo nos importa este √∫nico commit!\n\n![](https://cdn-images-1.medium.com/max/800/0*h9Dzw1Ore-z4OYpU.gif)\n\n¬°¬†Genial, la rama maestra ahora contiene los cambios que se introdujeron en el commit`76d12`!\n\n### Fetching\n\nSi tenemos una rama remota de Git, por ejemplo, una rama en Github, ¬°puede suceder que la rama remota tenga commit que la rama actual no tiene! Tal vez se fusion√≥ otra rama, tu compa√±ero impuls√≥ una soluci√≥n r√°pida, y as√≠ sucesivamente.\n\n¬°Podemos obtener estos cambios localmente, realizando un `git fetch`en la rama remota! No afecta a tu rama local de ninguna manera: `fetch`simplemente descarga nuevos datos.\n\n![](https://cdn-images-1.medium.com/max/800/0*p45hIZ9Vf94hww0j.gif)\n\n¬°Ahora podemos ver todos los cambios que se han realizado desde la √∫ltima vez que presionamos! Podemos decidir qu√© queremos hacer con los nuevos datos ahora que los tenemos localmente.\n\n### Pulling\n\nAunque un `git fetch`es muy √∫til para obtener la informaci√≥n remota de una rama, tambi√©n podemos realizar un `git pull`.\n\n`git pull`es en realidad dos comandos en uno: a `git fetch`y a `git merge`. Cuando extraemos cambios desde el origen, primero obtenemos todos los datos como lo hicimos con un `git fetch`, despu√©s de lo cual los cambios m√°s recientes se fusionan autom√°ticamente en la rama local.\n\n![](https://cdn-images-1.medium.com/max/800/0*U8WnlxnOHUaEO_H0.gif)\n\nImpresionante, ahora estamos perfectamente sincronizados con la rama remota y tenemos todos los cambios m√°s recientes.\n\n* * *\n\n### Reflog\n\nTodo el mundo comete errores, ¬°y eso est√° totalmente bien! A veces puede parecer que has estropeado tanto tu repositorio de git que solo quieres eliminarlo por completo.\n\n`git reflog`es un comando muy √∫til para mostrar un registro de todas las acciones que se han realizado. Esto incluye fusiones, reinicios, reversiones: b√°sicamente cualquier alteraci√≥n en su rama.\n\n![](https://cdn-images-1.medium.com/max/800/0*wEQ4XLAoLWJ203Ya.gif)\n\nBy [Jaime Hern√°ndez](https://medium.com/@devjaime) on [April 7, 2022](https://medium.com/p/454276c8074).\n\n[Canonical link](https://medium.com/@devjaime/comandos-%C3%BAtiles-de-git-454276c8074)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"comandos-√∫tiles-de-git","text":"Comandos √∫tiles de git"},{"depth":3,"slug":"comandos-√∫tiles-degit","text":"Comandos √∫tiles de¬†git"},{"depth":3,"slug":"fusi√≥nmerge","text":"Fusi√≥n‚Ää‚Äî‚ÄäMerge"},{"depth":3,"slug":"avance-r√°pido----ff-fast-forward","text":"Avance r√°pido ( --ff) Fast-forward"},{"depth":3,"slug":"sin-avance-r√°pido----no-ff-no-fast-foward","text":"Sin avance r√°pido ( --no-ff) No-fast-foward"},{"depth":3,"slug":"fusionar-conflictos","text":"Fusionar conflictos"},{"depth":3,"slug":"rebase","text":"rebase"},{"depth":3,"slug":"rebase-interactivo","text":"Rebase interactivo"},{"depth":3,"slug":"resettingrestablecer","text":"Resetting‚Ää‚Äî‚ÄäRestablecer"},{"depth":3,"slug":"soft-resetreiniciosuave","text":"Soft reset‚Ää‚Äî‚ÄäReinicio¬†suave"},{"depth":3,"slug":"hard-resetrestablecimiento-completo","text":"Hard reset‚Ää‚Äî‚ÄäRestablecimiento completo"},{"depth":3,"slug":"revertrevirtiendo","text":"revert‚Ää‚Äî‚Äärevirtiendo"},{"depth":3,"slug":"cherry-picking","text":"Cherry-picking"},{"depth":3,"slug":"fetching","text":"Fetching"},{"depth":3,"slug":"pulling","text":"Pulling"},{"depth":3,"slug":"reflog","text":"Reflog"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
