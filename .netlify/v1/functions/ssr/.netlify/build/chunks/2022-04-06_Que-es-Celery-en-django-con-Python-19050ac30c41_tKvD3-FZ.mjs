/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"que-es-celery-en-django-con-python\">Que es Celery en django con Python</h1>\n<p>Una tecnología imprescindible para los desarrolladores de Python</p>\n<hr>\n<h3 id=\"que-es-celery-en-django-conpython\">Que es Celery en django con Python</h3>\n<h3 id=\"una-tecnología-imprescindible-para-los-desarrolladores-depython\">Una tecnología imprescindible para los desarrolladores de Python</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*M1vSb1FgAzwmeKuvvJPlqA.png\" alt=\"\"></p>\n<p>Celery es una tecnología imprescindible para los desarrolladores de Python</p>\n<p>Cuando trabajas en aplicaciones con uso intensivo de datos, las tareas de ejecución prolongada pueden ralentizar seriamente a tus usuarios.</p>\n<p>Los usuarios modernos esperan que las páginas se carguen instantáneamente, pero las tareas con muchos datos pueden tardar varios segundos o incluso minutos en completarse. ¿Cómo podemos asegurarnos de que los usuarios tengan una experiencia rápida mientras completan tareas complicadas?</p>\n<h3 id=\"workers-y-colas-demensajes\">Workers y Colas de Mensajes</h3>\n<p>Si queremos que los usuarios experimenten tiempos de carga rápidos en nuestra aplicación, necesitaremos descargar parte del trabajo de nuestro servidor web.</p>\n<p>Una forma de hacer esto es con la asincronía. Mientras el servidor web carga la siguiente página, un segundo servidor está haciendo los cálculos que necesitamos en segundo plano.</p>\n<p>A estos servidores en segundo plano, basados ​​en tareas, los llamamos “Workers”. Si bien normalmente solo tiene uno o unos pocos servidores web que responden a las solicitudes de los usuarios, puede tener muchos servidores de trabajo que procesan tareas en segundo plano.</p>\n<p>Estos trabajadores pueden realizar cambios en la base de datos, actualizar la interfaz de usuario a través de webhooks o devoluciones de llamada, agregar elementos al caché, procesar archivos, enviar correos electrónicos, poner en cola tareas futuras y más. Todo mientras nuestro servidor web principal permanece libre para responder a las solicitudes de los usuarios.</p>\n<h3 id=\"colas-demensajes\">Colas de mensajes</h3>\n<p>Les decimos a estos workers qué hacer a través de una cola de mensajes. En pocas palabras, una cola es una estructura de datos de tipo primero en entrar, primero en salir FIFO. Cuando almacenamos mensajes en una cola, el primero que coloquemos en la cola será el primero en ser procesado. Todas las tareas se iniciarán en el orden en que las agreguemos.</p>\n<p>Cuando un workers está disponible, toma la primera tarea del frente de la cola y comienza a procesar. Si tenemos muchos workers, cada uno realiza una tarea en orden.</p>\n<p>La cola garantiza que cada workers solo obtenga una tarea a la vez y que cada tarea solo sea procesada por un workers.</p>\n<h3 id=\"qué-es-celery-gestión-de-trabajadores-para-tareas-depython\">¿Qué es Celery? Gestión de trabajadores para tareas de Python</h3>\n<p>Celery permite que las aplicaciones de Python implementen rápidamente colas de tareas para muchos workers.</p>\n<p>Se encarga de la parte difícil de recibir tareas y asignarlas adecuadamente a los workers.</p>\n<p>Utiliza Celery para lograr algunos objetivos principales:</p>\n<ol>\n<li>Define tareas independientes que tus workers pueden hacer como una función de Python</li>\n<li>Escucha a un intermediario de mensajes (usando Redis en este ejemplo) para obtener nuevas solicitudes de tareas</li>\n<li>Asigna esas solicitudes a los workers para completar la tarea</li>\n<li>Supervisar el progreso y el estado de las tareas y los workers</li>\n</ol>\n<h3 id=\"resumen-de-celery-ydjango\">Resumen de Celery y Django</h3>\n<p>En este ejemplo, usaremos Celery dentro de una aplicación Django para tareas de ejecución prolongada en segundo plano.</p>\n<p>Dado que queremos que Celery tenga acceso a nuestra base de datos, modelos y lógica, definiremos las tareas de trabajo dentro de nuestra aplicación Django.</p>\n<p>Sin embargo, estas tareas no se ejecutarán en nuestro servidor web Django principal. En cambio, Celery administrará servidores separados que pueden ejecutar las tareas simultáneamente en segundo plano.</p>\n<p>Dado que necesitamos que la cola sea accesible tanto para el servidor web de Django (para agregar nuevas tareas) como para los servidores de workers (para recoger las tareas en cola), usaremos un servidor adicional que funcione como intermediario de mensajes.</p>\n<p>Ese servidor de intermediario de mensajes utilizará Redis, un almacén de datos en memoria, para mantener la cola de tareas.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*erZ-QokAuVqqtFM9.png\" alt=\"\"></p>\n<p>Django agrega tareas a Redis; Redis alimenta tareas a Celery</p>\n<p>Para recapitular: Django crea una tarea (función de Python) y le dice a Celery que la agregue a la cola. Celery pone esa tarea en Redis (liberando a Django para que continúe trabajando en otras cosas). En un servidor separado, Celery ejecuta workers que pueden realizar tareas. Esos workers escuchan a Redis. Cuando llega la nueva tarea, un trabajador la recoge y la procesa, registrando el resultado nuevamente en Celery.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/19050ac30c41\">April 6, 2022</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/que-es-celery-en-django-con-python-19050ac30c41\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Que es Celery en django con Python","description":"","tags":["code","Celery","python"],"time":4,"featured":true,"timestamp":"2022-04-06T12:20:31-0300","filename":"2022-04-06_Que-es-Celery-en-django-con-Python-19050ac30c41"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2022-04-06_Que-es-Celery-en-django-con-Python-19050ac30c41.md";
				const url = "/blog/2022-04-06_Que-es-Celery-en-django-con-Python-19050ac30c41";
				function rawContent() {
					return "   \n                                        \n                                           \n               \n                                  \n       \n              \n                                     \n                                                                      \n   \n\n\nQue es Celery en django con Python\n==================================\n\nUna tecnología imprescindible para los desarrolladores de Python\n\n* * *\n\n### Que es Celery en django con Python\n\n### Una tecnología imprescindible para los desarrolladores de Python\n\n![](https://cdn-images-1.medium.com/max/800/1*M1vSb1FgAzwmeKuvvJPlqA.png)\n\nCelery es una tecnología imprescindible para los desarrolladores de Python\n\nCuando trabajas en aplicaciones con uso intensivo de datos, las tareas de ejecución prolongada pueden ralentizar seriamente a tus usuarios.\n\nLos usuarios modernos esperan que las páginas se carguen instantáneamente, pero las tareas con muchos datos pueden tardar varios segundos o incluso minutos en completarse. ¿Cómo podemos asegurarnos de que los usuarios tengan una experiencia rápida mientras completan tareas complicadas?\n\n### Workers y Colas de Mensajes\n\nSi queremos que los usuarios experimenten tiempos de carga rápidos en nuestra aplicación, necesitaremos descargar parte del trabajo de nuestro servidor web.\n\nUna forma de hacer esto es con la asincronía. Mientras el servidor web carga la siguiente página, un segundo servidor está haciendo los cálculos que necesitamos en segundo plano.\n\nA estos servidores en segundo plano, basados ​​en tareas, los llamamos “Workers”. Si bien normalmente solo tiene uno o unos pocos servidores web que responden a las solicitudes de los usuarios, puede tener muchos servidores de trabajo que procesan tareas en segundo plano.\n\nEstos trabajadores pueden realizar cambios en la base de datos, actualizar la interfaz de usuario a través de webhooks o devoluciones de llamada, agregar elementos al caché, procesar archivos, enviar correos electrónicos, poner en cola tareas futuras y más. Todo mientras nuestro servidor web principal permanece libre para responder a las solicitudes de los usuarios.\n\n### Colas de mensajes\n\nLes decimos a estos workers qué hacer a través de una cola de mensajes. En pocas palabras, una cola es una estructura de datos de tipo primero en entrar, primero en salir FIFO. Cuando almacenamos mensajes en una cola, el primero que coloquemos en la cola será el primero en ser procesado. Todas las tareas se iniciarán en el orden en que las agreguemos.\n\nCuando un workers está disponible, toma la primera tarea del frente de la cola y comienza a procesar. Si tenemos muchos workers, cada uno realiza una tarea en orden.\n\nLa cola garantiza que cada workers solo obtenga una tarea a la vez y que cada tarea solo sea procesada por un workers.\n\n### ¿Qué es Celery? Gestión de trabajadores para tareas de Python\n\nCelery permite que las aplicaciones de Python implementen rápidamente colas de tareas para muchos workers.\n\nSe encarga de la parte difícil de recibir tareas y asignarlas adecuadamente a los workers.\n\nUtiliza Celery para lograr algunos objetivos principales:\n\n1.  Define tareas independientes que tus workers pueden hacer como una función de Python\n2.  Escucha a un intermediario de mensajes (usando Redis en este ejemplo) para obtener nuevas solicitudes de tareas\n3.  Asigna esas solicitudes a los workers para completar la tarea\n4.  Supervisar el progreso y el estado de las tareas y los workers\n\n### Resumen de Celery y Django\n\nEn este ejemplo, usaremos Celery dentro de una aplicación Django para tareas de ejecución prolongada en segundo plano.\n\nDado que queremos que Celery tenga acceso a nuestra base de datos, modelos y lógica, definiremos las tareas de trabajo dentro de nuestra aplicación Django.\n\nSin embargo, estas tareas no se ejecutarán en nuestro servidor web Django principal. En cambio, Celery administrará servidores separados que pueden ejecutar las tareas simultáneamente en segundo plano.\n\nDado que necesitamos que la cola sea accesible tanto para el servidor web de Django (para agregar nuevas tareas) como para los servidores de workers (para recoger las tareas en cola), usaremos un servidor adicional que funcione como intermediario de mensajes.\n\nEse servidor de intermediario de mensajes utilizará Redis, un almacén de datos en memoria, para mantener la cola de tareas.\n\n![](https://cdn-images-1.medium.com/max/800/0*erZ-QokAuVqqtFM9.png)\n\nDjango agrega tareas a Redis; Redis alimenta tareas a Celery\n\nPara recapitular: Django crea una tarea (función de Python) y le dice a Celery que la agregue a la cola. Celery pone esa tarea en Redis (liberando a Django para que continúe trabajando en otras cosas). En un servidor separado, Celery ejecuta workers que pueden realizar tareas. Esos workers escuchan a Redis. Cuando llega la nueva tarea, un trabajador la recoge y la procesa, registrando el resultado nuevamente en Celery.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [April 6, 2022](https://medium.com/p/19050ac30c41).\n\n[Canonical link](https://medium.com/@devjaime/que-es-celery-en-django-con-python-19050ac30c41)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"que-es-celery-en-django-con-python","text":"Que es Celery en django con Python"},{"depth":3,"slug":"que-es-celery-en-django-conpython","text":"Que es Celery en django con Python"},{"depth":3,"slug":"una-tecnología-imprescindible-para-los-desarrolladores-depython","text":"Una tecnología imprescindible para los desarrolladores de Python"},{"depth":3,"slug":"workers-y-colas-demensajes","text":"Workers y Colas de Mensajes"},{"depth":3,"slug":"colas-demensajes","text":"Colas de mensajes"},{"depth":3,"slug":"qué-es-celery-gestión-de-trabajadores-para-tareas-depython","text":"¿Qué es Celery? Gestión de trabajadores para tareas de Python"},{"depth":3,"slug":"resumen-de-celery-ydjango","text":"Resumen de Celery y Django"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
