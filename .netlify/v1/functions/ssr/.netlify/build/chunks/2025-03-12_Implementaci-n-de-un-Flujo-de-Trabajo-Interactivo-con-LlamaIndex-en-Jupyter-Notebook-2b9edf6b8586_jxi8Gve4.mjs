/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"implementación-de-un-flujo-de-trabajo-interactivo-con-llamaindex-en-jupyter-notebook\">Implementación de un Flujo de Trabajo Interactivo con LlamaIndex en Jupyter Notebook</h1>\n<p>En este artículo, exploraremos un conjunto de notebooks diseñados para implementar un flujo de trabajo interactivo utilizando LlamaIndex…</p>\n<hr>\n<h3 id=\"implementación-de-un-flujo-de-trabajo-interactivo-con-llamaindex-en-jupyternotebook\">Implementación de un Flujo de Trabajo Interactivo con LlamaIndex en Jupyter Notebook</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*N-KjmkFZnDtWVUMjz1GibQ.png\" alt=\"\"></p>\n<p>En este artículo, exploraremos un conjunto de notebooks diseñados para implementar un flujo de trabajo interactivo utilizando <strong>LlamaIndex</strong>, <strong>OpenAI</strong> y eventos de feedback para mejorar la generación de respuestas. Esta implementación permite la iteración en respuestas a cuestionarios mediante un agente que recibe retroalimentación de un usuario humano.</p>\n<h3 id=\"1-introducción-y-objetivo-delproyecto\">1. Introducción y Objetivo del Proyecto</h3>\n<p>Los notebooks están enfocados en la construcción de un <strong>flujo de trabajo iterativo</strong> que utiliza modelos de lenguaje para responder preguntas basadas en documentos cargados, como formularios de solicitud de empleo y currículums.</p>\n<p>El objetivo principal es mejorar la precisión de las respuestas generadas mediante un sistema de feedback en tiempo real, permitiendo que un usuario pueda corregir o ajustar las respuestas antes de finalizar el proceso.</p>\n<h3 id=\"2-instalación-y-configuración-deentorno\">2. Instalación y Configuración de Entorno</h3>\n<p>Antes de ejecutar los notebooks, es necesario configurar el entorno instalando las dependencias adecuadas:</p>\n<p>pip install llama-index openai ipywidgets pandas matplotlib</p>\n<p>Además, se utilizan claves de API para OpenAI y LlamaIndex, las cuales se extraen a través de funciones auxiliares.</p>\n<p>from helper import get_openai_api_key, get_llama_cloud_api_key<br>\nllama_cloud_api_key = get_llama_cloud_api_key()<br>\nopenai_api_key = get_openai_api_key()</p>\n<h3 id=\"3-construcción-del-flujo-detrabajo\">3. Construcción del Flujo de Trabajo</h3>\n<h3 id=\"31-definición-deeventos\">3.1. Definición de Eventos</h3>\n<p>Se definen eventos personalizados para estructurar el flujo del agente:</p>\n<p>from llama_index.core.workflow import Event<br>\nclass ParseFormEvent(Event):<br>\napplication_form: str<br>\nclass QueryEvent(Event):<br>\nquery: str<br>\nfield: str<br>\nclass ResponseEvent(Event):<br>\nresponse: str<br>\nclass FeedbackEvent(Event):<br>\nfeedback: str<br>\nclass GenerateQuestionsEvent(Event):<br>\npass</p>\n<p>Estos eventos permiten gestionar el proceso de consulta, respuesta y feedback dentro del flujo del agente.</p>\n<h3 id=\"32-implementación-del-agente-con-llamaindex\">3.2. Implementación del Agente con LlamaIndex</h3>\n<p>El flujo de trabajo está estructurado en pasos utilizando <code>Workflow</code> y <code>step</code> de LlamaIndex.</p>\n<p>from llama_index.core.workflow import Workflow, step, Context<br>\nclass RAGWorkflow(Workflow):<br>\nstorage_dir = ”./storage”<br>\nllm: OpenAI<br>\nquery_engine: VectorStoreIndex<br>\n@step<br>\nasync def set_up(self, ctx: Context, ev: StartEvent) -> ParseFormEvent:<br>\nself.llm = OpenAI(model=“gpt-4o-mini”)<br>\nreturn ParseFormEvent(application_form=ev.application_form)</p>\n<p>Cada paso dentro del flujo maneja una etapa específica:</p>\n<ul>\n<li><strong>parse_form</strong>: Extrae los campos de un formulario para ser respondidos.</li>\n<li><strong>generate_questions</strong>: Genera preguntas basadas en el contenido del documento.</li>\n<li><strong>ask_question</strong>: Utiliza el modelo de lenguaje para obtener respuestas preliminares.</li>\n<li><strong>fill_in_application</strong>: Recibe feedback del usuario y permite iteraciones.</li>\n<li><strong>get_feedback</strong>: Procesa la retroalimentación para mejorar las respuestas.</li>\n</ul>\n<h3 id=\"33-integración-de-feedbackhumano\">3.3. Integración de Feedback Humano</h3>\n<p>Uno de los aspectos más importantes del flujo es la capacidad de recibir y procesar retroalimentación en tiempo real:</p>\n<p>@step<br>\nasync def get_feedback(self, ctx: Context, ev: HumanResponseEvent) -> FeedbackEvent | StopEvent:<br>\nresult = self.llm.complete(f\"\"\"<br>\nHas recibido retroalimentación sobre las respuestas.<br>\n¿Hay algo que mejorar?<br>\n<feedback>{ev.response}</feedback><br>\nResponde con ‘OKAY’ si está todo bien o ‘FEEDBACK’ si hay ajustes necesarios.<br>\n\"\"\")</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>verdict = result.text.strip()  </span></span>\n<span class=\"line\"><span>if verdict == \"OKAY\":  </span></span>\n<span class=\"line\"><span>    return StopEvent(result=await ctx.get(\"filled\\_form\"))  </span></span>\n<span class=\"line\"><span>else:  </span></span>\n<span class=\"line\"><span>    return FeedbackEvent(feedback=ev.response)</span></span></code></pre>\n<p>Esto permite que el usuario pueda validar cada respuesta antes de finalizar el proceso.</p>\n<h3 id=\"4-ejecución-y-visualización-delflujo\">4. Ejecución y Visualización del Flujo</h3>\n<p>Para ejecutar el agente, se inicia el flujo de eventos y se gestiona la retroalimentación del usuario:</p>\n<p>w = RAGWorkflow(timeout=600, verbose=False)<br>\nhandler = w.run(<br>\nresume_file=“data/fake_resume.pdf”,<br>\napplication_form=“data/fake_application_form.pdf”<br>\n)</p>\n<p>async for event in handler.stream_events():<br>\nif isinstance(event, InputRequiredEvent):<br>\nprint(“Formulario generado:\\n”)<br>\nprint(event.result)<br>\nresponse = input(event.prefix)<br>\nhandler.ctx.send_event(HumanResponseEvent(response=response))<br>\nresponse = await handler<br>\nprint(“Flujo completado. Resultado final:“)<br>\nprint(str(response))</p>\n<p>Este código permite al usuario interactuar con el flujo y hacer ajustes en tiempo real.</p>\n<h3 id=\"5-conclusión\">5. Conclusión</h3>\n<p>Este conjunto de notebooks demuestra cómo se puede construir un flujo de trabajo interactivo utilizando modelos de lenguaje, mejorando la precisión de las respuestas con retroalimentación humana. La combinación de <strong>LlamaIndex</strong>, <strong>OpenAI</strong> y eventos personalizados permite crear un sistema flexible y escalable para automatizar tareas de procesamiento de documentos y formularios.</p>\n<p>Con este enfoque, se pueden optimizar procesos en áreas como reclutamiento, asistencia virtual y validación automatizada de información.</p>\n<h3 id=\"6-ejemplo-de-validación-automatizada-de-información\">6. Ejemplo de Validación Automatizada de Información</h3>\n<p>Un caso de uso práctico es la validación de documentos en un sistema de control de calidad. Supongamos que tenemos un sistema que debe verificar si los datos ingresados en un formulario cumplen con ciertos criterios predefinidos:</p>\n<p>@step<br>\nasync def validate_information(self, ctx: Context, ev: ParseFormEvent) -> ResponseEvent:<br>\nrules = {<br>\n“email”: r”^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$”,<br>\n“phone”: r”^\\+?[0-9]{7,15}$”<br>\n}</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>form\\_data = json.loads(ev.application\\_form)  </span></span>\n<span class=\"line\"><span>errors = \\[\\]  </span></span>\n<span class=\"line\"><span>  </span></span>\n<span class=\"line\"><span>for field, value in form\\_data.items():  </span></span>\n<span class=\"line\"><span>    if field in rules and not re.match(rules\\[field\\], value):  </span></span>\n<span class=\"line\"><span>        errors.append(f\"{field} tiene un formato inválido.\")  </span></span>\n<span class=\"line\"><span>  </span></span>\n<span class=\"line\"><span>if errors:  </span></span>\n<span class=\"line\"><span>    return ResponseEvent(response=\"\\\\n\".join(errors))  </span></span>\n<span class=\"line\"><span>else:  </span></span>\n<span class=\"line\"><span>    return ResponseEvent(response=\"Todos los datos son válidos.\")</span></span></code></pre>\n<p>Este ejemplo muestra cómo un flujo de trabajo puede validar automáticamente los datos de un formulario, asegurando que cumplan con ciertos estándares antes de continuar con el proceso.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/2b9edf6b8586\">March 12, 2025</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/implementaci%C3%B3n-de-un-flujo-de-trabajo-interactivo-con-llamaindex-en-jupyter-notebook-2b9edf6b8586\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Implementación de un Flujo de Trabajo Interactivo con LlamaIndex en Jupyter Notebook","description":"","tags":["code","LlamaIndex","JupyterNotebook"],"time":4,"featured":true,"timestamp":"2025-03-12T12:20:33-0300","filename":"2025-03-12_Implementaci-n-de-un-Flujo-de-Trabajo-Interactivo-con-LlamaIndex-en-Jupyter-Notebook-2b9edf6b8586"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2025-03-12_Implementaci-n-de-un-Flujo-de-Trabajo-Interactivo-con-LlamaIndex-en-Jupyter-Notebook-2b9edf6b8586.md";
				const url = "/blog/2025-03-12_Implementaci-n-de-un-Flujo-de-Trabajo-Interactivo-con-LlamaIndex-en-Jupyter-Notebook-2b9edf6b8586";
				function rawContent() {
					return "   \n                                        \n                                                                                             \n               \n                                               \n       \n              \n                                     \n                                                                                                                        \n   \n\nImplementación de un Flujo de Trabajo Interactivo con LlamaIndex en Jupyter Notebook\n====================================================================================\n\nEn este artículo, exploraremos un conjunto de notebooks diseñados para implementar un flujo de trabajo interactivo utilizando LlamaIndex…\n\n* * *\n\n### Implementación de un Flujo de Trabajo Interactivo con LlamaIndex en Jupyter Notebook\n\n![](https://cdn-images-1.medium.com/max/800/1*N-KjmkFZnDtWVUMjz1GibQ.png)\n\nEn este artículo, exploraremos un conjunto de notebooks diseñados para implementar un flujo de trabajo interactivo utilizando **LlamaIndex**, **OpenAI** y eventos de feedback para mejorar la generación de respuestas. Esta implementación permite la iteración en respuestas a cuestionarios mediante un agente que recibe retroalimentación de un usuario humano.\n\n### 1\\. Introducción y Objetivo del Proyecto\n\nLos notebooks están enfocados en la construcción de un **flujo de trabajo iterativo** que utiliza modelos de lenguaje para responder preguntas basadas en documentos cargados, como formularios de solicitud de empleo y currículums.\n\nEl objetivo principal es mejorar la precisión de las respuestas generadas mediante un sistema de feedback en tiempo real, permitiendo que un usuario pueda corregir o ajustar las respuestas antes de finalizar el proceso.\n\n### 2\\. Instalación y Configuración de Entorno\n\nAntes de ejecutar los notebooks, es necesario configurar el entorno instalando las dependencias adecuadas:\n\npip install llama-index openai ipywidgets pandas matplotlib\n\nAdemás, se utilizan claves de API para OpenAI y LlamaIndex, las cuales se extraen a través de funciones auxiliares.\n\nfrom helper import get\\_openai\\_api\\_key, get\\_llama\\_cloud\\_api\\_key  \nllama\\_cloud\\_api\\_key = get\\_llama\\_cloud\\_api\\_key()  \nopenai\\_api\\_key = get\\_openai\\_api\\_key()\n\n### 3\\. Construcción del Flujo de Trabajo\n\n### 3.1. Definición de Eventos\n\nSe definen eventos personalizados para estructurar el flujo del agente:\n\nfrom llama\\_index.core.workflow import Event  \nclass ParseFormEvent(Event):  \n    application\\_form: str  \nclass QueryEvent(Event):  \n    query: str  \n    field: str  \nclass ResponseEvent(Event):  \n    response: str  \nclass FeedbackEvent(Event):  \n    feedback: str  \nclass GenerateQuestionsEvent(Event):  \n    pass\n\nEstos eventos permiten gestionar el proceso de consulta, respuesta y feedback dentro del flujo del agente.\n\n### 3.2. Implementación del Agente con LlamaIndex\n\nEl flujo de trabajo está estructurado en pasos utilizando `Workflow` y `step` de LlamaIndex.\n\nfrom llama\\_index.core.workflow import Workflow, step, Context  \nclass RAGWorkflow(Workflow):  \n    storage\\_dir = \"./storage\"  \n    llm: OpenAI  \n    query\\_engine: VectorStoreIndex  \n    @step  \n    async def set\\_up(self, ctx: Context, ev: StartEvent) -> ParseFormEvent:  \n        self.llm = OpenAI(model=\"gpt-4o-mini\")  \n        return ParseFormEvent(application\\_form=ev.application\\_form)\n\nCada paso dentro del flujo maneja una etapa específica:\n\n*   **parse\\_form**: Extrae los campos de un formulario para ser respondidos.\n*   **generate\\_questions**: Genera preguntas basadas en el contenido del documento.\n*   **ask\\_question**: Utiliza el modelo de lenguaje para obtener respuestas preliminares.\n*   **fill\\_in\\_application**: Recibe feedback del usuario y permite iteraciones.\n*   **get\\_feedback**: Procesa la retroalimentación para mejorar las respuestas.\n\n### 3.3. Integración de Feedback Humano\n\nUno de los aspectos más importantes del flujo es la capacidad de recibir y procesar retroalimentación en tiempo real:\n\n@step  \nasync def get\\_feedback(self, ctx: Context, ev: HumanResponseEvent) -> FeedbackEvent | StopEvent:  \n    result = self.llm.complete(f\"\"\"  \n        Has recibido retroalimentación sobre las respuestas.   \n        ¿Hay algo que mejorar?  \n        <feedback>{ev.response}</feedback>  \n        Responde con 'OKAY' si está todo bien o 'FEEDBACK' si hay ajustes necesarios.  \n    \"\"\")  \n      \n    verdict = result.text.strip()  \n    if verdict == \"OKAY\":  \n        return StopEvent(result=await ctx.get(\"filled\\_form\"))  \n    else:  \n        return FeedbackEvent(feedback=ev.response)\n\nEsto permite que el usuario pueda validar cada respuesta antes de finalizar el proceso.\n\n### 4\\. Ejecución y Visualización del Flujo\n\nPara ejecutar el agente, se inicia el flujo de eventos y se gestiona la retroalimentación del usuario:\n\nw = RAGWorkflow(timeout=600, verbose=False)  \nhandler = w.run(  \n    resume\\_file=\"data/fake\\_resume.pdf\",  \n    application\\_form=\"data/fake\\_application\\_form.pdf\"  \n)  \n  \nasync for event in handler.stream\\_events():  \n    if isinstance(event, InputRequiredEvent):  \n        print(\"Formulario generado:\\\\n\")  \n        print(event.result)  \n        response = input(event.prefix)  \n        handler.ctx.send\\_event(HumanResponseEvent(response=response))  \nresponse = await handler  \nprint(\"Flujo completado. Resultado final:\")  \nprint(str(response))\n\nEste código permite al usuario interactuar con el flujo y hacer ajustes en tiempo real.\n\n### 5\\. Conclusión\n\nEste conjunto de notebooks demuestra cómo se puede construir un flujo de trabajo interactivo utilizando modelos de lenguaje, mejorando la precisión de las respuestas con retroalimentación humana. La combinación de **LlamaIndex**, **OpenAI** y eventos personalizados permite crear un sistema flexible y escalable para automatizar tareas de procesamiento de documentos y formularios.\n\nCon este enfoque, se pueden optimizar procesos en áreas como reclutamiento, asistencia virtual y validación automatizada de información.\n\n### 6\\. Ejemplo de Validación Automatizada de Información\n\nUn caso de uso práctico es la validación de documentos en un sistema de control de calidad. Supongamos que tenemos un sistema que debe verificar si los datos ingresados en un formulario cumplen con ciertos criterios predefinidos:\n\n@step  \nasync def validate\\_information(self, ctx: Context, ev: ParseFormEvent) -> ResponseEvent:  \n    rules = {  \n        \"email\": r\"^\\[\\\\w\\\\.-\\]+@\\[\\\\w\\\\.-\\]+\\\\.\\\\w+$\",  \n        \"phone\": r\"^\\\\+?\\[0-9\\]{7,15}$\"  \n    }  \n      \n    form\\_data = json.loads(ev.application\\_form)  \n    errors = \\[\\]  \n      \n    for field, value in form\\_data.items():  \n        if field in rules and not re.match(rules\\[field\\], value):  \n            errors.append(f\"{field} tiene un formato inválido.\")  \n      \n    if errors:  \n        return ResponseEvent(response=\"\\\\n\".join(errors))  \n    else:  \n        return ResponseEvent(response=\"Todos los datos son válidos.\")\n\nEste ejemplo muestra cómo un flujo de trabajo puede validar automáticamente los datos de un formulario, asegurando que cumplan con ciertos estándares antes de continuar con el proceso.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [March 12, 2025](https://medium.com/p/2b9edf6b8586).\n\n[Canonical link](https://medium.com/@devjaime/implementaci%C3%B3n-de-un-flujo-de-trabajo-interactivo-con-llamaindex-en-jupyter-notebook-2b9edf6b8586)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"implementación-de-un-flujo-de-trabajo-interactivo-con-llamaindex-en-jupyter-notebook","text":"Implementación de un Flujo de Trabajo Interactivo con LlamaIndex en Jupyter Notebook"},{"depth":3,"slug":"implementación-de-un-flujo-de-trabajo-interactivo-con-llamaindex-en-jupyternotebook","text":"Implementación de un Flujo de Trabajo Interactivo con LlamaIndex en Jupyter Notebook"},{"depth":3,"slug":"1-introducción-y-objetivo-delproyecto","text":"1. Introducción y Objetivo del Proyecto"},{"depth":3,"slug":"2-instalación-y-configuración-deentorno","text":"2. Instalación y Configuración de Entorno"},{"depth":3,"slug":"3-construcción-del-flujo-detrabajo","text":"3. Construcción del Flujo de Trabajo"},{"depth":3,"slug":"31-definición-deeventos","text":"3.1. Definición de Eventos"},{"depth":3,"slug":"32-implementación-del-agente-con-llamaindex","text":"3.2. Implementación del Agente con LlamaIndex"},{"depth":3,"slug":"33-integración-de-feedbackhumano","text":"3.3. Integración de Feedback Humano"},{"depth":3,"slug":"4-ejecución-y-visualización-delflujo","text":"4. Ejecución y Visualización del Flujo"},{"depth":3,"slug":"5-conclusión","text":"5. Conclusión"},{"depth":3,"slug":"6-ejemplo-de-validación-automatizada-de-información","text":"6. Ejemplo de Validación Automatizada de Información"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
