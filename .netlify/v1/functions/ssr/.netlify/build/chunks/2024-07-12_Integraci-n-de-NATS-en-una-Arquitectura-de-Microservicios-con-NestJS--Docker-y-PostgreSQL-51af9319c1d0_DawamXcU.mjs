/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"integración-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql\">Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL</h1>\n<p>Introducción</p>\n<hr>\n<h3 id=\"integración-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql-1\">Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*Uwwpj7DXbcxMeTb7\" alt=\"\"></p>\n<h3 id=\"introducción\">Introducción</h3>\n<p>En el mundo del desarrollo de software, los microservicios han ganado popularidad debido a su capacidad para dividir aplicaciones grandes y complejas en partes más pequeñas y manejables. En este blog, exploraremos cómo integrar un servidor NATS (Neural Autonomic Transport System) en una arquitectura de microservicios utilizando NestJS, Docker y PostgreSQL. Para hacerlo más tangible, utilizaremos un caso de uso real de una aplicación de gestión de pedidos.</p>\n<h3 id=\"caso-de-uso-aplicación-de-gestión-depedidos\">Caso de Uso: Aplicación de Gestión de Pedidos</h3>\n<p>Imaginemos que estamos construyendo una aplicación de gestión de pedidos que incluye múltiples servicios, como el servicio de pedidos, el servicio de inventario y el servicio de notificaciones. Estos servicios deben comunicarse entre sí de manera eficiente y confiable. Aquí es donde NATS entra en juego, proporcionando un sistema de mensajería rápida y de bajo retardo.</p>\n<h3 id=\"arquitectura-de-la-aplicación\">Arquitectura de la Aplicación</h3>\n<p>Nuestra aplicación de gestión de pedidos tendrá la siguiente arquitectura:</p>\n<ol>\n<li><strong>Servicio de Pedidos</strong>: Gestiona la creación, actualización y eliminación de pedidos.</li>\n<li><strong>Servicio de Inventario</strong>: Mantiene el inventario de productos y actualiza las existencias según los pedidos.</li>\n<li><strong>Servicio de Notificaciones</strong>: Envía notificaciones a los usuarios sobre el estado de sus pedidos.</li>\n</ol>\n<h3 id=\"configuración-dedocker\">Configuración de Docker</h3>\n<p>Primero, configuramos Docker para orquestar nuestros servicios. Creamos un archivo <code>Dockerfile</code> para nuestro servicio NestJS y un archivo <code>docker-compose.yml</code> para definir y ejecutar múltiples contenedores Docker.</p>\n<p>FROM node:14<br>\nWORKDIR /app<br>\nCOPY package*.json ./<br>\nRUN npm install<br>\nCOPY . .<br>\nRUN npm run build<br>\nEXPOSE 3000<br>\nCMD [“npm”, “run”, “start:prod”]</p>\n<h4 id=\"docker-compose\">Docker Compose</h4>\n<p>version: ‘3’<br>\nservices:<br>\npostgres:<br>\nimage: postgres:latest<br>\nenvironment:<br>\nPOSTGRES_USER: user<br>\nPOSTGRES_PASSWORD: password<br>\nPOSTGRES_DB: orders<br>\nports:<br>\n- “5432:5432”<br>\nvolumes:<br>\n- postgres-data:/var/lib/postgresql/data</p>\n<p>nats:<br>\nimage: nats:latest<br>\nports:<br>\n- “4222:4222”</p>\n<p>orders:<br>\nbuild: .<br>\nenvironment:<br>\nDATABASE_HOST: postgres<br>\nDATABASE_PORT: 5432<br>\nDATABASE_USER: user<br>\nDATABASE_PASSWORD: password<br>\nDATABASE_NAME: orders<br>\nNATS_SERVER: nats://nats:4222<br>\ndepends_on:<br>\n- postgres<br>\n- nats<br>\nports:<br>\n- “3000:3000”</p>\n<p>volumes:<br>\npostgres-data:</p>\n<h3 id=\"configuración-denestjs\">Configuración de NestJS</h3>\n<p>Ahora configuramos nuestro proyecto NestJS para que interactúe con NATS y PostgreSQL.</p>\n<h4 id=\"instalación-de-dependencias\">Instalación de Dependencias</h4>\n<p>npm install @nestjs/microservices nats @nestjs/typeorm typeorm pg</p>\n<p>Claro, aquí tienes un ejemplo de cómo se podría escribir un blog sobre la integración de un servidor NATS en una configuración de microservicios utilizando NestJS, Docker y PostgreSQL, con un caso de uso real.</p>\n<hr>\n<h3 id=\"integración-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql-2\">Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL</h3>\n<h3 id=\"introducción-1\">Introducción</h3>\n<p>En el mundo del desarrollo de software, los microservicios han ganado popularidad debido a su capacidad para dividir aplicaciones grandes y complejas en partes más pequeñas y manejables. En este blog, exploraremos cómo integrar un servidor NATS (Neural Autonomic Transport System) en una arquitectura de microservicios utilizando NestJS, Docker y PostgreSQL. Para hacerlo más tangible, utilizaremos un caso de uso real de una aplicación de gestión de pedidos.</p>\n<h3 id=\"caso-de-uso-aplicación-de-gestión-depedidos-1\">Caso de Uso: Aplicación de Gestión de Pedidos</h3>\n<p>Imaginemos que estamos construyendo una aplicación de gestión de pedidos que incluye múltiples servicios, como el servicio de pedidos, el servicio de inventario y el servicio de notificaciones. Estos servicios deben comunicarse entre sí de manera eficiente y confiable. Aquí es donde NATS entra en juego, proporcionando un sistema de mensajería rápida y de bajo retardo.</p>\n<h3 id=\"arquitectura-de-la-aplicación-1\">Arquitectura de la Aplicación</h3>\n<p>Nuestra aplicación de gestión de pedidos tendrá la siguiente arquitectura:</p>\n<ol>\n<li><strong>Servicio de Pedidos</strong>: Gestiona la creación, actualización y eliminación de pedidos.</li>\n<li><strong>Servicio de Inventario</strong>: Mantiene el inventario de productos y actualiza las existencias según los pedidos.</li>\n<li><strong>Servicio de Notificaciones</strong>: Envía notificaciones a los usuarios sobre el estado de sus pedidos.</li>\n</ol>\n<h3 id=\"configuración-dedocker-1\">Configuración de Docker</h3>\n<p>Primero, configuramos Docker para orquestar nuestros servicios. Creamos un archivo <code>Dockerfile</code> para nuestro servicio NestJS y un archivo <code>docker-compose.yml</code> para definir y ejecutar múltiples contenedores Docker.</p>\n<h4 id=\"dockerfile-para-el-servicionestjs\">Dockerfile para el servicio NestJS</h4>\n<p>FROM node:14<br>\nWORKDIR /app<br>\nCOPY package*.json ./<br>\nRUN npm install<br>\nCOPY . .<br>\nRUN npm run build<br>\nEXPOSE 3000<br>\nCMD [“npm”, “run”, “start:prod”]</p>\n<h4 id=\"docker-compose-1\">Docker Compose</h4>\n<p>version: ‘3’<br>\nservices:<br>\npostgres:<br>\nimage: postgres:latest<br>\nenvironment:<br>\nPOSTGRES_USER: user<br>\nPOSTGRES_PASSWORD: password<br>\nPOSTGRES_DB: orders<br>\nports:<br>\n- “5432:5432”<br>\nvolumes:<br>\n- postgres-data:/var/lib/postgresql/data</p>\n<p>nats:<br>\nimage: nats:latest<br>\nports:<br>\n- “4222:4222”</p>\n<p>orders:<br>\nbuild: .<br>\nenvironment:<br>\nDATABASE_HOST: postgres<br>\nDATABASE_PORT: 5432<br>\nDATABASE_USER: user<br>\nDATABASE_PASSWORD: password<br>\nDATABASE_NAME: orders<br>\nNATS_SERVER: nats://nats:4222<br>\ndepends_on:<br>\n- postgres<br>\n- nats<br>\nports:<br>\n- “3000:3000”</p>\n<p>volumes:<br>\npostgres-data:</p>\n<h3 id=\"configuración-denestjs-1\">Configuración de NestJS</h3>\n<p>Ahora configuramos nuestro proyecto NestJS para que interactúe con NATS y PostgreSQL.</p>\n<h4 id=\"instalación-de-dependencias-1\">Instalación de Dependencias</h4>\n<p>npm install @nestjs/microservices nats @nestjs/typeorm typeorm pg</p>\n<h4 id=\"configuración-del-microservicio-connats\">Configuración del Microservicio con NATS</h4>\n<p>Configuramos el microservicio en el archivo <code>app.module.ts</code> para que use NATS como sistema de mensajería.</p>\n<p>import { Module } from ‘@nestjs/common’;<br>\nimport { ClientsModule, Transport } from ‘@nestjs/microservices’;<br>\nimport { TypeOrmModule } from ‘@nestjs/typeorm’;<br>\nimport { AppController } from ’./app.controller’;<br>\nimport { AppService } from ’./app.service’;</p>\n<p>@Module({<br>\nimports: [<br>\nClientsModule.register([<br>\n{<br>\nname: ‘NATS_SERVICE’,<br>\ntransport: Transport.NATS,<br>\noptions: {<br>\nurl: process.env.NATS_SERVER,<br>\n},<br>\n},<br>\n]),<br>\nTypeOrmModule.forRoot({<br>\ntype: ‘postgres’,<br>\nhost: process.env.DATABASE_HOST,<br>\nport: parseInt(process.env.DATABASE_PORT, 10),<br>\nusername: process.env.DATABASE_USER,<br>\npassword: process.env.DATABASE_PASSWORD,<br>\ndatabase: process.env.DATABASE_NAME,<br>\nentities: [__dirname + ’/**/*.entity{.ts,.js}’],<br>\nsynchronize: true,<br>\n}),<br>\n],<br>\ncontrollers: [AppController],<br>\nproviders: [AppService],<br>\n})<br>\nexport class AppModule {}</p>\n<h4 id=\"uso-del-servicio-nats-en-un-controlador\">Uso del Servicio NATS en un Controlador</h4>\n<p>En el controlador, usamos NATS para enviar y recibir mensajes.</p>\n<p>import { Controller, Get } from ‘@nestjs/common’;<br>\nimport { ClientProxy, Client } from ‘@nestjs/microservices’;<br>\nimport { Observable } from ‘rxjs’;</p>\n<p>@Controller()<br>\nexport class AppController {<br>\n@Client({ transport: Transport.NATS, options: { url: process.env.NATS_SERVER } })<br>\nprivate client: ClientProxy;</p>\n<p>@Get()<br>\ngetHello(): Observable&#x3C;string> {<br>\nreturn this.client.send&#x3C;string>({ cmd: ‘hello’ }, {});<br>\n}<br>\n}</p>\n<h3 id=\"integración-con-postgresql\">Integración con PostgreSQL</h3>\n<p>Configuramos TypeORM para interactuar con PostgreSQL.</p>\n<h4 id=\"configuración-detypeorm\">Configuración de TypeORM</h4>\n<p>import { TypeOrmModule } from ‘@nestjs/typeorm’;</p>\n<p>@Module({<br>\nimports: [<br>\nTypeOrmModule.forRoot({<br>\ntype: ‘postgres’,<br>\nhost: process.env.DATABASE_HOST,<br>\nport: parseInt(process.env.DATABASE_PORT, 10),<br>\nusername: process.env.DATABASE_USER,<br>\npassword: process.env.DATABASE_PASSWORD,<br>\ndatabase: process.env.DATABASE_NAME,<br>\nentities: [__dirname + ’/**/*.entity{.ts,.js}’],<br>\nsynchronize: true,<br>\n}),<br>\n],<br>\ncontrollers: [AppController],<br>\nproviders: [AppService],<br>\n})<br>\nexport class AppModule {}</p>\n<h3 id=\"conclusión\">Conclusión</h3>\n<p>Con esta configuración, hemos logrado integrar un servidor NATS en una arquitectura de microservicios utilizando NestJS, Docker y PostgreSQL. Esta integración permite que nuestros servicios se comuniquen de manera eficiente y escalable, lo que es crucial para aplicaciones modernas de microservicios. La configuración de Docker facilita el despliegue y la gestión de cada componente, asegurando que nuestra aplicación sea fácil de mantener y escalar.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/51af9319c1d0\">July 12, 2024</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/integraci%C3%B3n-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql-51af9319c1d0\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL","description":"","tags":["code","NATS","NESTJS","DOCKER","PostgresSQL"],"time":4,"featured":true,"timestamp":"2024-07-12T12:20:32-0300","filename":"2024-07-12_Integraci-n-de-NATS-en-una-Arquitectura-de-Microservicios-con-NestJS--Docker-y-PostgreSQL-51af9319c1d0"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2024-07-12_Integraci-n-de-NATS-en-una-Arquitectura-de-Microservicios-con-NestJS--Docker-y-PostgreSQL-51af9319c1d0.md";
				const url = "/blog/2024-07-12_Integraci-n-de-NATS-en-una-Arquitectura-de-Microservicios-con-NestJS--Docker-y-PostgreSQL-51af9319c1d0";
				function rawContent() {
					return "   \n                                        \n                                                                                                  \n               \n                                                         \n       \n              \n                                     \n                                                                                                                             \n   \n\nIntegración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL\n=========================================================================================\n\nIntroducción\n\n* * *\n\n### Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL\n\n![](https://cdn-images-1.medium.com/max/800/0*Uwwpj7DXbcxMeTb7)\n\n### Introducción\n\nEn el mundo del desarrollo de software, los microservicios han ganado popularidad debido a su capacidad para dividir aplicaciones grandes y complejas en partes más pequeñas y manejables. En este blog, exploraremos cómo integrar un servidor NATS (Neural Autonomic Transport System) en una arquitectura de microservicios utilizando NestJS, Docker y PostgreSQL. Para hacerlo más tangible, utilizaremos un caso de uso real de una aplicación de gestión de pedidos.\n\n### Caso de Uso: Aplicación de Gestión de Pedidos\n\nImaginemos que estamos construyendo una aplicación de gestión de pedidos que incluye múltiples servicios, como el servicio de pedidos, el servicio de inventario y el servicio de notificaciones. Estos servicios deben comunicarse entre sí de manera eficiente y confiable. Aquí es donde NATS entra en juego, proporcionando un sistema de mensajería rápida y de bajo retardo.\n\n### Arquitectura de la Aplicación\n\nNuestra aplicación de gestión de pedidos tendrá la siguiente arquitectura:\n\n1.  **Servicio de Pedidos**: Gestiona la creación, actualización y eliminación de pedidos.\n2.  **Servicio de Inventario**: Mantiene el inventario de productos y actualiza las existencias según los pedidos.\n3.  **Servicio de Notificaciones**: Envía notificaciones a los usuarios sobre el estado de sus pedidos.\n\n### Configuración de Docker\n\nPrimero, configuramos Docker para orquestar nuestros servicios. Creamos un archivo `Dockerfile` para nuestro servicio NestJS y un archivo `docker-compose.yml` para definir y ejecutar múltiples contenedores Docker.\n\nFROM node:14  \nWORKDIR /app  \nCOPY package\\*.json ./  \nRUN npm install  \nCOPY . .  \nRUN npm run build  \nEXPOSE 3000  \nCMD \\[\"npm\", \"run\", \"start:prod\"\\]\n\n#### Docker Compose\n\nversion: '3'  \nservices:  \n  postgres:  \n    image: postgres:latest  \n    environment:  \n      POSTGRES\\_USER: user  \n      POSTGRES\\_PASSWORD: password  \n      POSTGRES\\_DB: orders  \n    ports:  \n      \\- \"5432:5432\"  \n    volumes:  \n      \\- postgres-data:/var/lib/postgresql/data  \n  \n  nats:  \n    image: nats:latest  \n    ports:  \n      \\- \"4222:4222\"  \n  \n  orders:  \n    build: .  \n    environment:  \n      DATABASE\\_HOST: postgres  \n      DATABASE\\_PORT: 5432  \n      DATABASE\\_USER: user  \n      DATABASE\\_PASSWORD: password  \n      DATABASE\\_NAME: orders  \n      NATS\\_SERVER: nats://nats:4222  \n    depends\\_on:  \n      \\- postgres  \n      \\- nats  \n    ports:  \n      \\- \"3000:3000\"  \n    \nvolumes:  \n  postgres-data:\n\n### Configuración de NestJS\n\nAhora configuramos nuestro proyecto NestJS para que interactúe con NATS y PostgreSQL.\n\n#### Instalación de Dependencias\n\nnpm install @nestjs/microservices nats @nestjs/typeorm typeorm pg\n\nClaro, aquí tienes un ejemplo de cómo se podría escribir un blog sobre la integración de un servidor NATS en una configuración de microservicios utilizando NestJS, Docker y PostgreSQL, con un caso de uso real.\n\n* * *\n\n### Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL\n\n### Introducción\n\nEn el mundo del desarrollo de software, los microservicios han ganado popularidad debido a su capacidad para dividir aplicaciones grandes y complejas en partes más pequeñas y manejables. En este blog, exploraremos cómo integrar un servidor NATS (Neural Autonomic Transport System) en una arquitectura de microservicios utilizando NestJS, Docker y PostgreSQL. Para hacerlo más tangible, utilizaremos un caso de uso real de una aplicación de gestión de pedidos.\n\n### Caso de Uso: Aplicación de Gestión de Pedidos\n\nImaginemos que estamos construyendo una aplicación de gestión de pedidos que incluye múltiples servicios, como el servicio de pedidos, el servicio de inventario y el servicio de notificaciones. Estos servicios deben comunicarse entre sí de manera eficiente y confiable. Aquí es donde NATS entra en juego, proporcionando un sistema de mensajería rápida y de bajo retardo.\n\n### Arquitectura de la Aplicación\n\nNuestra aplicación de gestión de pedidos tendrá la siguiente arquitectura:\n\n1.  **Servicio de Pedidos**: Gestiona la creación, actualización y eliminación de pedidos.\n2.  **Servicio de Inventario**: Mantiene el inventario de productos y actualiza las existencias según los pedidos.\n3.  **Servicio de Notificaciones**: Envía notificaciones a los usuarios sobre el estado de sus pedidos.\n\n### Configuración de Docker\n\nPrimero, configuramos Docker para orquestar nuestros servicios. Creamos un archivo `Dockerfile` para nuestro servicio NestJS y un archivo `docker-compose.yml` para definir y ejecutar múltiples contenedores Docker.\n\n#### Dockerfile para el servicio NestJS\n\nFROM node:14  \nWORKDIR /app  \nCOPY package\\*.json ./  \nRUN npm install  \nCOPY . .  \nRUN npm run build  \nEXPOSE 3000  \nCMD \\[\"npm\", \"run\", \"start:prod\"\\]\n\n#### Docker Compose\n\nversion: '3'  \nservices:  \n  postgres:  \n    image: postgres:latest  \n    environment:  \n      POSTGRES\\_USER: user  \n      POSTGRES\\_PASSWORD: password  \n      POSTGRES\\_DB: orders  \n    ports:  \n      \\- \"5432:5432\"  \n    volumes:  \n      \\- postgres-data:/var/lib/postgresql/data  \n  \n  nats:  \n    image: nats:latest  \n    ports:  \n      \\- \"4222:4222\"  \n  \n  orders:  \n    build: .  \n    environment:  \n      DATABASE\\_HOST: postgres  \n      DATABASE\\_PORT: 5432  \n      DATABASE\\_USER: user  \n      DATABASE\\_PASSWORD: password  \n      DATABASE\\_NAME: orders  \n      NATS\\_SERVER: nats://nats:4222  \n    depends\\_on:  \n      \\- postgres  \n      \\- nats  \n    ports:  \n      \\- \"3000:3000\"  \n    \nvolumes:  \n  postgres-data:\n\n### Configuración de NestJS\n\nAhora configuramos nuestro proyecto NestJS para que interactúe con NATS y PostgreSQL.\n\n#### Instalación de Dependencias\n\nnpm install @nestjs/microservices nats @nestjs/typeorm typeorm pg\n\n#### Configuración del Microservicio con NATS\n\nConfiguramos el microservicio en el archivo `app.module.ts` para que use NATS como sistema de mensajería.\n\nimport { Module } from '@nestjs/common';  \nimport { ClientsModule, Transport } from '@nestjs/microservices';  \nimport { TypeOrmModule } from '@nestjs/typeorm';  \nimport { AppController } from './app.controller';  \nimport { AppService } from './app.service';  \n  \n@Module({  \n  imports: \\[  \n    ClientsModule.register(\\[  \n      {  \n        name: 'NATS\\_SERVICE',  \n        transport: Transport.NATS,  \n        options: {  \n          url: process.env.NATS\\_SERVER,  \n        },  \n      },  \n    \\]),  \n    TypeOrmModule.forRoot({  \n      type: 'postgres',  \n      host: process.env.DATABASE\\_HOST,  \n      port: parseInt(process.env.DATABASE\\_PORT, 10),  \n      username: process.env.DATABASE\\_USER,  \n      password: process.env.DATABASE\\_PASSWORD,  \n      database: process.env.DATABASE\\_NAME,  \n      entities: \\[\\_\\_dirname + '/\\*\\*/\\*.entity{.ts,.js}'\\],  \n      synchronize: true,  \n    }),  \n  \\],  \n  controllers: \\[AppController\\],  \n  providers: \\[AppService\\],  \n})  \nexport class AppModule {}\n\n#### Uso del Servicio NATS en un Controlador\n\nEn el controlador, usamos NATS para enviar y recibir mensajes.\n\nimport { Controller, Get } from '@nestjs/common';  \nimport { ClientProxy, Client } from '@nestjs/microservices';  \nimport { Observable } from 'rxjs';  \n  \n@Controller()  \nexport class AppController {  \n  @Client({ transport: Transport.NATS, options: { url: process.env.NATS\\_SERVER } })  \n  private client: ClientProxy;  \n  \n  @Get()  \n  getHello(): Observable<string\\> {  \n    return this.client.send<string\\>({ cmd: 'hello' }, {});  \n  }  \n}\n\n### Integración con PostgreSQL\n\nConfiguramos TypeORM para interactuar con PostgreSQL.\n\n#### Configuración de TypeORM\n\nimport { TypeOrmModule } from '@nestjs/typeorm';  \n  \n@Module({  \n  imports: \\[  \n    TypeOrmModule.forRoot({  \n      type: 'postgres',  \n      host: process.env.DATABASE\\_HOST,  \n      port: parseInt(process.env.DATABASE\\_PORT, 10),  \n      username: process.env.DATABASE\\_USER,  \n      password: process.env.DATABASE\\_PASSWORD,  \n      database: process.env.DATABASE\\_NAME,  \n      entities: \\[\\_\\_dirname + '/\\*\\*/\\*.entity{.ts,.js}'\\],  \n      synchronize: true,  \n    }),  \n  \\],  \n  controllers: \\[AppController\\],  \n  providers: \\[AppService\\],  \n})  \nexport class AppModule {}\n\n### Conclusión\n\nCon esta configuración, hemos logrado integrar un servidor NATS en una arquitectura de microservicios utilizando NestJS, Docker y PostgreSQL. Esta integración permite que nuestros servicios se comuniquen de manera eficiente y escalable, lo que es crucial para aplicaciones modernas de microservicios. La configuración de Docker facilita el despliegue y la gestión de cada componente, asegurando que nuestra aplicación sea fácil de mantener y escalar.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [July 12, 2024](https://medium.com/p/51af9319c1d0).\n\n[Canonical link](https://medium.com/@devjaime/integraci%C3%B3n-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql-51af9319c1d0)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"integración-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql","text":"Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL"},{"depth":3,"slug":"integración-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql-1","text":"Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL"},{"depth":3,"slug":"introducción","text":"Introducción"},{"depth":3,"slug":"caso-de-uso-aplicación-de-gestión-depedidos","text":"Caso de Uso: Aplicación de Gestión de Pedidos"},{"depth":3,"slug":"arquitectura-de-la-aplicación","text":"Arquitectura de la Aplicación"},{"depth":3,"slug":"configuración-dedocker","text":"Configuración de Docker"},{"depth":4,"slug":"docker-compose","text":"Docker Compose"},{"depth":3,"slug":"configuración-denestjs","text":"Configuración de NestJS"},{"depth":4,"slug":"instalación-de-dependencias","text":"Instalación de Dependencias"},{"depth":3,"slug":"integración-de-nats-en-una-arquitectura-de-microservicios-con-nestjs-docker-y-postgresql-2","text":"Integración de NATS en una Arquitectura de Microservicios con NestJS, Docker y PostgreSQL"},{"depth":3,"slug":"introducción-1","text":"Introducción"},{"depth":3,"slug":"caso-de-uso-aplicación-de-gestión-depedidos-1","text":"Caso de Uso: Aplicación de Gestión de Pedidos"},{"depth":3,"slug":"arquitectura-de-la-aplicación-1","text":"Arquitectura de la Aplicación"},{"depth":3,"slug":"configuración-dedocker-1","text":"Configuración de Docker"},{"depth":4,"slug":"dockerfile-para-el-servicionestjs","text":"Dockerfile para el servicio NestJS"},{"depth":4,"slug":"docker-compose-1","text":"Docker Compose"},{"depth":3,"slug":"configuración-denestjs-1","text":"Configuración de NestJS"},{"depth":4,"slug":"instalación-de-dependencias-1","text":"Instalación de Dependencias"},{"depth":4,"slug":"configuración-del-microservicio-connats","text":"Configuración del Microservicio con NATS"},{"depth":4,"slug":"uso-del-servicio-nats-en-un-controlador","text":"Uso del Servicio NATS en un Controlador"},{"depth":3,"slug":"integración-con-postgresql","text":"Integración con PostgreSQL"},{"depth":4,"slug":"configuración-detypeorm","text":"Configuración de TypeORM"},{"depth":3,"slug":"conclusión","text":"Conclusión"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
