/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"que-es-vite-y-como-funciona-más-rapido-que-webpack\">Que es Vite y como funciona más rapido que webpack</h1>\n<p>Vite es una herramienta de compilación que tiene como objetivo proporcionar una experiencia de desarrollo más rápida y ágil para proyectos…</p>\n<hr>\n<h3 id=\"que-es-vite-y-como-funciona-más-rapido-quewebpack\">Que es Vite y como funciona más rapido que webpack</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*9je4S8adxijCGILV.jpg\" alt=\"\"></p>\n<p>Vite es una herramienta de compilación que tiene como objetivo proporcionar una experiencia de desarrollo más rápida y ágil para proyectos web modernos. Consta de dos partes principales:</p>\n<ul>\n<li>Un servidor de desarrollo que proporciona <a href=\"https://vitejs.dev/guide/features.html\">amplias mejoras de características</a> sobre <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">los módulos ES nativos , por ejemplo,</a> <a href=\"https://vitejs.dev/guide/features.html#hot-module-replacement\">Hot Module Replacement (HMR)</a> extremadamente rápido .</li>\n<li>Un comando de compilación que agrupa su código con <a href=\"https://rollupjs.org/\">Rollup</a> , preconfigurado para generar activos estáticos altamente optimizados para producción.</li>\n</ul>\n<p>Link oficial: <a href=\"https://vitejs.dev/\">https://vitejs.dev/</a></p>\n<h3 id=\"los-problemas\">Los problemas</h3>\n<p>Antes de que los ES modules estuvieran disponibles en los navegadores, los desarrolladores no tenían un mecanismo nativo para crear JavaScript de forma modular. Es por eso que todos estamos familiarizados con el concepto de “empaquetado”: usar herramientas que rastrean, procesan y concatenan nuestros módulos fuente en archivos que pueden ejecutarse en el navegador.</p>\n<p>Con el tiempo, hemos visto herramientas como <a href=\"https://webpack.js.org/\">webpack</a> , <a href=\"https://rollupjs.org/\">Rollup</a> y <a href=\"https://parceljs.org/\">Parcel</a> , que mejoraron enormemente la experiencia de desarrollo para los desarrolladores frontend.</p>\n<p>Sin embargo, a medida que comenzamos a crear aplicaciones cada vez más ambiciosas, la cantidad de JavaScript con la que nos enfrentamos también aumentó exponencialmente. No es raro que los proyectos a gran escala contengan miles de módulos. Estamos empezando a encontrarnos con un cuello de botella en el rendimiento de las herramientas basadas en JavaScript: a menudo puede llevar una espera excesivamente larga (¡a veces hasta minutos!) poner en marcha un servidor de desarrollo, las ediciones de archivos pueden tardar un par de segundos en reflejarse. en el navegador. El ciclo de retroalimentación lento puede afectar en gran medida la productividad y la felicidad de los desarrolladores.</p>\n<p>Vite tiene como objetivo abordar estos problemas aprovechando los nuevos avances en el ecosistema: la disponibilidad de ES modules nativos en el navegador y el surgimiento de herramientas JavaScript escritas en lenguajes nativos de compilación.</p>\n<h3 id=\"inicio-lento-delservidor\">Inicio lento del servidor</h3>\n<p>Cuando se inicia en frío el servidor de desarrollo, una configuración de compilación basada en un paquete tiene que rastrear y compilar ansiosamente toda la aplicación antes de que se pueda servir.</p>\n<p>Vite mejora el tiempo de inicio del servidor de desarrollo dividiendo primero los módulos de una aplicación en dos categorías: dependencias y código fuente .</p>\n<ul>\n<li>Las dependencias son en su mayoría JavaScript simple que no cambia con frecuencia durante el desarrollo. Algunas dependencias grandes (por ejemplo, bibliotecas de componentes con cientos de módulos) también son bastante caras de procesar. Las dependencias también se pueden enviar en varios formatos de módulos (por ejemplo, ESM o CommonJS).</li>\n<li>Vite preagrupa <a href=\"https://vitejs.dev/guide/dep-pre-bundling.html\">las dependencias</a> mediante <a href=\"https://esbuild.github.io/\">esbuild</a> . esbuild está escrito en Go y preagrupa las dependencias entre 10 y 100 veces más rápido que los paquetes basados ​​en JavaScript.</li>\n<li>El código fuente a menudo contiene JavaScript no simple que necesita transformación (por ejemplo, componentes JSX, CSS o Vue/Svelte), y se editará con mucha frecuencia. Además, no es necesario cargar todo el código fuente al mismo tiempo (por ejemplo, con división de código basada en rutas).</li>\n<li>Vite sirve código fuente sobre <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">ESM nativo</a> . Básicamente, esto permite que el navegador se haga cargo de parte del trabajo de un empaquetador: Vite solo necesita transformar y servir el código fuente a pedido, según lo solicite el navegador. El código detrás de las importaciones dinámicas condicionales solo se procesa si realmente se usa en la pantalla actual.</li>\n</ul>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*EIRXP6Xvfp_8aGWC.png\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*zonVIzsG6kCl3Jo0.png\" alt=\"\"></p>\n<h3 id=\"actualizaciones-lentas\">Actualizaciones lentas</h3>\n<p>Cuando se edita un archivo en una configuración de compilación basada en un paquete, es ineficiente reconstruir todo el paquete por razones obvias: la velocidad de actualización se degradará linealmente con el tamaño de la aplicación.</p>\n<p>En algunos paquetes, el servidor de desarrollo ejecuta el paquete en la memoria, por lo que solo necesita invalidar parte de su gráfico de módulo cuando cambia un archivo, pero aún necesita reconstruir todo el paquete y recargar la página web. Reconstruir el paquete puede ser costoso y recargar la página arruina el estado actual de la aplicación. Esta es la razón por la que algunos paquetes admiten el reemplazo de módulo en caliente (HMR): lo que permite que un módulo se “reemplace en caliente” a sí mismo sin afectar el resto de la página. Esto mejora en gran medida DX; sin embargo, en la práctica hemos descubierto que incluso la velocidad de actualización de HMR se deteriora significativamente a medida que crece el tamaño de la aplicación.</p>\n<p>En Vite, HMR se realiza sobre ESM nativo. Cuando se edita un archivo, Vite solo necesita invalidar con precisión la cadena entre el módulo editado y su límite HMR más cercano (la mayoría de las veces solo el módulo en sí), lo que hace que las actualizaciones de HMR sean consistentemente rápidas, independientemente del tamaño de su aplicación.</p>\n<p>Vite también aprovecha los encabezados HTTP para acelerar las recargas de páginas completas (nuevamente, permita que el navegador haga más trabajo por nosotros): las solicitudes del módulo de código fuente se hacen condicionales a través <code>304 Not Modified</code>de , y las solicitudes del módulo de dependencia se almacenan en caché <code>Cache-Control: max-age=31536000,immutable</code>para que no lleguen al servidor nuevamente. una vez en caché.</p>\n<p>Una vez que experimente lo rápido que es Vite, dudamos mucho que esté dispuesto a soportar nuevamente el desarrollo en paquete.</p>\n<h3 id=\"por-qué-agrupar-para-producción\">Por qué agrupar para producción</h3>\n<p>Aunque el ESM nativo ahora es ampliamente compatible, el envío de ESM desagregado en producción sigue siendo ineficiente (incluso con HTTP/2) debido a los viajes de ida y vuelta de la red adicionales causados ​​por las importaciones anidadas. Para obtener el rendimiento de carga óptimo en producción, aún es mejor agrupar su código con agitación de árboles, carga diferida y división de fragmentos comunes (para un mejor almacenamiento en caché).</p>\n<p>Garantizar un resultado óptimo y una coherencia de comportamiento entre el servidor de desarrollo y la compilación de producción no es fácil. <a href=\"https://vitejs.dev/guide/build.html\">Esta es la razón por la que Vite se envía con un comando de compilación</a> preconfigurado que incluye muchas <a href=\"https://vitejs.dev/guide/features.html#build-optimizations\">optimizaciones</a> de rendimiento listas para usar.</p>\n<h3 id=\"por-qué-no-agrupar-conesbuild\">¿Por qué no agrupar con esbuild?</h3>\n<p>Si bien <code>esbuild</code>es increíblemente rápido y ya es un paquete muy capaz para bibliotecas, algunas de las funciones importantes necesarias para agrupar <em>aplicaciones</em> todavía están en progreso, en particular, la división de código y el manejo de CSS. Por el momento, Rollup es más maduro y flexible en estos aspectos. Dicho esto, no descartaremos la posibilidad de usar <code>esbuild</code>para la construcción de producción cuando estabilice estas características en el futuro.</p>\n<h3 id=\"create-react-app-yvite\">Create React APP y Vite</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*6poDC_xXdTrdpi_z.png\" alt=\"\"></p>\n<p>Lo primero que debe realizar es instalar vite: Recomiendo pnpm (las razones en este articulo) <a href=\"https://medium.com/@devjaime/que-es-pnpm-37553a828c1b\">https://medium.com/@devjaime/que-es-pnpm-37553a828c1b</a></p>\n<p>NPM:</p>\n<p>Yarn:</p>\n<p>PNPM (recomendado)</p>\n<p>Para completar los pasos según su proyecto siga estos pasos</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*am8g-6Us2lZDykgW6UU1QQ.png\" alt=\"\"></p>\n<h3 id=\"creando-la-app-react-js-usandovite\">Creando la App React JS usando Vite</h3>\n<p>Comandos para crear las diferentes versiones</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*Mp4dcjSe-vpNDPMGzoiDbQ.png\" alt=\"\"></p>\n<p>Después de instalar las dependencias, puede iniciar la app con el siguiente comando npm run dev</p>\n<p>Felicdades!!</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/132f45efa4e4\">April 25, 2022</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/que-es-vite-y-como-funciona-m%C3%A1s-rapido-que-webpack-132f45efa4e4\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Que es Vite y como funciona más rapido que webpack","description":"","tags":["code","vite","javascript"],"time":4,"featured":true,"timestamp":"2022-04-25T12:20:31-0300","filename":"2022-04-25_Que-es-Vite-y-como-funciona-m-s-rapido-que-webpack-132f45efa4e4"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2022-04-25_Que-es-Vite-y-como-funciona-m-s-rapido-que-webpack-132f45efa4e4.md";
				const url = "/blog/2022-04-25_Que-es-Vite-y-como-funciona-m-s-rapido-que-webpack-132f45efa4e4";
				function rawContent() {
					return "   \n                                        \n                                                           \n               \n                                    \n       \n              \n                                     \n                                                                                      \n   \n\nQue es Vite y como funciona más rapido que webpack\n==================================================\n\nVite es una herramienta de compilación que tiene como objetivo proporcionar una experiencia de desarrollo más rápida y ágil para proyectos…\n\n* * *\n\n### Que es Vite y como funciona más rapido que webpack\n\n![](https://cdn-images-1.medium.com/max/800/0*9je4S8adxijCGILV.jpg)\n\nVite es una herramienta de compilación que tiene como objetivo proporcionar una experiencia de desarrollo más rápida y ágil para proyectos web modernos. Consta de dos partes principales:\n\n*   Un servidor de desarrollo que proporciona [amplias mejoras de características](https://vitejs.dev/guide/features.html) sobre [los módulos ES nativos , por ejemplo,](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) [Hot Module Replacement (HMR)](https://vitejs.dev/guide/features.html#hot-module-replacement) extremadamente rápido .\n*   Un comando de compilación que agrupa su código con [Rollup](https://rollupjs.org/) , preconfigurado para generar activos estáticos altamente optimizados para producción.\n\nLink oficial: [https://vitejs.dev/](https://vitejs.dev/)\n\n### Los problemas\n\nAntes de que los ES modules estuvieran disponibles en los navegadores, los desarrolladores no tenían un mecanismo nativo para crear JavaScript de forma modular. Es por eso que todos estamos familiarizados con el concepto de “empaquetado”: usar herramientas que rastrean, procesan y concatenan nuestros módulos fuente en archivos que pueden ejecutarse en el navegador.\n\nCon el tiempo, hemos visto herramientas como [webpack](https://webpack.js.org/) , [Rollup](https://rollupjs.org/) y [Parcel](https://parceljs.org/) , que mejoraron enormemente la experiencia de desarrollo para los desarrolladores frontend.\n\nSin embargo, a medida que comenzamos a crear aplicaciones cada vez más ambiciosas, la cantidad de JavaScript con la que nos enfrentamos también aumentó exponencialmente. No es raro que los proyectos a gran escala contengan miles de módulos. Estamos empezando a encontrarnos con un cuello de botella en el rendimiento de las herramientas basadas en JavaScript: a menudo puede llevar una espera excesivamente larga (¡a veces hasta minutos!) poner en marcha un servidor de desarrollo, las ediciones de archivos pueden tardar un par de segundos en reflejarse. en el navegador. El ciclo de retroalimentación lento puede afectar en gran medida la productividad y la felicidad de los desarrolladores.\n\nVite tiene como objetivo abordar estos problemas aprovechando los nuevos avances en el ecosistema: la disponibilidad de ES modules nativos en el navegador y el surgimiento de herramientas JavaScript escritas en lenguajes nativos de compilación.\n\n### Inicio lento del servidor\n\nCuando se inicia en frío el servidor de desarrollo, una configuración de compilación basada en un paquete tiene que rastrear y compilar ansiosamente toda la aplicación antes de que se pueda servir.\n\nVite mejora el tiempo de inicio del servidor de desarrollo dividiendo primero los módulos de una aplicación en dos categorías: dependencias y código fuente .\n\n*   Las dependencias son en su mayoría JavaScript simple que no cambia con frecuencia durante el desarrollo. Algunas dependencias grandes (por ejemplo, bibliotecas de componentes con cientos de módulos) también son bastante caras de procesar. Las dependencias también se pueden enviar en varios formatos de módulos (por ejemplo, ESM o CommonJS).\n*   Vite preagrupa [las dependencias](https://vitejs.dev/guide/dep-pre-bundling.html) mediante [esbuild](https://esbuild.github.io/) . esbuild está escrito en Go y preagrupa las dependencias entre 10 y 100 veces más rápido que los paquetes basados ​​en JavaScript.\n*   El código fuente a menudo contiene JavaScript no simple que necesita transformación (por ejemplo, componentes JSX, CSS o Vue/Svelte), y se editará con mucha frecuencia. Además, no es necesario cargar todo el código fuente al mismo tiempo (por ejemplo, con división de código basada en rutas).\n*   Vite sirve código fuente sobre [ESM nativo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) . Básicamente, esto permite que el navegador se haga cargo de parte del trabajo de un empaquetador: Vite solo necesita transformar y servir el código fuente a pedido, según lo solicite el navegador. El código detrás de las importaciones dinámicas condicionales solo se procesa si realmente se usa en la pantalla actual.\n\n![](https://cdn-images-1.medium.com/max/800/0*EIRXP6Xvfp_8aGWC.png)\n\n![](https://cdn-images-1.medium.com/max/800/0*zonVIzsG6kCl3Jo0.png)\n\n### Actualizaciones lentas\n\nCuando se edita un archivo en una configuración de compilación basada en un paquete, es ineficiente reconstruir todo el paquete por razones obvias: la velocidad de actualización se degradará linealmente con el tamaño de la aplicación.\n\nEn algunos paquetes, el servidor de desarrollo ejecuta el paquete en la memoria, por lo que solo necesita invalidar parte de su gráfico de módulo cuando cambia un archivo, pero aún necesita reconstruir todo el paquete y recargar la página web. Reconstruir el paquete puede ser costoso y recargar la página arruina el estado actual de la aplicación. Esta es la razón por la que algunos paquetes admiten el reemplazo de módulo en caliente (HMR): lo que permite que un módulo se “reemplace en caliente” a sí mismo sin afectar el resto de la página. Esto mejora en gran medida DX; sin embargo, en la práctica hemos descubierto que incluso la velocidad de actualización de HMR se deteriora significativamente a medida que crece el tamaño de la aplicación.\n\nEn Vite, HMR se realiza sobre ESM nativo. Cuando se edita un archivo, Vite solo necesita invalidar con precisión la cadena entre el módulo editado y su límite HMR más cercano (la mayoría de las veces solo el módulo en sí), lo que hace que las actualizaciones de HMR sean consistentemente rápidas, independientemente del tamaño de su aplicación.\n\nVite también aprovecha los encabezados HTTP para acelerar las recargas de páginas completas (nuevamente, permita que el navegador haga más trabajo por nosotros): las solicitudes del módulo de código fuente se hacen condicionales a través `304 Not Modified`de , y las solicitudes del módulo de dependencia se almacenan en caché `Cache-Control: max-age=31536000,immutable`para que no lleguen al servidor nuevamente. una vez en caché.\n\nUna vez que experimente lo rápido que es Vite, dudamos mucho que esté dispuesto a soportar nuevamente el desarrollo en paquete.\n\n### Por qué agrupar para producción\n\nAunque el ESM nativo ahora es ampliamente compatible, el envío de ESM desagregado en producción sigue siendo ineficiente (incluso con HTTP/2) debido a los viajes de ida y vuelta de la red adicionales causados ​​por las importaciones anidadas. Para obtener el rendimiento de carga óptimo en producción, aún es mejor agrupar su código con agitación de árboles, carga diferida y división de fragmentos comunes (para un mejor almacenamiento en caché).\n\nGarantizar un resultado óptimo y una coherencia de comportamiento entre el servidor de desarrollo y la compilación de producción no es fácil. [Esta es la razón por la que Vite se envía con un comando de compilación](https://vitejs.dev/guide/build.html) preconfigurado que incluye muchas [optimizaciones](https://vitejs.dev/guide/features.html#build-optimizations) de rendimiento listas para usar.\n\n### ¿Por qué no agrupar con esbuild?\n\nSi bien `esbuild`es increíblemente rápido y ya es un paquete muy capaz para bibliotecas, algunas de las funciones importantes necesarias para agrupar _aplicaciones_ todavía están en progreso, en particular, la división de código y el manejo de CSS. Por el momento, Rollup es más maduro y flexible en estos aspectos. Dicho esto, no descartaremos la posibilidad de usar `esbuild`para la construcción de producción cuando estabilice estas características en el futuro.\n\n### Create React APP y Vite\n\n![](https://cdn-images-1.medium.com/max/800/0*6poDC_xXdTrdpi_z.png)\n\nLo primero que debe realizar es instalar vite: Recomiendo pnpm (las razones en este articulo) [https://medium.com/@devjaime/que-es-pnpm-37553a828c1b](https://medium.com/@devjaime/que-es-pnpm-37553a828c1b)\n\nNPM:\n\nYarn:\n\nPNPM (recomendado)\n\nPara completar los pasos según su proyecto siga estos pasos\n\n![](https://cdn-images-1.medium.com/max/800/1*am8g-6Us2lZDykgW6UU1QQ.png)\n\n### Creando la App React JS usando Vite\n\nComandos para crear las diferentes versiones\n\n![](https://cdn-images-1.medium.com/max/800/1*Mp4dcjSe-vpNDPMGzoiDbQ.png)\n\nDespués de instalar las dependencias, puede iniciar la app con el siguiente comando npm run dev\n\nFelicdades!!\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [April 25, 2022](https://medium.com/p/132f45efa4e4).\n\n[Canonical link](https://medium.com/@devjaime/que-es-vite-y-como-funciona-m%C3%A1s-rapido-que-webpack-132f45efa4e4)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"que-es-vite-y-como-funciona-más-rapido-que-webpack","text":"Que es Vite y como funciona más rapido que webpack"},{"depth":3,"slug":"que-es-vite-y-como-funciona-más-rapido-quewebpack","text":"Que es Vite y como funciona más rapido que webpack"},{"depth":3,"slug":"los-problemas","text":"Los problemas"},{"depth":3,"slug":"inicio-lento-delservidor","text":"Inicio lento del servidor"},{"depth":3,"slug":"actualizaciones-lentas","text":"Actualizaciones lentas"},{"depth":3,"slug":"por-qué-agrupar-para-producción","text":"Por qué agrupar para producción"},{"depth":3,"slug":"por-qué-no-agrupar-conesbuild","text":"¿Por qué no agrupar con esbuild?"},{"depth":3,"slug":"create-react-app-yvite","text":"Create React APP y Vite"},{"depth":3,"slug":"creando-la-app-react-js-usandovite","text":"Creando la App React JS usando Vite"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
