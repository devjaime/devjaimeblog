/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"implementando-el-patrón-saga-en-microservicios-garantizando-la-integridad-de-las-transacciones\">Implementando el Patrón Saga en Microservicios: Garantizando la Integridad de las Transacciones</h1>\n<p>Los microservicios han revolucionado la forma en que desarrollamos aplicaciones, permitiéndonos descomponer sistemas monolíticos en…</p>\n<hr>\n<h3 id=\"implementando-el-patrón-saga-en-microservicios-garantizando-la-integridad-de-las-transacciones-1\">Implementando el Patrón Saga en Microservicios: Garantizando la Integridad de las Transacciones</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*e8D2X1rjbL8R3iZq.png\" alt=\"\"></p>\n<p>Los microservicios han revolucionado la forma en que desarrollamos aplicaciones, permitiéndonos descomponer sistemas monolíticos en componentes más pequeños y manejables. Sin embargo, este enfoque descentralizado plantea desafíos importantes en lo que respecta a la gestión de transacciones distribuidas. Aquí es donde el patrón Saga entra en juego, ofreciendo una solución eficaz para garantizar la integridad de las transacciones en entornos de microservicios. En este blog, exploraremos qué es el patrón Saga y cómo se puede implementar de manera correcta en microservicios.</p>\n<h3 id=\"qué-es-el-patrónsaga\">¿Qué es el Patrón Saga?</h3>\n<p>El patrón Saga es una estrategia de diseño que se utiliza para mantener la consistencia de las transacciones en sistemas distribuidos. En lugar de depender de una única transacción global que involucra múltiples servicios, el patrón Saga divide la transacción en una serie de pasos más pequeños y autónomos. Cada uno de estos pasos es responsabilidad de un servicio específico y se ejecuta dentro de su propia transacción. Si un paso falla, se desencadena un proceso de compensación para revertir los cambios realizados en los pasos anteriores.</p>\n<h3 id=\"implementación-correcta-del-patrón-saga-en-microservicios\">Implementación Correcta del Patrón Saga en Microservicios</h3>\n<p>A continuación, te presentamos algunos pasos clave para implementar el patrón Saga de manera efectiva en un entorno de microservicios:</p>\n<p>1. Definir los pasos de la transacción:</p>\n<ul>\n<li>Identifica y descompón la transacción en pasos individuales.</li>\n<li>Asigna cada paso a un servicio específico, asegurándote de que sean lo más atómicos posible.</li>\n</ul>\n<p>2. Registrar eventos:</p>\n<ul>\n<li>Utiliza un sistema de registro de eventos para rastrear el progreso de cada paso.</li>\n<li>Los eventos deben contener información relevante sobre la transacción, como el ID de la transacción y el estado del paso.</li>\n</ul>\n<p>3. Implementar la lógica de compensación:</p>\n<ul>\n<li>Para cada paso, define una lógica de compensación que deshaga los cambios realizados en caso de un fallo.</li>\n<li>Las compensaciones deben ser reversibles y seguras.</li>\n</ul>\n<p>4. Coordinar los pasos de la transacción:</p>\n<ul>\n<li>Utiliza una orquestación o una coreografía para coordinar la secuencia de pasos de la transacción.</li>\n<li>En la orquestación, un servicio central se encarga de coordinar los pasos y gestionar el flujo de la transacción.</li>\n<li>En la coreografía, los servicios se comunican entre sí para avanzar en la transacción.</li>\n</ul>\n<p>5. Manejar fallos:</p>\n<ul>\n<li>Implementa un mecanismo para detectar fallos en cada paso y desencadenar la lógica de compensación correspondiente.</li>\n<li>Puedes utilizar un temporizador para detectar inactividad o un sistema de monitoreo para identificar errores.</li>\n</ul>\n<p>6. Garantizar la atomicidad:</p>\n<ul>\n<li>Cada paso debe ser atómico y asegurarse de que se complete antes de continuar con el siguiente.</li>\n<li>Utiliza transacciones de bases de datos si es necesario para garantizar la atomicidad.</li>\n</ul>\n<p>7. Escalabilidad y rendimiento:</p>\n<ul>\n<li>Considera la escalabilidad y el rendimiento al implementar el patrón Saga.</li>\n<li>Puedes utilizar colas de mensajes para gestionar la comunicación entre servicios y garantizar que no se pierdan eventos.</li>\n</ul>\n<p>8. Pruebas y simulaciones:</p>\n<ul>\n<li>Realiza pruebas exhaustivas para garantizar que el patrón Saga funcione correctamente, incluyendo escenarios de fallo y recuperación.</li>\n<li>Simula fallos para verificar la robustez de tu implementación.</li>\n</ul>\n<h3 id=\"implementando-el-patrón-saga-en-microservicios-con-nestjs-redis-y-postgresql\">Implementando el Patrón Saga en Microservicios con NestJS, Redis y PostgreSQL</h3>\n<p>El patrón Saga es una estrategia de diseño que se utiliza para mantener la consistencia de las transacciones en sistemas distribuidos. En este blog, exploraremos cómo implementar el patrón Saga en microservicios utilizando NestJS como marco de desarrollo, Redis como sistema de mensajería y PostgreSQL como base de datos. Esta combinación de tecnologías proporciona una base sólida para crear aplicaciones de microservicios escalables y confiables.</p>\n<h3 id=\"pasos-para-implementar-el-patrón-saga-con-nestjs-redis-y-postgresql\">Pasos para Implementar el Patrón Saga con NestJS, Redis y PostgreSQL</h3>\n<h4 id=\"1-configuración-delentorno\">1. Configuración del Entorno</h4>\n<p>Comencemos configurando nuestro entorno de desarrollo. Asegúrate de tener NestJS instalado y una instancia de Redis y PostgreSQL disponibles. Puedes utilizar Docker para ejecutar contenedores de Redis y PostgreSQL para simplificar esta configuración.</p>\n<p># Instalar NestJS CLI<br>\nnpm install -g @nestjs/cli</p>\n<p># Crear un nuevo proyecto NestJS<br>\nnest new saga-microservices</p>\n<h4 id=\"2-definir-los-pasos-de-la-transacción\">2. Definir los Pasos de la Transacción</h4>\n<p>En tu aplicación NestJS, define los pasos de la transacción como servicios. Por ejemplo, supongamos que estamos construyendo un sistema de procesamiento de pedidos con tres pasos: <code>CrearOrden</code>, <code>PagarOrden</code> y <code>EnviarOrden</code>.</p>\n<p># Crear servicios para cada paso<br>\nnest generate service crear-orden<br>\nnest generate service pagar-orden<br>\nnest generate service enviar-orden</p>\n<h4 id=\"3-registrar-eventos\">3. Registrar Eventos</h4>\n<p>Usa Redis para registrar eventos que representen el progreso de cada paso de la transacción. Cuando un servicio completa su paso, emite un evento en Redis para notificar a los otros servicios.</p>\n<p>// Ejemplo de emisión de evento en NestJS<br>\nimport { Injectable } from ‘@nestjs/common’;<br>\nimport { Client, ClientProxy, Transport } from ‘@nestjs/microservices’;</p>\n<p>@Injectable()<br>\nexport class CrearOrdenService {<br>\nconstructor(    @Client({ transport: Transport.REDIS, options: { url: ‘redis://localhost:6379’ } })<br>\nprivate client: ClientProxy,  ) {}</p>\n<p>async crearOrden() {<br>\n// Lógica para crear la orden</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>// Emitir evento  </span></span>\n<span class=\"line\"><span>this.client.emit('orden\\_creada', { orderId: 123 });  </span></span></code></pre>\n<p>}<br>\n}</p>\n<h4 id=\"4-implementar-la-lógica-de-compensación\">4. Implementar la Lógica de Compensación</h4>\n<p>Cada servicio debe tener una lógica de compensación que deshaga los cambios en caso de un fallo. En nuestro ejemplo, el servicio <code>PagarOrden</code> podría tener una función para revertir un pago si se produce un error en un paso posterior.</p>\n<p>// Ejemplo de lógica de compensación en NestJS<br>\n@Injectable()<br>\nexport class PagarOrdenService {<br>\nasync pagarOrden(orderId: number) {<br>\n// Lógica para pagar la orden</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>// Si ocurre un error en un paso posterior, revertir el pago  </span></span>\n<span class=\"line\"><span>this.client.emit('revertir\\_pago', { orderId });  </span></span></code></pre>\n<p>}<br>\n}</p>\n<h4 id=\"5-coordinar-los-pasos-de-la-transacción\">5. Coordinar los Pasos de la Transacción</h4>\n<p>Utiliza Redis o RabbitMQ para coordinar la secuencia de pasos de la transacción. Un servicio central puede orquestar la transacción o puedes optar por una coreografía donde los servicios se comunican entre sí.</p>\n<h4 id=\"6-manejarfallos\">6. Manejar Fallos</h4>\n<p>Implementa un mecanismo para detectar fallos en cada paso y desencadenar la lógica de compensación correspondiente. Puedes utilizar la biblioteca <code>nestjs-redis</code> para interactuar con Redis y manejar eventos.</p>\n<p># Instalar nestjs-redis<br>\nnpm install nestjs-redis</p>\n<p>// Ejemplo de manejo de eventos con nestjs-redis<br>\nimport { Module } from ‘@nestjs/common’;<br>\nimport { RedisModule } from ‘nestjs-redis’;</p>\n<p>@Module({<br>\nimports: [<br>\nRedisModule.register({<br>\nurl: ‘redis://localhost:6379’,<br>\n}),<br>\n],<br>\n})<br>\nexport class AppModule {}</p>\n<h4 id=\"7-garantizar-la-atomicidad\">7. Garantizar la Atomicidad</h4>\n<p>Cada paso debe ser atómico y asegurarse de que se complete antes de continuar con el siguiente. Utiliza transacciones de PostgreSQL si es necesario para garantizar la atomicidad.</p>\n<h4 id=\"8-escalabilidad-y-rendimiento\">8. Escalabilidad y Rendimiento</h4>\n<p>Considera la escalabilidad y el rendimiento al implementar el patrón Saga. Puedes utilizar colas de mensajes como Redis y un equilibrador de carga para gestionar la comunicación entre servicios y garantizar que no se pierdan eventos.</p>\n<h3 id=\"conclusión\">Conclusión</h3>\n<p>La implementación del patrón Saga en microservicios con NestJS, Redis y PostgreSQL proporciona una base sólida para construir aplicaciones escalables y confiables. Siguiendo los pasos mencionados y aprovechando las características de estas tecnologías, puedes garantizar la integridad de las transacciones en un entorno distribuido. El patrón Saga es una herramienta esencial para abordar los desafíos de la gestión de transacciones en microservicios, y esta implementación te ayudará a aprovechar al máximo su potencial.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/3f3063ea2abc\">October 21, 2023</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/implementando-el-patr%C3%B3n-saga-en-microservicios-garantizando-la-integridad-de-las-transacciones-3f3063ea2abc\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Implementando el Patrón Saga en Microservicios: Garantizando la Integridad de las Transacciones","description":"","tags":["code","microservicios"],"time":4,"featured":true,"timestamp":"2023-10-21T12:20:32-0300","filename":"2023-10-21_Implementando-el-Patr-n-Saga-en-Microservicios--Garantizando-la-Integridad-de-las-Transacciones-3f3063ea2abc"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2023-10-21_Implementando-el-Patr-n-Saga-en-Microservicios--Garantizando-la-Integridad-de-las-Transacciones-3f3063ea2abc.md";
				const url = "/blog/2023-10-21_Implementando-el-Patr-n-Saga-en-Microservicios--Garantizando-la-Integridad-de-las-Transacciones-3f3063ea2abc";
				function rawContent() {
					return "   \n                                        \n                                                                                                        \n               \n                                \n       \n              \n                                     \n                                                                                                                                   \n   \n\nImplementando el Patrón Saga en Microservicios: Garantizando la Integridad de las Transacciones\n===============================================================================================\n\nLos microservicios han revolucionado la forma en que desarrollamos aplicaciones, permitiéndonos descomponer sistemas monolíticos en…\n\n* * *\n\n### Implementando el Patrón Saga en Microservicios: Garantizando la Integridad de las Transacciones\n\n![](https://cdn-images-1.medium.com/max/800/0*e8D2X1rjbL8R3iZq.png)\n\nLos microservicios han revolucionado la forma en que desarrollamos aplicaciones, permitiéndonos descomponer sistemas monolíticos en componentes más pequeños y manejables. Sin embargo, este enfoque descentralizado plantea desafíos importantes en lo que respecta a la gestión de transacciones distribuidas. Aquí es donde el patrón Saga entra en juego, ofreciendo una solución eficaz para garantizar la integridad de las transacciones en entornos de microservicios. En este blog, exploraremos qué es el patrón Saga y cómo se puede implementar de manera correcta en microservicios.\n\n### ¿Qué es el Patrón Saga?\n\nEl patrón Saga es una estrategia de diseño que se utiliza para mantener la consistencia de las transacciones en sistemas distribuidos. En lugar de depender de una única transacción global que involucra múltiples servicios, el patrón Saga divide la transacción en una serie de pasos más pequeños y autónomos. Cada uno de estos pasos es responsabilidad de un servicio específico y se ejecuta dentro de su propia transacción. Si un paso falla, se desencadena un proceso de compensación para revertir los cambios realizados en los pasos anteriores.\n\n### Implementación Correcta del Patrón Saga en Microservicios\n\nA continuación, te presentamos algunos pasos clave para implementar el patrón Saga de manera efectiva en un entorno de microservicios:\n\n1\\. Definir los pasos de la transacción:\n\n*   Identifica y descompón la transacción en pasos individuales.\n*   Asigna cada paso a un servicio específico, asegurándote de que sean lo más atómicos posible.\n\n2\\. Registrar eventos:\n\n*   Utiliza un sistema de registro de eventos para rastrear el progreso de cada paso.\n*   Los eventos deben contener información relevante sobre la transacción, como el ID de la transacción y el estado del paso.\n\n3\\. Implementar la lógica de compensación:\n\n*   Para cada paso, define una lógica de compensación que deshaga los cambios realizados en caso de un fallo.\n*   Las compensaciones deben ser reversibles y seguras.\n\n4\\. Coordinar los pasos de la transacción:\n\n*   Utiliza una orquestación o una coreografía para coordinar la secuencia de pasos de la transacción.\n*   En la orquestación, un servicio central se encarga de coordinar los pasos y gestionar el flujo de la transacción.\n*   En la coreografía, los servicios se comunican entre sí para avanzar en la transacción.\n\n5\\. Manejar fallos:\n\n*   Implementa un mecanismo para detectar fallos en cada paso y desencadenar la lógica de compensación correspondiente.\n*   Puedes utilizar un temporizador para detectar inactividad o un sistema de monitoreo para identificar errores.\n\n6\\. Garantizar la atomicidad:\n\n*   Cada paso debe ser atómico y asegurarse de que se complete antes de continuar con el siguiente.\n*   Utiliza transacciones de bases de datos si es necesario para garantizar la atomicidad.\n\n7\\. Escalabilidad y rendimiento:\n\n*   Considera la escalabilidad y el rendimiento al implementar el patrón Saga.\n*   Puedes utilizar colas de mensajes para gestionar la comunicación entre servicios y garantizar que no se pierdan eventos.\n\n8\\. Pruebas y simulaciones:\n\n*   Realiza pruebas exhaustivas para garantizar que el patrón Saga funcione correctamente, incluyendo escenarios de fallo y recuperación.\n*   Simula fallos para verificar la robustez de tu implementación.\n\n### Implementando el Patrón Saga en Microservicios con NestJS, Redis y PostgreSQL\n\nEl patrón Saga es una estrategia de diseño que se utiliza para mantener la consistencia de las transacciones en sistemas distribuidos. En este blog, exploraremos cómo implementar el patrón Saga en microservicios utilizando NestJS como marco de desarrollo, Redis como sistema de mensajería y PostgreSQL como base de datos. Esta combinación de tecnologías proporciona una base sólida para crear aplicaciones de microservicios escalables y confiables.\n\n### Pasos para Implementar el Patrón Saga con NestJS, Redis y PostgreSQL\n\n#### 1\\. Configuración del Entorno\n\nComencemos configurando nuestro entorno de desarrollo. Asegúrate de tener NestJS instalado y una instancia de Redis y PostgreSQL disponibles. Puedes utilizar Docker para ejecutar contenedores de Redis y PostgreSQL para simplificar esta configuración.\n\n\\# Instalar NestJS CLI  \nnpm install -g @nestjs/cli  \n  \n\\# Crear un nuevo proyecto NestJS  \nnest new saga-microservices\n\n#### 2\\. Definir los Pasos de la Transacción\n\nEn tu aplicación NestJS, define los pasos de la transacción como servicios. Por ejemplo, supongamos que estamos construyendo un sistema de procesamiento de pedidos con tres pasos: `CrearOrden`, `PagarOrden` y `EnviarOrden`.\n\n\\# Crear servicios para cada paso  \nnest generate service crear-orden  \nnest generate service pagar-orden  \nnest generate service enviar-orden\n\n#### 3\\. Registrar Eventos\n\nUsa Redis para registrar eventos que representen el progreso de cada paso de la transacción. Cuando un servicio completa su paso, emite un evento en Redis para notificar a los otros servicios.\n\n// Ejemplo de emisión de evento en NestJS  \nimport { Injectable } from '@nestjs/common';  \nimport { Client, ClientProxy, Transport } from '@nestjs/microservices';  \n  \n@Injectable()  \nexport class CrearOrdenService {  \n  constructor(    @Client({ transport: Transport.REDIS, options: { url: 'redis://localhost:6379' } })  \n    private client: ClientProxy,  ) {}  \n  \n  async crearOrden() {  \n    // Lógica para crear la orden  \n  \n    // Emitir evento  \n    this.client.emit('orden\\_creada', { orderId: 123 });  \n  }  \n}\n\n#### 4\\. Implementar la Lógica de Compensación\n\nCada servicio debe tener una lógica de compensación que deshaga los cambios en caso de un fallo. En nuestro ejemplo, el servicio `PagarOrden` podría tener una función para revertir un pago si se produce un error en un paso posterior.\n\n// Ejemplo de lógica de compensación en NestJS  \n@Injectable()  \nexport class PagarOrdenService {  \n  async pagarOrden(orderId: number) {  \n    // Lógica para pagar la orden  \n  \n    // Si ocurre un error en un paso posterior, revertir el pago  \n    this.client.emit('revertir\\_pago', { orderId });  \n  }  \n}\n\n#### 5\\. Coordinar los Pasos de la Transacción\n\nUtiliza Redis o RabbitMQ para coordinar la secuencia de pasos de la transacción. Un servicio central puede orquestar la transacción o puedes optar por una coreografía donde los servicios se comunican entre sí.\n\n#### 6\\. Manejar Fallos\n\nImplementa un mecanismo para detectar fallos en cada paso y desencadenar la lógica de compensación correspondiente. Puedes utilizar la biblioteca `nestjs-redis` para interactuar con Redis y manejar eventos.\n\n\\# Instalar nestjs-redis  \nnpm install nestjs-redis\n\n// Ejemplo de manejo de eventos con nestjs-redis  \nimport { Module } from '@nestjs/common';  \nimport { RedisModule } from 'nestjs-redis';  \n  \n@Module({  \n  imports: \\[  \n    RedisModule.register({  \n      url: 'redis://localhost:6379',  \n    }),  \n  \\],  \n})  \nexport class AppModule {}\n\n#### 7\\. Garantizar la Atomicidad\n\nCada paso debe ser atómico y asegurarse de que se complete antes de continuar con el siguiente. Utiliza transacciones de PostgreSQL si es necesario para garantizar la atomicidad.\n\n#### 8\\. Escalabilidad y Rendimiento\n\nConsidera la escalabilidad y el rendimiento al implementar el patrón Saga. Puedes utilizar colas de mensajes como Redis y un equilibrador de carga para gestionar la comunicación entre servicios y garantizar que no se pierdan eventos.\n\n### Conclusión\n\nLa implementación del patrón Saga en microservicios con NestJS, Redis y PostgreSQL proporciona una base sólida para construir aplicaciones escalables y confiables. Siguiendo los pasos mencionados y aprovechando las características de estas tecnologías, puedes garantizar la integridad de las transacciones en un entorno distribuido. El patrón Saga es una herramienta esencial para abordar los desafíos de la gestión de transacciones en microservicios, y esta implementación te ayudará a aprovechar al máximo su potencial.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [October 21, 2023](https://medium.com/p/3f3063ea2abc).\n\n[Canonical link](https://medium.com/@devjaime/implementando-el-patr%C3%B3n-saga-en-microservicios-garantizando-la-integridad-de-las-transacciones-3f3063ea2abc)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"implementando-el-patrón-saga-en-microservicios-garantizando-la-integridad-de-las-transacciones","text":"Implementando el Patrón Saga en Microservicios: Garantizando la Integridad de las Transacciones"},{"depth":3,"slug":"implementando-el-patrón-saga-en-microservicios-garantizando-la-integridad-de-las-transacciones-1","text":"Implementando el Patrón Saga en Microservicios: Garantizando la Integridad de las Transacciones"},{"depth":3,"slug":"qué-es-el-patrónsaga","text":"¿Qué es el Patrón Saga?"},{"depth":3,"slug":"implementación-correcta-del-patrón-saga-en-microservicios","text":"Implementación Correcta del Patrón Saga en Microservicios"},{"depth":3,"slug":"implementando-el-patrón-saga-en-microservicios-con-nestjs-redis-y-postgresql","text":"Implementando el Patrón Saga en Microservicios con NestJS, Redis y PostgreSQL"},{"depth":3,"slug":"pasos-para-implementar-el-patrón-saga-con-nestjs-redis-y-postgresql","text":"Pasos para Implementar el Patrón Saga con NestJS, Redis y PostgreSQL"},{"depth":4,"slug":"1-configuración-delentorno","text":"1. Configuración del Entorno"},{"depth":4,"slug":"2-definir-los-pasos-de-la-transacción","text":"2. Definir los Pasos de la Transacción"},{"depth":4,"slug":"3-registrar-eventos","text":"3. Registrar Eventos"},{"depth":4,"slug":"4-implementar-la-lógica-de-compensación","text":"4. Implementar la Lógica de Compensación"},{"depth":4,"slug":"5-coordinar-los-pasos-de-la-transacción","text":"5. Coordinar los Pasos de la Transacción"},{"depth":4,"slug":"6-manejarfallos","text":"6. Manejar Fallos"},{"depth":4,"slug":"7-garantizar-la-atomicidad","text":"7. Garantizar la Atomicidad"},{"depth":4,"slug":"8-escalabilidad-y-rendimiento","text":"8. Escalabilidad y Rendimiento"},{"depth":3,"slug":"conclusión","text":"Conclusión"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
