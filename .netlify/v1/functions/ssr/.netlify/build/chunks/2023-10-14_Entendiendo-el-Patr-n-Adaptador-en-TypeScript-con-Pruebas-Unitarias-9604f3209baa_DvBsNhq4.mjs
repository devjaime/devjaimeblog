/* empty css                                                                    */
import { d as createComponent, i as renderComponent, r as renderTemplate, u as unescapeHTML } from './astro/server_C7nAViGe.mjs';
import 'kleur/colors';
import { $ as $$BlogLayout } from './BlogLayout_COI89YL8.mjs';

const html = () => "<h1 id=\"entendiendo-el-patrón-adaptador-en-typescript-con-pruebas-unitarias\">Entendiendo el Patrón Adaptador en TypeScript con Pruebas Unitarias</h1>\n<p>El patrón Adaptador es un patrón de diseño estructural utilizado para hacer que una interfaz sea compatible con otra. Permite que objetos…</p>\n<hr>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/0*JYV6UA5J8l2MF3AX.jpg\" alt=\"\"></p>\n<h3 id=\"entendiendo-el-patrón-adaptador-en-typescript-con-pruebas-unitarias-1\">Entendiendo el Patrón Adaptador en TypeScript con Pruebas Unitarias</h3>\n<p>El patrón Adaptador es un patrón de diseño estructural utilizado para hacer que una interfaz sea compatible con otra. Permite que objetos con interfaces incompatibles trabajen juntos. En este blog, exploraremos el patrón Adaptador en TypeScript y cómo implementar pruebas unitarias para garantizar su corrección.</p>\n<h3 id=\"comprendiendo-el-patrón-adaptador\">Comprendiendo el Patrón Adaptador</h3>\n<p>El patrón Adaptador implica la creación de una clase, conocida como el adaptador, que actúa como un puente entre dos interfaces incompatibles. Permite que las clases con diferentes interfaces trabajen juntas de manera fluida. Este patrón es especialmente útil al integrar bibliotecas externas, trabajar con código heredado o garantizar la interoperabilidad.</p>\n<h4 id=\"componentes-del-patrón-adaptador\">Componentes del Patrón Adaptador</h4>\n<ol>\n<li>Objetivo (Target): Esta es la interfaz con la que el código cliente espera trabajar.</li>\n<li>Adaptee: Esta es la clase que debe adaptarse para ajustarse a la interfaz objetivo.</li>\n<li>Adaptador: Esta es la clase que une la brecha entre el objetivo y el adaptee al implementar la interfaz objetivo y delegar las llamadas al adaptee.</li>\n</ol>\n<h3 id=\"implementación-del-patrón-adaptador-en-typescript\">Implementación del Patrón Adaptador en TypeScript</h3>\n<p>Consideremos un ejemplo práctico en el que queremos adaptar una clase que proporciona datos meteorológicos en grados Fahrenheit para que funcione con una clase que espera datos en grados Celsius. Aquí tienes el código TypeScript para este escenario:</p>\n<p>// Interfaz objetivo<br>\ninterface TemperaturaEnCelsius {<br>\nobtenerTemperaturaEnCelsius(): number;<br>\n}</p>\n<p>// Adaptee<br>\nclass TemperaturaEnFahrenheit {<br>\nconstructor(private temperaturaEnFahrenheit: number) {}</p>\n<p>obtenerTemperaturaEnFahrenheit(): number {<br>\nreturn this.temperaturaEnFahrenheit;<br>\n}<br>\n}</p>\n<p>// Adaptador<br>\nclass AdaptadorDeTemperatura implements TemperaturaEnCelsius {<br>\nconstructor(private adaptee: TemperaturaEnFahrenheit) {}</p>\n<p>obtenerTemperaturaEnCelsius(): number {<br>\n// Adaptar de Fahrenheit a Celsius<br>\nreturn (this.adaptee.obtenerTemperaturaEnFahrenheit() - 32) / 1.8;<br>\n}<br>\n}</p>\n<p>En este ejemplo, la clase <code>AdaptadorDeTemperatura</code> nos permite utilizar la clase <code>TemperaturaEnFahrenheit</code> como si implementara la interfaz <code>TemperaturaEnCelsius</code>.</p>\n<h3 id=\"implementación-de-pruebas-unitarias-para-el-adaptador\">Implementación de Pruebas Unitarias para el Adaptador</h3>\n<p>Ahora, implementemos pruebas unitarias para garantizar la corrección de nuestra implementación del patrón Adaptador. Utilizaremos el popular framework de pruebas, Jest, para este propósito.</p>\n<p># Instalar Jest<br>\nnpm install —save-dev jest @types/jest ts-jest</p>\n<p># Crear un archivo de pruebas, por ejemplo, temperatureAdapter.test.ts</p>\n<p>Aquí tienes una prueba unitaria de muestra para nuestro <code>AdaptadorDeTemperatura</code>:</p>\n<p>// temperatureAdapter.test.ts<br>\nimport { TemperaturaEnFahrenheit, AdaptadorDeTemperatura } from ’./temperatureAdapter’;</p>\n<p>describe(‘AdaptadorDeTemperatura’, () => {<br>\nit(‘debería adaptar la temperatura en Fahrenheit a Celsius’, () => {<br>\nconst temperaturaFahrenheit = new TemperaturaEnFahrenheit(32); // 32°F<br>\nconst adaptador = new AdaptadorDeTemperatura(temperaturaFahrenheit);</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>const resultado = adaptador.obtenerTemperaturaEnCelsius();  </span></span>\n<span class=\"line\"><span>expect(resultado).toBe(0); // 0°C  </span></span></code></pre>\n<p>});<br>\n});</p>\n<p>Para ejecutar las pruebas, agrega el siguiente script a tu archivo <code>package.json</code>:</p>\n<p>“scripts”: {<br>\n“test”: “jest”<br>\n}</p>\n<p>Luego, ejecuta las pruebas con <code>npm test</code>.</p>\n<h3 id=\"conclusión\">Conclusión</h3>\n<p>El patrón Adaptador es una herramienta valiosa para lograr la compatibilidad entre interfaces incompatibles en TypeScript. Al implementar pruebas unitarias, puedes asegurarte de que tus adaptadores funcionen correctamente, incluso a medida que tu código evoluciona. Este blog ha proporcionado una introducción al patrón Adaptador y ha demostrado cómo implementar pruebas unitarias en TypeScript para verificar su funcionalidad.</p>\n<p>By <a href=\"https://medium.com/@devjaime\">Jaime Hernández</a> on <a href=\"https://medium.com/p/9604f3209baa\">October 14, 2023</a>.</p>\n<p><a href=\"https://medium.com/@devjaime/entendiendo-el-patr%C3%B3n-adaptador-en-typescript-con-pruebas-unitarias-9604f3209baa\">Canonical link</a></p>\n<p>Exported from <a href=\"https://medium.com\">Medium</a> on March 15, 2025.</p>";

				const frontmatter = {"layout":"../../layouts/BlogLayout.astro","title":"Entendiendo el Patrón Adaptador en TypeScript con Pruebas Unitarias","description":"","tags":["code","TypeScript","TestUnit"],"time":4,"featured":true,"timestamp":"2023-10-14T12:20:32-0300","filename":"2023-10-14_Entendiendo-el-Patr-n-Adaptador-en-TypeScript-con-Pruebas-Unitarias-9604f3209baa"};
				const file = "/Users/devjaime/Documents/devjaimeblog/src/pages/blog/2023-10-14_Entendiendo-el-Patr-n-Adaptador-en-TypeScript-con-Pruebas-Unitarias-9604f3209baa.md";
				const url = "/blog/2023-10-14_Entendiendo-el-Patr-n-Adaptador-en-TypeScript-con-Pruebas-Unitarias-9604f3209baa";
				function rawContent() {
					return "   \n                                        \n                                                                            \n               \n                                        \n       \n              \n                                     \n                                                                                                       \n   \n\n\nEntendiendo el Patrón Adaptador en TypeScript con Pruebas Unitarias\n===================================================================\n\nEl patrón Adaptador es un patrón de diseño estructural utilizado para hacer que una interfaz sea compatible con otra. Permite que objetos…\n\n* * *\n\n![](https://cdn-images-1.medium.com/max/800/0*JYV6UA5J8l2MF3AX.jpg)\n\n### Entendiendo el Patrón Adaptador en TypeScript con Pruebas Unitarias\n\nEl patrón Adaptador es un patrón de diseño estructural utilizado para hacer que una interfaz sea compatible con otra. Permite que objetos con interfaces incompatibles trabajen juntos. En este blog, exploraremos el patrón Adaptador en TypeScript y cómo implementar pruebas unitarias para garantizar su corrección.\n\n### Comprendiendo el Patrón Adaptador\n\nEl patrón Adaptador implica la creación de una clase, conocida como el adaptador, que actúa como un puente entre dos interfaces incompatibles. Permite que las clases con diferentes interfaces trabajen juntas de manera fluida. Este patrón es especialmente útil al integrar bibliotecas externas, trabajar con código heredado o garantizar la interoperabilidad.\n\n#### Componentes del Patrón Adaptador\n\n1.  Objetivo (Target): Esta es la interfaz con la que el código cliente espera trabajar.\n2.  Adaptee: Esta es la clase que debe adaptarse para ajustarse a la interfaz objetivo.\n3.  Adaptador: Esta es la clase que une la brecha entre el objetivo y el adaptee al implementar la interfaz objetivo y delegar las llamadas al adaptee.\n\n### Implementación del Patrón Adaptador en TypeScript\n\nConsideremos un ejemplo práctico en el que queremos adaptar una clase que proporciona datos meteorológicos en grados Fahrenheit para que funcione con una clase que espera datos en grados Celsius. Aquí tienes el código TypeScript para este escenario:\n\n// Interfaz objetivo  \ninterface TemperaturaEnCelsius {  \n  obtenerTemperaturaEnCelsius(): number;  \n}  \n  \n// Adaptee  \nclass TemperaturaEnFahrenheit {  \n  constructor(private temperaturaEnFahrenheit: number) {}  \n  \n  obtenerTemperaturaEnFahrenheit(): number {  \n    return this.temperaturaEnFahrenheit;  \n  }  \n}  \n  \n// Adaptador  \nclass AdaptadorDeTemperatura implements TemperaturaEnCelsius {  \n  constructor(private adaptee: TemperaturaEnFahrenheit) {}  \n  \n  obtenerTemperaturaEnCelsius(): number {  \n    // Adaptar de Fahrenheit a Celsius  \n    return (this.adaptee.obtenerTemperaturaEnFahrenheit() - 32) / 1.8;  \n  }  \n}\n\nEn este ejemplo, la clase `AdaptadorDeTemperatura` nos permite utilizar la clase `TemperaturaEnFahrenheit` como si implementara la interfaz `TemperaturaEnCelsius`.\n\n### Implementación de Pruebas Unitarias para el Adaptador\n\nAhora, implementemos pruebas unitarias para garantizar la corrección de nuestra implementación del patrón Adaptador. Utilizaremos el popular framework de pruebas, Jest, para este propósito.\n\n\\# Instalar Jest  \nnpm install --save-dev jest @types/jest ts-jest  \n  \n\\# Crear un archivo de pruebas, por ejemplo, temperatureAdapter.test.ts\n\nAquí tienes una prueba unitaria de muestra para nuestro `AdaptadorDeTemperatura`:\n\n// temperatureAdapter.test.ts  \nimport { TemperaturaEnFahrenheit, AdaptadorDeTemperatura } from './temperatureAdapter';  \n  \ndescribe('AdaptadorDeTemperatura', () => {  \n  it('debería adaptar la temperatura en Fahrenheit a Celsius', () => {  \n    const temperaturaFahrenheit = new TemperaturaEnFahrenheit(32); // 32°F  \n    const adaptador = new AdaptadorDeTemperatura(temperaturaFahrenheit);  \n  \n    const resultado = adaptador.obtenerTemperaturaEnCelsius();  \n    expect(resultado).toBe(0); // 0°C  \n  });  \n});\n\nPara ejecutar las pruebas, agrega el siguiente script a tu archivo `package.json`:\n\n\"scripts\": {  \n  \"test\": \"jest\"  \n}\n\nLuego, ejecuta las pruebas con `npm test`.\n\n### Conclusión\n\nEl patrón Adaptador es una herramienta valiosa para lograr la compatibilidad entre interfaces incompatibles en TypeScript. Al implementar pruebas unitarias, puedes asegurarte de que tus adaptadores funcionen correctamente, incluso a medida que tu código evoluciona. Este blog ha proporcionado una introducción al patrón Adaptador y ha demostrado cómo implementar pruebas unitarias en TypeScript para verificar su funcionalidad.\n\nBy [Jaime Hernández](https://medium.com/@devjaime) on [October 14, 2023](https://medium.com/p/9604f3209baa).\n\n[Canonical link](https://medium.com/@devjaime/entendiendo-el-patr%C3%B3n-adaptador-en-typescript-con-pruebas-unitarias-9604f3209baa)\n\nExported from [Medium](https://medium.com) on March 15, 2025.";
				}
				async function compiledContent() {
					return await html();
				}
				function getHeadings() {
					return [{"depth":1,"slug":"entendiendo-el-patrón-adaptador-en-typescript-con-pruebas-unitarias","text":"Entendiendo el Patrón Adaptador en TypeScript con Pruebas Unitarias"},{"depth":3,"slug":"entendiendo-el-patrón-adaptador-en-typescript-con-pruebas-unitarias-1","text":"Entendiendo el Patrón Adaptador en TypeScript con Pruebas Unitarias"},{"depth":3,"slug":"comprendiendo-el-patrón-adaptador","text":"Comprendiendo el Patrón Adaptador"},{"depth":4,"slug":"componentes-del-patrón-adaptador","text":"Componentes del Patrón Adaptador"},{"depth":3,"slug":"implementación-del-patrón-adaptador-en-typescript","text":"Implementación del Patrón Adaptador en TypeScript"},{"depth":3,"slug":"implementación-de-pruebas-unitarias-para-el-adaptador","text":"Implementación de Pruebas Unitarias para el Adaptador"},{"depth":3,"slug":"conclusión","text":"Conclusión"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html())}`
							})}`;
				});

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Content,
	compiledContent,
	default: Content,
	file,
	frontmatter,
	getHeadings,
	rawContent,
	url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page as _ };
